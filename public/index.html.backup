<!DOCTYPE html>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Alex Library</title>
        <!-- Bootstrap 5 CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
        <style>
            /* Custom styles - minimal overrides for Bootstrap */
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft JhengHei", sans-serif;
                background: #f5f5f5;
                padding: 20px;
            }
            
            .main-container {
                max-width: 1400px;
                margin: 0 auto;
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                overflow: hidden;
            }
            
            .header-icon {
                width: 32px;
                height: 32px;
            }
            
            /* Tab content visibility */
            .tab-content {
                display: none;
            }
            .tab-content.active {
                display: block;
            }
            
            /* Queue items with border-left indicators */
            .queue-item.processing {
                border-left: 4px solid #007bff !important;
            }
            .queue-item.completed {
                border-left: 4px solid #28a745 !important;
            }
            .queue-item.error {
                border-left: 4px solid #dc3545 !important;
            }
            
            /* Thread items */
            .thread-item:hover {
                background: #f9f9f9;
            }
            
            /* Badges */
            .chapter-badge, .book-badge {
                margin-left: 10px;
            }
            
            /* Selection section */
            .selection-section {
                display: none;
            }
            .selection-section.active {
                display: block;
            }
            
            /* Books table row selection */
            .books-table tbody tr.selected {
                background: #f0f7ff;
                border-color: #007bff;
            }
            .books-table tbody tr.selected:hover {
                background: #e6f2ff;
            }
            
            /* Rating stars */
            .rating-stars {
                gap: 2px;
                cursor: pointer;
                user-select: none;
            }
            .rating-star {
                font-size: 20px;
                color: #ddd;
                transition: color 0.2s;
            }
            .rating-star.active {
                color: #ffc107;
            }
            .rating-star:hover {
                color: #ffc107;
            }
            
            /* Sortable table headers */
            .books-table th.sortable {
                cursor: pointer;
                position: relative;
                padding-right: 25px;
            }
            .books-table th.sortable::after {
                content: "â‡…";
                position: absolute;
                right: 8px;
                opacity: 0.5;
                font-size: 14px;
            }
            .books-table th.sort-asc::after {
                content: "â†‘";
                opacity: 1;
            }
            .books-table th.sort-desc::after {
                content: "â†“";
                opacity: 1;
            }
            
            /* Results list scroll */
            .results-list {
                max-height: 600px;
                overflow-y: auto;
            }
            
            /* Book autocomplete */
            .book-autocomplete {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                border-top: none;
                border-radius: 0 0 4px 4px;
                max-height: 300px;
                overflow-y: auto;
                z-index: 1000;
            }
            .book-autocomplete-item-highlight {
                background: #fff3cd;
                font-weight: 600;
            }
            
            /* Bulk actions */
            .bulk-actions {
                position: sticky;
                bottom: 0;
                border-top: 2px solid #eee;
                display: none;
            }
            .bulk-actions.active {
                display: flex;
            }
            
            /* Upload area */
            .upload-area {
                border: 2px dashed #ddd;
                transition: all 0.3s;
                cursor: pointer;
            }
            .upload-area:hover {
                border-color: #007bff;
                background: #f0f7ff;
            }
            .upload-area.dragover {
                border-color: #007bff;
                background: #e7f3ff;
            }
            .upload-area-icon {
                font-size: 48px;
                color: #999;
            }
            
            /* Progress modal */
            .progress-modal {
                display: none;
            }
            .progress-modal.active {
                display: flex;
            }
            
            /* Custom modal (for draggable) */
            .modal {
                display: none;
            }
            .modal.active {
                display: flex;
            }
            
            /* Progress content draggable */
            .progress-content.draggable {
                cursor: move;
            }
            .progress-header {
                cursor: move;
                user-select: none;
            }
            
            /* Custom progress bar */
            .progress-bar-container {
                height: 30px;
                border-radius: 15px;
            }
            .progress-bar {
                height: 100%;
                transition: width 0.3s;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 12px;
            }
            
            /* Progress logs */
            .progress-logs {
                max-height: 300px;
                overflow-y: auto;
                font-family: monospace;
                font-size: 12px;
            }
            .progress-log-item.error {
                color: #dc3545;
            }
            .progress-log-item.success {
                color: #28a745;
            }
            
            /* Bot status indicator */
            .bot-status-indicator {
                margin-left: 15px;
            }
            .bot-status-indicator.active {
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.7; }
            }
            
            /* Operation cards */
            .operation-card.active {
                border-left: 4px solid #007bff !important;
            }
            .operation-card.completed {
                border-left: 4px solid #28a745 !important;
            }
            .operation-card.failed {
                border-left: 4px solid #dc3545 !important;
            }
            
            /* Operation type badges */
            .operation-type-badge.search {
                background: #17a2b8;
                color: white;
            }
            .operation-type-badge.download {
                background: #007bff;
                color: white;
            }
            .operation-type-badge.upload {
                background: #ffc107;
                color: #333;
            }
            .operation-type-badge.export {
                background: #28a745;
                color: white;
            }
            
            /* Operation progress fill */
            .operation-progress-fill {
                height: 100%;
                transition: width 0.3s;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 11px;
            }
            .operation-progress-fill.completed {
                background: #28a745;
            }
            .operation-progress-fill.failed {
                background: #dc3545;
            }
        </style>
    </head>
    <body>
        <div class="main-container">
            <div class="bg-primary text-white p-3">
                <h1 class="h4 mb-0 d-flex align-items-center gap-2">
                    <a
                        href="https://game-icons.net/1x1/lorc/cat.html"
                        target="_blank"
                        rel="noopener noreferrer"
                        class="text-white text-decoration-none"
                    >
                        <img
                            src="https://game-icons.net/icons/000000/transparent/1x1/lorc/cat.svg"
                            alt="Cat Icon"
                            class="header-icon"
                            style="filter: brightness(0) invert(1)"
                        />
                    </a>
                    Alex Library
                    <span id="botStatusIndicator" class="badge bg-secondary bot-status-indicator">é–’ç½®</span>
                </h1>
            </div>

            <ul class="nav nav-tabs bg-light" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" onclick="switchTab('search')" type="button">æœå°‹</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" onclick="switchTab('results')" type="button">æœå°‹çµæœ</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" onclick="switchTab('books')" type="button">æ›¸ç±</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" onclick="switchTab('chapters')" type="button">ç« ç¯€</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" onclick="switchTab('chunks')" type="button">åˆ†å¡Šé è¦½</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" onclick="switchTab('upload')" type="button">ä¸Šå‚³æª”æ¡ˆ</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" onclick="switchTab('botStatus')" type="button">æ©Ÿå™¨äººç‹€æ…‹</button>
                </li>
            </ul>

            <!-- Search Tab -->
            <div id="searchTab" class="tab-content active p-4">
                <div class="d-flex gap-2 mb-4">
                    <input
                        type="text"
                        id="searchInput"
                        class="form-control"
                        placeholder="è¼¸å…¥é—œéµå­—æœå°‹ (ä¾‹å¦‚: éƒ½å¸‚ã€å¤è£)"
                        onkeypress="if(event.key==='Enter') addToQueue()"
                    />
                    <button id="searchBtn" class="btn btn-primary" onclick="addToQueue()">
                        åŠ å…¥æœå°‹ä½‡åˆ—
                    </button>
                    <button
                        class="btn btn-secondary"
                        onclick="triggerSearchHtmlUpload()"
                    >
                        åŒ¯å…¥æœå°‹HTML
                    </button>
                    <input
                        type="file"
                        id="searchHtmlInput"
                        class="d-none"
                        accept=".html,.htm,.txt"
                    />
                </div>
                <div id="status" class="alert d-none"></div>

                <div class="bg-light p-3 rounded">
                    <h3 class="h5 mb-3">æœå°‹ä½‡åˆ—</h3>
                    <div id="queueList"></div>
                </div>
            </div>

            <!-- Results Tab -->
            <div id="resultsTab" class="tab-content p-4">
                <div class="d-flex justify-content-between align-items-start mb-3 pb-2 border-bottom">
                    <h3 class="h5 mb-0">æœå°‹çµæœ</h3>
                    <div class="d-flex align-items-center gap-3 flex-wrap">
                        <div class="d-flex align-items-center gap-2">
                            <label class="mb-0">é¸æ“‡æ›¸ç±ï¼š</label>
                            <select
                                id="bookSelector"
                                class="form-select form-select-sm"
                                onchange="toggleBookNameInput()"
                            >
                                <option value="new">å»ºç«‹æ–°æ›¸ç±</option>
                                <option value="from-url">å¾æœå°‹ç¶²å€å»ºç«‹</option>
                            </select>
                            <input
                                type="text"
                                id="newBookName"
                                class="form-control form-control-sm"
                                placeholder="æ–°æ›¸ç±åç¨± (ç°¡é«”ä¸­æ–‡)"
                                style="display: none"
                            />
                        </div>
                        <button
                            onclick="startDownload()"
                            id="downloadBtn"
                            class="btn btn-primary btn-sm"
                            disabled
                        >
                            ä¸‹è¼‰é¸ä¸­çš„ç« ç¯€
                        </button>
                    </div>
                </div>
                <div
                    id="searchUrlDisplay"
                    class="alert alert-info d-none mb-3 border-start border-primary border-4"
                >
                    <div class="small text-muted mb-1">ç›®æ¨™ç¶²å€ï¼š</div>
                    <div>
                        <a
                            id="searchUrlLink"
                            href="#"
                            target="_blank"
                            rel="noopener noreferrer"
                            class="text-break"
                        >
                            <span id="searchUrlText"></span>
                        </a>
                        <button
                            onclick="copySearchUrl()"
                            class="btn btn-sm btn-secondary ms-2"
                        >
                            è¤‡è£½
                        </button>
                    </div>
                </div>
                <div id="resultsList" class="results-list"></div>

                <div id="selectionSection" class="selection-section bg-light p-3 rounded mt-3">
                    <div class="fw-bold text-primary" id="selectedCount">
                        å·²é¸æ“‡ 0 å€‹ç« ç¯€
                    </div>
                </div>
            </div>

            <!-- Book Metadata Modal -->
            <div id="bookMetadataModal" class="progress-modal">
                <div id="bookMetadataModalContent" class="progress-content" style="max-width: 700px">
                    <div class="progress-header" id="bookMetadataModalHeader">
                        <h3>ç¢ºèªæ›¸ç±è³‡è¨Š</h3>
                        <button
                            onclick="closeBookMetadataModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div style="margin-bottom: 20px">
                        <p style="color: #666; margin-bottom: 15px">
                            è«‹ç¢ºèªä¸¦ç·¨è¼¯ä»¥ä¸‹è³‡è¨Šï¼Œé€™äº›è³‡è¨Šå°‡ç”¨æ–¼å»ºç«‹æ–°æ›¸ç±ï¼š
                        </p>
                        <form id="bookMetadataForm">
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >æ›¸åï¼ˆç°¡é«”ï¼‰:</label
                                >
                                <input
                                    type="text"
                                    id="metadataBookName"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                    required
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >æ›¸åï¼ˆç¹é«”ï¼‰:</label
                                >
                                <input
                                    type="text"
                                    id="metadataBookNameTraditional"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >ä½œè€…:</label
                                >
                                <input
                                    type="text"
                                    id="metadataAuthor"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >é¡åˆ¥:</label
                                >
                                <input
                                    type="text"
                                    id="metadataCategory"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >æ¨™ç±¤ï¼ˆç”¨é€—è™Ÿåˆ†éš”ï¼‰:</label
                                >
                                <input
                                    type="text"
                                    id="metadataTags"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                    placeholder="ä¾‹å¦‚: å°èªª, éƒ½å¸‚, æˆäºº"
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >æè¿°:</label
                                >
                                <textarea
                                    id="metadataDescription"
                                    rows="4"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                        resize: vertical;
                                    "
                                ></textarea>
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >ä¾†æºç¶²å€:</label
                                >
                                <input
                                    type="text"
                                    id="metadataSourceUrl"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                    placeholder="ç« ç¯€æˆ–æ›¸ç±ä¾†æºç¶²å€"
                                />
                            </div>
                        </form>
                    </div>
                    <div
                        style="
                            display: flex;
                            gap: 10px;
                            justify-content: flex-end;
                        "
                    >
                        <button
                            onclick="closeBookMetadataModal()"
                            style="
                                padding: 10px 20px;
                                background: #6c757d;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            å–æ¶ˆ
                        </button>
                        <button
                            onclick="confirmBookMetadata()"
                            style="
                                padding: 10px 20px;
                                background: #007bff;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            ç¢ºèªä¸¦é–‹å§‹ä¸‹è¼‰
                        </button>
                    </div>
                </div>
            </div>

            <!-- Book Details Modal -->
            <div id="bookDetailsModal" class="progress-modal">
                <div
                    class="progress-content"
                    style="max-width: 900px; max-height: 80vh"
                >
                    <div class="progress-header">
                        <h3 id="bookDetailsTitle">æ›¸ç±è©³æƒ…</h3>
                        <button
                            onclick="closeBookDetailsModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div
                        style="
                            margin-bottom: 20px;
                            max-height: 60vh;
                            overflow-y: auto;
                        "
                    >
                        <div id="bookDetailsContent"></div>
                    </div>
                    <div
                        style="
                            display: flex;
                            gap: 10px;
                            justify-content: flex-end;
                        "
                    >
                        <button
                            onclick="rescanBookChapters()"
                            id="rescanChaptersBtn"
                            style="
                                padding: 10px 20px;
                                background: #28a745;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            é‡æ–°æƒæç« ç¯€è³‡è¨Š
                        </button>
                        <button
                            onclick="closeBookDetailsModal()"
                            style="
                                padding: 10px 20px;
                                background: #6c757d;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            é—œé–‰
                        </button>
                    </div>
                </div>
            </div>

            <!-- Missing Chapters Modal -->
            <div id="missingChaptersModal" class="progress-modal">
                <div class="progress-content" style="max-width: 800px">
                    <div class="progress-header">
                        <h3>ç¼ºå¤±ç« ç¯€æœå°‹çµæœ</h3>
                        <button
                            onclick="closeMissingChaptersModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div id="missingChaptersContent"></div>
                </div>
            </div>

            <!-- Progress Modal -->
            <div id="progressModal" class="progress-modal">
                <div class="progress-content">
                    <div class="progress-header">
                        <h3>ä¸‹è¼‰é€²åº¦</h3>
                        <button
                            onclick="closeProgressModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div class="progress-bar-container">
                        <div
                            id="progressBar"
                            class="progress-bar"
                            style="width: 0%"
                        >
                            0%
                        </div>
                    </div>
                    <div id="progressStats" style="margin-bottom: 15px">
                        <div>
                            å·²å®Œæˆ: <span id="progressCompleted">0</span> /
                            <span id="progressTotal">0</span>
                        </div>
                        <div>å¤±æ•—: <span id="progressFailed">0</span></div>
                    </div>
                    <div class="progress-logs" id="progressLogs"></div>
                </div>
            </div>

            <!-- Upload Tab -->
            <div id="uploadTab" class="tab-content">
                <div class="results-header">
                    <h3>ä¸Šå‚³æª”æ¡ˆè™•ç†</h3>
                </div>
                <p style="margin-bottom: 20px; color: #666">
                    æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ï¼šhtml.txt (è«–å£‡ç´¢å¼•)ã€å–®ä¸€åŸ·è¡Œç·’
                    HTMLã€raw.txtã€pre_content_0.md
                </p>

                <div
                    class="upload-area"
                    id="uploadArea"
                    onclick="document.getElementById('fileInput').click()"
                >
                    <div class="upload-area-icon">ğŸ“</div>
                    <div class="upload-area-text">é»æ“Šæˆ–æ‹–æ”¾æª”æ¡ˆåˆ°æ­¤è™•ä¸Šå‚³</div>
                    <div class="upload-area-hint">æ”¯æ´å¤šæª”æ¡ˆä¸Šå‚³</div>
                </div>
                <input
                    type="file"
                    id="fileInput"
                    class="file-input"
                    multiple
                    accept=".txt,.html,.md"
                    onchange="handleFileSelect(event)"
                />

                <div
                    id="uploadStatus"
                    class="status"
                    style="display: none"
                ></div>

                <div
                    class="uploaded-files"
                    id="uploadedFiles"
                    style="display: none"
                >
                    <h4 style="margin-bottom: 15px">å·²ä¸Šå‚³çš„æª”æ¡ˆ</h4>
                    <div id="uploadedFilesList"></div>

                    </div>
                </div>

                <!-- Book Selection Modal -->
                <div id="uploadBookSelectionModal" class="modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>ç¢ºèªæ›¸ç±è³‡è¨Š</h3>
                            <button
                                class="modal-close"
                                onclick="closeUploadBookSelectionModal()"
                            >
                                Ã—
                            </button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px;">
                                <div id="uploadFileCountInfo" style="font-weight: bold; color: #007bff; margin-bottom: 10px;"></div>
                                <p style="color: #666; font-size: 14px;">
                                    æ›¸ç±è³‡è¨Šå·²å¾ç¬¬ä¸€å€‹æª”æ¡ˆä¸­æå–ï¼Œè«‹ç¢ºèªæˆ–ä¿®æ”¹ï¼š
                                </p>
                            </div>
                            
                            <div class="book-selector" style="margin-bottom: 20px;">
                                <label>é¸æ“‡æ›¸ç±ï¼š</label>
                                <select
                                    id="uploadBookSelector"
                                    onchange="toggleUploadBookMetadataForm()"
                                >
                                    <option value="new">å»ºç«‹æ–°æ›¸ç±</option>
                                </select>
                            </div>

                            <!-- New Book Metadata Form (shown when "å»ºç«‹æ–°æ›¸ç±" is selected) -->
                            <div id="uploadNewBookForm" style="display: none; margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-radius: 4px;">
                                <h4 style="margin-bottom: 15px;">æ–°æ›¸ç±è³‡è¨Š</h4>
                                
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ›¸ç±åç¨±ï¼š</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookName"
                                        placeholder="æ›¸ç±åç¨± (ç°¡é«”ä¸­æ–‡)"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä½œè€…ï¼š</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookAuthor"
                                        placeholder="ä½œè€…"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">åˆ†é¡ï¼š</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookCategory"
                                        placeholder="åˆ†é¡"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">æè¿°ï¼š</label>
                                    <textarea
                                        id="uploadNewBookDescription"
                                        placeholder="æè¿°"
                                        rows="3"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"
                                    ></textarea>
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä¾†æºç¶²å€ï¼š</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookSourceUrl"
                                        placeholder="ä¾†æºç¶²å€"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <label>ç« ç¯€é è¦½ï¼ˆå‰10å€‹ï¼‰ï¼š</label>
                                <pre id="uploadChapterPreview" style="background: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto; font-size: 13px; white-space: pre-wrap;"></pre>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button
                                class="btn btn-secondary"
                                onclick="closeUploadBookSelectionModal()"
                            >
                                å–æ¶ˆ
                            </button>
                            <button
                                class="btn btn-success"
                                onclick="processUploadedFiles()"
                            >
                                ç¢ºèªä¸¦è™•ç†æ‰€æœ‰æª”æ¡ˆ
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Books Tab -->
            <div id="booksTab" class="tab-content">
                <div class="results-header">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 10px 0;">æˆ‘çš„æ›¸ç±</h3>
                        <div id="bookSearchInfo" style="font-size: 14px; color: #666; display: none;">
                            <span id="bookSearchCount"></span>
                        </div>
                    </div>
                    <div>
                        <div class="book-search-container" style="position: relative; margin-right: 10px; display: inline-block;">
                            <div style="position: relative; display: flex; align-items: center;">
                                <input
                                    type="text"
                                    id="bookSearchInput"
                                    placeholder="æœå°‹æ›¸ç±åç¨±æˆ–ä½œè€…..."
                                    class="book-search-input"
                                    style="padding: 8px 35px 8px 12px; border: 1px solid #ddd; border-radius: 4px; width: 300px; font-size: 14px;"
                                    oninput="handleBookSearchInput(event)"
                                    onfocus="showBookAutocomplete()"
                                    onblur="hideBookAutocomplete()"
                                    onkeydown="handleBookSearchKeydown(event)"
                                />
                                <button
                                    id="clearBookSearchBtn"
                                    onclick="clearAllFilters()"
                                    style="position: absolute; right: 8px; background: none; border: none; cursor: pointer; padding: 4px; display: none; color: #999; font-size: 18px; line-height: 1;"
                                    title="æ¸…é™¤æ‰€æœ‰ç¯©é¸"
                                >
                                    Ã—
                                </button>
                            </div>
                            <div id="bookAutocomplete" class="book-autocomplete" style="display: none;"></div>
                        </div>
                        <button
                            class="btn btn-secondary"
                            onclick="refreshBooks()"
                        >
                            é‡æ–°æ•´ç†
                        </button>
                        <button
                            class="btn btn-success"
                            id="exportToJoplinBtn"
                            onclick="exportSelectedToJoplin()"
                            disabled
                        >
                            åŒ¯å‡ºé¸ä¸­æ›¸ç±åˆ° Joplin
                        </button>
                    </div>
                </div>
                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin-bottom: 15px;">
                    <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label style="font-size: 14px; white-space: nowrap;">ä½œè€…ï¼š</label>
                            <input
                                type="text"
                                id="filterAuthor"
                                placeholder="ç¯©é¸ä½œè€…..."
                                style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; width: 150px; font-size: 14px;"
                                oninput="handleAuthorFilterInput(event)"
                            />
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label style="font-size: 14px; white-space: nowrap;">è©•åˆ†ï¼š</label>
                            <input
                                type="number"
                                id="filterMinRating"
                                min="0"
                                max="5"
                                value="0"
                                style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; width: 60px; font-size: 14px;"
                                onchange="handleRatingFilterChange()"
                            />
                            <span style="font-size: 14px;">~</span>
                            <input
                                type="number"
                                id="filterMaxRating"
                                min="0"
                                max="5"
                                value="5"
                                style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; width: 60px; font-size: 14px;"
                                onchange="handleRatingFilterChange()"
                            />
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label style="font-size: 14px; white-space: nowrap;">ç« ç¯€æ•¸ï¼š</label>
                            <input
                                type="number"
                                id="filterMinChapters"
                                min="0"
                                value="0"
                                style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; width: 80px; font-size: 14px;"
                                onchange="handleChapterFilterChange()"
                            />
                            <span style="font-size: 14px;">~</span>
                            <input
                                type="number"
                                id="filterMaxChapters"
                                min="0"
                                placeholder="ç„¡ä¸Šé™"
                                style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; width: 80px; font-size: 14px;"
                                onchange="handleChapterFilterChange()"
                            />
                        </div>
                        <button
                            class="btn btn-secondary"
                            onclick="clearAllFilters()"
                            style="font-size: 14px; padding: 6px 12px;"
                        >
                            æ¸…é™¤ç¯©é¸
                        </button>
                    </div>
                </div>
                <div id="booksGrid" class="books-grid"></div>
                <div id="bulkActions" class="bulk-actions">
                    <div class="bulk-actions-info" id="bulkActionsInfo">
                        å·²é¸æ“‡ 0 æœ¬æ›¸ç±
                    </div>
                    <button
                        class="btn btn-success"
                        onclick="exportSelectedToJoplin()"
                    >
                        åŒ¯å‡ºé¸ä¸­æ›¸ç±åˆ° Joplin
                    </button>
                </div>
            </div>

            <!-- Chapters Tab -->
            <div id="chaptersTab" class="tab-content">
                <div class="results-header">
                    <h3 id="chaptersTabTitle">ç« ç¯€åˆ—è¡¨</h3>
                    <div>
                        <button
                            id="backToBooksBtn"
                            class="btn btn-secondary"
                            onclick="backToBooks()"
                            style="display: none; margin-right: 10px"
                        >
                            è¿”å›æ›¸ç±åˆ—è¡¨
                        </button>
                        <button
                            id="reformatChaptersBtn"
                            class="btn btn-success"
                            onclick="reformatAllChapters()"
                            style="display: none; margin-right: 10px"
                        >
                            é‡æ–°æ ¼å¼åŒ–æ‰€æœ‰ç« ç¯€
                        </button>
                        <button
                            class="btn btn-secondary"
                            onclick="refreshChapters()"
                        >
                            é‡æ–°æ•´ç†
                        </button>
                    </div>
                </div>
                <div id="chapterToolbar" style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin-bottom: 15px;">
                    <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 300px;">
                            <label style="font-size: 14px; white-space: nowrap;">å¾ URL æ–°å¢ç« ç¯€ï¼š</label>
                            <input
                                type="text"
                                id="chapterUrlInput"
                                placeholder="è¼¸å…¥ Cool18 ç« ç¯€ URL..."
                                style="flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                                onkeypress="if(event.key==='Enter') addChapterFromUrl()"
                            />
                            <button
                                class="btn btn-success"
                                onclick="addChapterFromUrl()"
                                style="white-space: nowrap;"
                            >
                                ä¸‹è¼‰ç« ç¯€
                            </button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label style="font-size: 14px; white-space: nowrap;">æˆ–ä¸Šå‚³æª”æ¡ˆï¼š</label>
                            <input
                                type="file"
                                id="chapterFileUpload"
                                accept=".md,.txt,.html,.htm"
                                style="display: none;"
                                onchange="handleChapterFileUpload(event)"
                            />
                            <button
                                class="btn btn-primary"
                                onclick="document.getElementById('chapterFileUpload').click()"
                                style="white-space: nowrap;"
                            >
                                é¸æ“‡æª”æ¡ˆ
                            </button>
                        </div>
                    </div>
                </div>
                <div id="chaptersList"></div>
            </div>

            <!-- Chunks Tab -->
            <div id="chunksTab" class="tab-content p-4">
                <div class="results-header">
                    <h3>åˆ†å¡Šé è¦½</h3>
                    <button class="btn btn-secondary" onclick="refreshChunks()">
                        é‡æ–°æ•´ç†
                    </button>
                </div>

                <div class="mb-4">
                    <label for="chunkSizeInput" class="form-label">æ¯å¡Šæœ€å¤§è¡Œæ•¸ï¼š</label>
                    <input
                        type="number"
                        id="chunkSizeInput"
                        class="form-control"
                        value="1000"
                        min="100"
                        max="10000"
                        style="max-width: 200px;"
                    />
                </div>

                <!-- Waiting Books Section -->
                <div class="mb-4">
                    <h4>ç­‰å¾…è™•ç†çš„æ›¸ç±</h4>
                    <div id="waitingBooksList" class="list-group"></div>
                </div>

                <!-- Ready Books Section -->
                <div class="mb-4">
                    <h4>å¯é è¦½çš„æ›¸ç±</h4>
                    <div id="readyBooksList" class="list-group"></div>
                </div>

                <!-- Available Books Section -->
                <div class="mb-4">
                    <h4>å¯ç”Ÿæˆåˆ†å¡Šçš„æ›¸ç±</h4>
                    <div id="availableBooksList" class="list-group"></div>
                </div>

                <!-- Chunk Preview Modal -->
                <div id="chunkPreviewModal" class="modal">
                    <div class="modal-content" style="max-width: 90%; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h4 id="chunkPreviewTitle">åˆ†å¡Šé è¦½</h4>
                            <button class="modal-close" onclick="closeChunkPreview()">Ã—</button>
                        </div>
                        <div class="modal-body">
                            <div id="chunkPreviewContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bot Status Tab -->
            <div id="botStatusTab" class="tab-content">
                <div class="results-header">
                    <h3>æ©Ÿå™¨äººç‹€æ…‹</h3>
                    <button
                        class="btn btn-secondary"
                        onclick="refreshBotStatus()"
                    >
                        é‡æ–°æ•´ç†
                    </button>
                </div>

                <div class="bot-status-summary" id="botStatusSummary">
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryTotal"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">
                            ç¸½æ“ä½œæ•¸
                        </div>
                    </div>
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryActive"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">é€²è¡Œä¸­</div>
                    </div>
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryCompleted"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">å·²å®Œæˆ</div>
                    </div>
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryFailed"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">å¤±æ•—</div>
                    </div>
                </div>

                <div id="operationsList"></div>
            </div>
        </div>

        <script>
            // Global state
            let searchQueue = [];
            let searchResults = [];
            let selectedThreads = new Set();
            let books = [];
            let allBooks = []; // Store all books for filtering
            let selectedBooks = new Set();
            let bookSearchQuery = ""; // Current search query
            let bookFilters = {
                search: "",
                minRating: 0,
                maxRating: 5,
                minChapters: 0,
                maxChapters: null,
                author: ""
            };
            let currentSearchId = null;
            let lastSearchParams = null; // Store last search keyword and pages for retry
            let lastSearchId = null; // Store last search ID for deletion
            let currentSearchKeyword = null; // Store current search keyword for URL display
            let missingChapterResults = {}; // Store missing chapter search results by queue item ID
            let backgroundWorkers = []; // Store background download/upload tasks
            let workerEventSources = new Map(); // Store SSE connections for workers

            // LocalStorage persistence helpers
            function saveSearchStateToLocalStorage() {
                try {
                    localStorage.setItem(
                        "alexLib_searchQueue",
                        JSON.stringify(searchQueue)
                    );
                    localStorage.setItem(
                        "alexLib_searchResults",
                        JSON.stringify(searchResults)
                    );
                    localStorage.setItem(
                        "alexLib_currentSearchKeyword",
                        currentSearchKeyword || ""
                    );
                    localStorage.setItem(
                        "alexLib_lastSearchParams",
                        JSON.stringify(lastSearchParams)
                    );
                    localStorage.setItem(
                        "alexLib_lastSearchId",
                        lastSearchId || ""
                    );
                } catch (error) {
                    console.error(
                        "Error saving search state to localStorage:",
                        error
                    );
                }
            }

            function loadSearchStateFromLocalStorage() {
                try {
                    const savedQueue = localStorage.getItem(
                        "alexLib_searchQueue"
                    );
                    if (savedQueue) {
                        searchQueue = JSON.parse(savedQueue);
                        // Filter out any items that were processing (they won't complete after restart)
                        searchQueue = searchQueue.filter(
                            (item) => item.status !== "processing"
                        );
                    }

                    const savedResults = localStorage.getItem(
                        "alexLib_searchResults"
                    );
                    if (savedResults) {
                        searchResults = JSON.parse(savedResults);
                    }

                    const savedKeyword = localStorage.getItem(
                        "alexLib_currentSearchKeyword"
                    );
                    if (savedKeyword) {
                        currentSearchKeyword = savedKeyword;
                    }

                    const savedParams = localStorage.getItem(
                        "alexLib_lastSearchParams"
                    );
                    if (savedParams) {
                        lastSearchParams = JSON.parse(savedParams);
                    }

                    const savedSearchId = localStorage.getItem(
                        "alexLib_lastSearchId"
                    );
                    if (savedSearchId) {
                        lastSearchId = savedSearchId;
                    }
                } catch (error) {
                    console.error(
                        "Error loading search state from localStorage:",
                        error
                    );
                }
            }

            // Tab switching
            function switchTab(tabName) {
                // Update tab buttons (Bootstrap nav-tabs)
                const tabMap = {
                    'search': 0,
                    'results': 1,
                    'books': 2,
                    'chapters': 3,
                    'chunks': 4,
                    'upload': 5,
                    'botStatus': 6
                };
                document.querySelectorAll(".nav-link").forEach((tab, index) => {
                    tab.classList.remove("active");
                    if (index === tabMap[tabName]) {
                        tab.classList.add("active");
                    }
                });

                // Update tab content
                document
                    .querySelectorAll(".tab-content")
                    .forEach((content) => content.classList.remove("active"));
                document
                    .getElementById(tabName + "Tab")
                    .classList.add("active");

                // Load data when switching tabs
                if (tabName === "books") {
                    loadBooks();
                } else if (tabName === "upload") {
                    loadBooksForUpload();
                    // Make sure modal is closed when switching to upload tab
                    const modal = document.getElementById("uploadBookSelectionModal");
                    if (modal) {
                        modal.classList.remove("active");
                    }
                } else if (tabName === "botStatus") {
                    loadBotStatus();
                } else if (tabName === "chunks") {
                    refreshChunks();
                } else if (tabName === "workers") {
                    refreshWorkers();
                    updateWorkersDisplay();
                }
            }

            // Normalize text: convert full-width English and numbers to half-width
            function normalizeToHalfWidth(text) {
                if (!text) return text;
                
                // Full-width to half-width mapping
                const fullToHalf = {
                    'ï¼¡': 'A', 'ï¼¢': 'B', 'ï¼£': 'C', 'ï¼¤': 'D', 'ï¼¥': 'E', 'ï¼¦': 'F',
                    'ï¼§': 'G', 'ï¼¨': 'H', 'ï¼©': 'I', 'ï¼ª': 'J', 'ï¼«': 'K', 'ï¼¬': 'L',
                    'ï¼­': 'M', 'ï¼®': 'N', 'ï¼¯': 'O', 'ï¼°': 'P', 'ï¼±': 'Q', 'ï¼²': 'R',
                    'ï¼³': 'S', 'ï¼´': 'T', 'ï¼µ': 'U', 'ï¼¶': 'V', 'ï¼·': 'W', 'ï¼¸': 'X',
                    'ï¼¹': 'Y', 'ï¼º': 'Z',
                    'ï½': 'a', 'ï½‚': 'b', 'ï½ƒ': 'c', 'ï½„': 'd', 'ï½…': 'e', 'ï½†': 'f',
                    'ï½‡': 'g', 'ï½ˆ': 'h', 'ï½‰': 'i', 'ï½Š': 'j', 'ï½‹': 'k', 'ï½Œ': 'l',
                    'ï½': 'm', 'ï½': 'n', 'ï½': 'o', 'ï½': 'p', 'ï½‘': 'q', 'ï½’': 'r',
                    'ï½“': 's', 'ï½”': 't', 'ï½•': 'u', 'ï½–': 'v', 'ï½—': 'w', 'ï½˜': 'x',
                    'ï½™': 'y', 'ï½š': 'z',
                    'ï¼': '0', 'ï¼‘': '1', 'ï¼’': '2', 'ï¼“': '3', 'ï¼”': '4',
                    'ï¼•': '5', 'ï¼–': '6', 'ï¼—': '7', 'ï¼˜': '8', 'ï¼™': '9',
                    'ã€€': ' ', // Full-width space to half-width space
                };
                
                let normalized = text;
                for (const [full, half] of Object.entries(fullToHalf)) {
                    normalized = normalized.replace(new RegExp(full, 'g'), half);
                }
                
                return normalized;
            }

            // Search Queue Management
            function addToQueue() {
                let keyword = document
                    .getElementById("searchInput")
                    .value.trim();
                if (!keyword) {
                    showStatus("è«‹è¼¸å…¥æœå°‹é—œéµå­—", "error");
                    return;
                }

                // Normalize keyword: convert full-width to half-width
                keyword = normalizeToHalfWidth(keyword);

                const searchId = Date.now();
                const queueItem = {
                    id: searchId,
                    type: "search", // Operation type
                    keyword: keyword,
                    pages: 3, // Default to 3 pages
                    status: "pending",
                    results: null,
                };

                searchQueue.push(queueItem);
                document.getElementById("searchInput").value = "";
                updateQueueDisplay();
                saveSearchStateToLocalStorage();

                // Start processing if not already processing
                if (!currentSearchId) {
                    processQueue();
                }
            }

            // Add missing chapter search to queue
            function addMissingChapterSearchToQueue(bookId, bookName) {
                const searchId = Date.now();
                const queueItem = {
                    id: searchId,
                    type: "missing-chapters", // Operation type
                    bookId: bookId,
                    bookName: bookName,
                    status: "pending",
                    results: null,
                };

                searchQueue.push(queueItem);
                updateQueueDisplay();
                saveSearchStateToLocalStorage();

                // Start processing if not already processing
                if (!currentSearchId) {
                    processQueue();
                }

                showStatus(`å·²åŠ å…¥æœå°‹ä½‡åˆ—ï¼š${bookName} çš„ç¼ºå¤±ç« ç¯€`, "success");
            }

            function updateQueueDisplay() {
                const queueList = document.getElementById("queueList");
                if (searchQueue.length === 0) {
                    queueList.innerHTML =
                        '<div class="text-center text-muted py-5">ä½‡åˆ—ç‚ºç©º</div>';
                    return;
                }

                let html = "";
                searchQueue.forEach((item) => {
                    const statusClass =
                        item.status === "processing"
                            ? "processing"
                            : item.status === "completed"
                            ? "completed"
                            : item.status === "error"
                            ? "error"
                            : "";
                    const statusText =
                        item.status === "processing"
                            ? item.type === "missing-chapters" ? "æœå°‹ä¸­..." : "æœå°‹ä¸­..."
                            : item.status === "completed"
                            ? item.type === "missing-chapters" 
                                ? `å®Œæˆ (${item.results?.searchData?.foundChapters?.length || 0} å€‹ç« ç¯€)`
                                : `å®Œæˆ (${item.results?.length || 0} çµæœ)`
                            : item.status === "error"
                            ? "éŒ¯èª¤"
                            : "ç­‰å¾…ä¸­";

                    // Display text based on type
                    let displayText = "";
                    if (item.type === "missing-chapters") {
                        displayText = `ğŸ” æœå°‹ç¼ºå¤±ç« ç¯€: ${item.bookName || `æ›¸ç± ID ${item.bookId}`}`;
                    } else {
                        displayText = item.keyword || "æœªçŸ¥";
                    }

                    html += `
                    <div class="queue-item ${statusClass} card mb-2">
                        <div class="card-body d-flex justify-content-between align-items-center">
                            <div>
                                <div class="fw-bold">${displayText}</div>
                                <div class="text-muted small">${statusText}</div>
                            </div>
                            <div class="d-flex gap-2">
                                ${
                                    item.status === "completed"
                                        ? `<button class="btn btn-sm btn-primary" onclick="viewQueueResults(${item.id})">æŸ¥çœ‹çµæœ</button>`
                                        : ""
                                }
                                ${
                                    item.status !== "processing"
                                        ? `<button class="btn btn-sm btn-secondary" onclick="retrySearch(${item.id})">é‡æ–°æœå°‹</button>`
                                        : ""
                                }
                                ${
                                    item.status !== "processing"
                                        ? `<button class="btn btn-sm btn-danger" onclick="removeSearch(${item.id})">ç§»é™¤</button>`
                                        : ""
                                }
                            </div>
                        </div>
                    </div>
                `;
                });
                queueList.innerHTML = html;
            }

            async function processQueue() {
                const pendingItem = searchQueue.find(
                    (item) => item.status === "pending"
                );
                if (!pendingItem) {
                    currentSearchId = null;
                    updateQueueDisplay(); // Update display when queue is empty
                    return;
                }

                currentSearchId = pendingItem.id;
                pendingItem.status = "processing";
                updateQueueDisplay();

                try {
                    if (pendingItem.type === "missing-chapters") {
                        // Process missing chapter search
                        await processMissingChapterSearch(pendingItem);
                    } else {
                        // Process regular search
                        await processRegularSearch(pendingItem);
                    }
                } catch (error) {
                    console.error("Error processing queue item:", error);
                    pendingItem.status = "error";
                    pendingItem.error = error.message;
                    showStatus("è™•ç†æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                } finally {
                    updateQueueDisplay();
                    // Process next item
                    setTimeout(() => {
                        processQueue();
                    }, 500);
                }
            }

            async function processRegularSearch(pendingItem) {
                try {
                    const pages = pendingItem.pages || 3;
                    const response = await fetch(
                        `/api/search?keyword=${encodeURIComponent(
                            pendingItem.keyword
                        )}&pages=${pages}`
                    );
                    const data = await response.json();

                    if (!response.ok || data.error) {
                        pendingItem.status = "error";
                        const errorMessage =
                            data.message ||
                            data.error ||
                            `HTTP ${response.status}`;
                        console.error("æœå°‹ API å›æ‡‰éŒ¯èª¤", {
                            keyword: pendingItem.keyword,
                            status: response.status,
                            error: data.error,
                            message: data.message,
                        });
                        showStatus("æœå°‹å¤±æ•—: " + errorMessage, "error");
                    } else {
                        pendingItem.status = "completed";
                        pendingItem.results = data.threads || [];
                        pendingItem.dbSearchId = data.searchResultId || null; // Store database ID
                        // Store last search params for retry
                        currentSearchKeyword = pendingItem.keyword;
                        lastSearchParams = {
                            keyword: pendingItem.keyword,
                            pages: pages,
                        };
                        lastSearchId = pendingItem.id;
                        // Show retry and delete buttons (if they exist)
                        const retryBtn =
                            document.getElementById("retrySearchBtn");
                        const deleteBtn =
                            document.getElementById("deleteSearchBtn");
                        if (retryBtn) retryBtn.style.display = "inline-block";
                        if (deleteBtn) deleteBtn.style.display = "inline-block";
                        showStatus(
                            `æœå°‹å®Œæˆ: æ‰¾åˆ° ${pendingItem.results.length} å€‹çµæœ`,
                            "success"
                        );
                        // Save to localStorage
                        saveSearchStateToLocalStorage();
                    }
                } catch (error) {
                    pendingItem.status = "error";
                    console.error("æœå°‹è«‹æ±‚å¤±æ•—", {
                        keyword: pendingItem.keyword,
                        error,
                        stack: error.stack,
                    });
                    const errorMessage = error.message || "æœªçŸ¥éŒ¯èª¤";
                    console.error("æœå°‹éŒ¯èª¤è©³æƒ…:", errorMessage);
                    showStatus("æœå°‹æ™‚ç™¼ç”ŸéŒ¯èª¤: " + errorMessage, "error");
                } finally {
                    updateQueueDisplay();
                    // Process next item
                    setTimeout(() => {
                        processQueue();
                    }, 500);
                }
            }

            function viewQueueResults(searchId) {
                const queueItem = searchQueue.find(
                    (item) => item.id === searchId
                );
                if (!queueItem || !queueItem.results) return;

                if (queueItem.type === "missing-chapters") {
                    // Show missing chapters modal
                    showMissingChaptersModal(
                        queueItem.results.bookId,
                        queueItem.results.missingData,
                        queueItem.results.searchData
                    );
                } else {
                    // Show regular search results
                    searchResults = queueItem.results;
                    currentSearchKeyword = queueItem.keyword;
                    lastSearchId = searchId;
                    lastSearchParams = {
                        keyword: queueItem.keyword,
                        pages: queueItem.pages || 3,
                    };
                    // Show retry and delete buttons (if they exist)
                    const retryBtn = document.getElementById("retrySearchBtn");
                    const deleteBtn = document.getElementById("deleteSearchBtn");
                    if (retryBtn) retryBtn.style.display = "inline-block";
                    if (deleteBtn) deleteBtn.style.display = "inline-block";
                    displayResults(searchResults);
                    updateSearchUrlDisplay();
                    switchTab("results");
                    // Save to localStorage
                    saveSearchStateToLocalStorage();
                }
            }

            function viewResults(searchId) {
                // Legacy function for backward compatibility
                viewQueueResults(searchId);
            }

            function clearResults() {
                searchResults = [];
                selectedThreads.clear();
                displayResults([]);
                const selectionSection =
                    document.getElementById("selectionSection");
                if (selectionSection) {
                    selectionSection.classList.remove("active");
                }
                lastSearchParams = null;
                lastSearchId = null;
                const retryBtn = document.getElementById("retrySearchBtn");
                const deleteBtn = document.getElementById("deleteSearchBtn");
                if (retryBtn) retryBtn.style.display = "none";
                if (deleteBtn) deleteBtn.style.display = "none";
                // Save to localStorage
                saveSearchStateToLocalStorage();
            }

            async function deleteLastSearch() {
                if (!lastSearchId) {
                    showStatus("æ²’æœ‰å¯åˆªé™¤çš„æœå°‹", "error");
                    return;
                }

                // Remove from queue
                const queueItem = searchQueue.find(
                    (item) => item.id === lastSearchId
                );
                if (queueItem && queueItem.status === "processing") {
                    showStatus("ç„¡æ³•åˆªé™¤æ­£åœ¨è™•ç†ä¸­çš„æœå°‹", "error");
                    return;
                }

                // Delete from database if it has a dbSearchId
                if (queueItem && queueItem.dbSearchId) {
                    try {
                        const response = await fetch(
                            `/api/search/${queueItem.dbSearchId}`,
                            {
                                method: "DELETE",
                            }
                        );
                        if (!response.ok) {
                            console.error(
                                "Failed to delete search from database"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "Error deleting search from database:",
                            error
                        );
                    }
                }

                searchQueue = searchQueue.filter(
                    (item) => item.id !== lastSearchId
                );

                // If it was the current search, clear it
                if (currentSearchId === lastSearchId) {
                    currentSearchId = null;
                }

                // Clear results if viewing this search
                if (searchResults.length > 0) {
                    clearResults();
                }

                updateQueueDisplay();
                showStatus("å·²åˆªé™¤æœå°‹", "success");
                // Save to localStorage
                saveSearchStateToLocalStorage();
            }

            function retryLastSearch() {
                if (!lastSearchParams) {
                    showStatus("æ²’æœ‰å¯é‡è©¦çš„æœå°‹", "error");
                    return;
                }

                // Add to queue with same params
                const searchId = Date.now();
                const queueItem = {
                    id: searchId,
                    keyword: lastSearchParams.keyword,
                    pages: lastSearchParams.pages,
                    status: "pending",
                    results: null,
                };

                searchQueue.push(queueItem);
                updateQueueDisplay();
                saveSearchStateToLocalStorage();

                // Start processing if not already processing
                if (!currentSearchId) {
                    processQueue();
                }

                showStatus("å·²åŠ å…¥æœå°‹ä½‡åˆ—", "success");
            }

            function retrySearch(searchId) {
                const queueItem = searchQueue.find(
                    (item) => item.id === searchId
                );
                if (!queueItem) return;

                const newItem = {
                    id: Date.now(),
                    type: queueItem.type || "search",
                    status: "pending",
                    results: null,
                };

                // Copy type-specific fields
                if (queueItem.type === "missing-chapters") {
                    newItem.bookId = queueItem.bookId;
                    newItem.bookName = queueItem.bookName;
                } else {
                    newItem.keyword = queueItem.keyword;
                    newItem.pages = queueItem.pages || 3;
                }

                searchQueue.push(newItem);
                updateQueueDisplay();
                saveSearchStateToLocalStorage();

                // Start processing if not already processing
                if (!currentSearchId) {
                    processQueue();
                }

                showStatus("å·²é‡æ–°åŠ å…¥æœå°‹", "success");
            }

            async function removeSearch(searchId) {
                // Don't remove if currently processing
                const queueItem = searchQueue.find(
                    (item) => item.id === searchId
                );
                if (queueItem && queueItem.status === "processing") {
                    showStatus("ç„¡æ³•ç§»é™¤æ­£åœ¨è™•ç†ä¸­çš„æœå°‹", "error");
                    return;
                }

                // Delete from database if it has a dbSearchId
                if (queueItem && queueItem.dbSearchId) {
                    try {
                        const response = await fetch(
                            `/api/search/${queueItem.dbSearchId}`,
                            {
                                method: "DELETE",
                            }
                        );
                        if (!response.ok) {
                            console.error(
                                "Failed to delete search from database"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "Error deleting search from database:",
                            error
                        );
                    }
                }

                // Remove from queue
                searchQueue = searchQueue.filter(
                    (item) => item.id !== searchId
                );

                // If it was the current search, clear it
                if (currentSearchId === searchId) {
                    currentSearchId = null;
                }

                updateQueueDisplay();
                showStatus("å·²ç§»é™¤æœå°‹", "success");
            }

            // Update search URL display
            function updateSearchUrlDisplay() {
                const searchUrlDisplay =
                    document.getElementById("searchUrlDisplay");
                const searchUrlLink = document.getElementById("searchUrlLink");
                const searchUrlText = document.getElementById("searchUrlText");

                if (!searchUrlDisplay || !searchUrlLink || !searchUrlText) {
                    return; // Elements don't exist, skip
                }

                if (currentSearchKeyword) {
                    const baseUrl = "https://www.cool18.com/bbs4";
                    const searchUrl = `${baseUrl}/index.php?app=forum&act=search&keyword=${encodeURIComponent(
                        currentSearchKeyword
                    )}&page=1`;
                    searchUrlLink.href = searchUrl;
                    searchUrlText.textContent = searchUrl;
                    searchUrlDisplay.classList.remove("d-none");
                } else {
                    searchUrlDisplay.classList.add("d-none");
                }
            }

            // Copy search URL to clipboard
            function copySearchUrl() {
                const searchUrlLink = document.getElementById("searchUrlLink");
                if (!searchUrlLink) {
                    showStatus("ç„¡æ³•è¤‡è£½ç¶²å€ï¼šæ‰¾ä¸åˆ°é€£çµå…ƒç´ ", "error");
                    return;
                }
                const url = searchUrlLink.href;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard
                        .writeText(url)
                        .then(() => {
                            showStatus("ç¶²å€å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿", "success");
                        })
                        .catch((err) => {
                            console.error("Failed to copy URL:", err);
                            showStatus("è¤‡è£½å¤±æ•—", "error");
                        });
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement("textarea");
                    textArea.value = url;
                    textArea.style.position = "fixed";
                    textArea.style.opacity = "0";
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand("copy");
                        showStatus("ç¶²å€å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿", "success");
                    } catch (err) {
                        showStatus("è¤‡è£½å¤±æ•—", "error");
                    }
                    document.body.removeChild(textArea);
                }
            }

            // Results Display
            function displayResults(threads) {
                const resultsList = document.getElementById("resultsList");

                if (threads.length === 0) {
                    resultsList.innerHTML =
                        '<div class="empty-state">æ²’æœ‰çµæœ</div>';
                    updateSearchUrlDisplay();
                    return;
                }

                let html = "";
                threads.forEach((thread, index) => {
                    const isSelected = selectedThreads.has(index);
                    html += `
                    <div class="thread-item">
                        <input type="checkbox" class="thread-checkbox" data-index="${index}" ${
                        isSelected ? "checked" : ""
                    } onchange="toggleThread(${index})">
                        <div class="thread-content" style="flex: 1;">
                            <div class="thread-title">
                                ${thread.titleTraditional || thread.title}
                                ${
                                    thread.chapterNumber
                                        ? `<span class="chapter-badge">ç¬¬${
                                              thread.chapterNumber
                                          }${
                                              thread.chapterFormat || "ç« "
                                          }</span>`
                                        : ""
                                }
                                ${
                                    thread.bookNameTraditional
                                        ? `<span class="book-badge">${thread.bookNameTraditional}</span>`
                                        : ""
                                }
                            </div>
                            <div class="thread-meta">
                                ${
                                    thread.url
                                        ? `<span><a href="${thread.url}" target="_blank" rel="noopener noreferrer" style="color: #007bff; text-decoration: none;">ğŸ”— æŸ¥çœ‹åŸæ–‡</a></span>`
                                        : ""
                                }
                                ${
                                    thread.date
                                        ? `<span>æ—¥æœŸ: ${thread.date}</span>`
                                        : ""
                                }
                                ${
                                    thread.replies !== undefined
                                        ? `<span>å›è¦†: ${thread.replies}</span>`
                                        : ""
                                }
                                ${
                                    thread.existingBookId
                                        ? `<span style="color: #28a745;">âœ“ å·²å­˜åœ¨æ–¼è³‡æ–™åº«</span>`
                                        : ""
                                }
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button class="btn btn-sm btn-success" onclick="downloadSingleChapter(${index})">ä¸‹è¼‰ç« ç¯€</button>
                        </div>
                    </div>
                `;
                });

                resultsList.innerHTML = html;
                updateSearchUrlDisplay();
            }

            function toggleThread(index) {
                const checkbox = document.querySelector(
                    `.thread-checkbox[data-index="${index}"]`
                );
                if (checkbox.checked) {
                    selectedThreads.add(index);
                } else {
                    selectedThreads.delete(index);
                }
                updateSelectionUI();
            }

            function updateSelectionUI() {
                const count = selectedThreads.size;
                document.getElementById(
                    "selectedCount"
                ).textContent = `å·²é¸æ“‡ ${count} å€‹ç« ç¯€`;
                document.getElementById("downloadBtn").disabled = count === 0;

                const selectionSection =
                    document.getElementById("selectionSection");
                if (count > 0) {
                    selectionSection.classList.add("active");
                } else {
                    selectionSection.classList.remove("active");
                }
            }

            function toggleBookNameInput() {
                const selector = document.getElementById("bookSelector");
                const newBookInput = document.getElementById("newBookName");
                newBookInput.style.display =
                    selector.value === "new" ? "block" : "none";
            }

            let pendingDownloadData = null; // Store download data while showing metadata modal

            async function downloadSingleChapter(index) {
                const thread = searchResults[index];
                if (!thread || !thread.url) {
                    showStatus("ç„¡æ³•å–å¾—ç« ç¯€è³‡è¨Š", "error");
                    return;
                }

                showStatus("æ­£åœ¨æå–æ›¸ç±è³‡è¨Š...", "");

                try {
                    // Extract metadata from chapter URL
                    const response = await fetch(
                        "/api/books/extract-metadata",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ url: thread.url }),
                        }
                    );

                    const data = await response.json();

                    if (!response.ok || data.error) {
                        const errorMsg =
                            data.message ||
                            data.error ||
                            `HTTP ${response.status}`;
                        console.error("Metadata extraction failed:", {
                            status: response.status,
                            error: data.error,
                            message: data.message,
                            url: thread.url,
                        });
                        showStatus("æå–è³‡è¨Šå¤±æ•—: " + errorMsg, "error");
                        return;
                    }

                    // Prepare chapter data
                    const chapter = {
                        url: thread.url,
                        title: thread.title || thread.titleTraditional || "",
                        chapterNum: thread.chapterNumber || null,
                    };

                    // Show metadata modal for confirmation/editing
                    showBookMetadataModalForSingleChapter(data, chapter);
                } catch (error) {
                    console.error("Metadata extraction error:", error);
                    showStatus(
                        "æå–è³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤: " + (error.message || "æœªçŸ¥éŒ¯èª¤"),
                        "error"
                    );
                }
            }

            function showBookMetadataModalForSingleChapter(metadata, chapter) {
                // Populate form with extracted metadata
                document.getElementById("metadataBookName").value =
                    metadata.bookName || "";
                document.getElementById("metadataBookNameTraditional").value =
                    metadata.bookNameTraditional || "";
                document.getElementById("metadataAuthor").value =
                    metadata.author || "";
                document.getElementById("metadataCategory").value =
                    metadata.category || "";
                document.getElementById("metadataTags").value = (
                    metadata.tags || []
                ).join(", ");
                document.getElementById("metadataDescription").value =
                    metadata.description || "";
                document.getElementById("metadataSourceUrl").value =
                    metadata.sourceUrl || chapter.url || "";

                // Store download data for single chapter
                pendingDownloadData = {
                    chapters: [chapter],
                    bookId: null,
                    bookName: metadata.bookName || "",
                    isSingleChapter: true,
                };

                // Update modal title and button
                const modalTitle = document.querySelector(
                    "#bookMetadataModal .progress-header h3"
                );
                const confirmButton = document.querySelector(
                    '#bookMetadataModal button[onclick="confirmBookMetadata()"]'
                );
                modalTitle.textContent = "ç¢ºèªæ›¸ç±è³‡è¨Šä¸¦ä¸‹è¼‰ç« ç¯€";
                confirmButton.textContent = "ç¢ºèªä¸¦é–‹å§‹ä¸‹è¼‰";

                // Show modal
                const modal = document.getElementById("bookMetadataModal");
                const modalContent = document.getElementById("bookMetadataModalContent");
                modal.classList.add("active");
                
                // Initialize or reset modal position
                modalContent.style.position = "fixed";
                modalContent.style.top = "50%";
                modalContent.style.left = "50%";
                modalContent.style.transform = "translate(-50%, -50%)";
                modalContent.style.margin = "0";
            }

            async function startDownload() {
                const selected = Array.from(selectedThreads).map(
                    (i) => searchResults[i]
                );
                const bookSelector = document.getElementById("bookSelector");
                const newBookName = document
                    .getElementById("newBookName")
                    .value.trim();

                let bookId =
                    bookSelector.value === "new" ||
                    bookSelector.value === "from-url"
                        ? null
                        : parseInt(bookSelector.value);
                let bookName = null;

                if (bookSelector.value === "new") {
                    if (!newBookName) {
                        showStatus("è«‹è¼¸å…¥æ–°æ›¸ç±åç¨±", "error");
                        return;
                    }
                    bookName = newBookName;
                } else if (bookSelector.value === "from-url") {
                    // Book name will be extracted from metadata
                    bookName = null;
                } else {
                    const selectedBook = allBooks.find((b) => b.id === bookId);
                    bookName = selectedBook
                        ? selectedBook.book_name_simplified
                        : null;
                }

                const chapters = selected.map((thread) => ({
                    url: thread.url,
                    title: thread.title,
                    chapterNum: thread.chapterNumber,
                }));

                // If creating a new book or from URL, extract metadata from first chapter URL
                if (
                    (bookSelector.value === "new" ||
                        bookSelector.value === "from-url") &&
                    chapters.length > 0
                ) {
                    showStatus("æ­£åœ¨æå–æ›¸ç±è³‡è¨Š...", "");
                    try {
                        const response = await fetch(
                            "/api/books/extract-metadata",
                            {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ url: chapters[0].url }),
                            }
                        );

                        const metadata = await response.json();
                        if (metadata.error) {
                            showStatus(
                                "æå–è³‡è¨Šå¤±æ•—ï¼Œå°‡ä½¿ç”¨é è¨­å€¼: " +
                                    metadata.message,
                                "warning"
                            );
                            // Create dummy metadata from first chapter URL
                            const urlTidMatch =
                                chapters[0].url?.match(/tid=(\d+)/);
                            const threadId = urlTidMatch
                                ? urlTidMatch[1]
                                : "unknown";
                            const dummyMetadata = {
                                bookName: `æ›¸ç±_${threadId}`,
                                author: "",
                                category: "",
                                description: "",
                                tags: [],
                                sourceUrl:
                                    bookSelector.value === "from-url"
                                        ? document.getElementById(
                                              "searchUrlLink"
                                          )?.href || chapters[0].url
                                        : chapters[0].url,
                                threadId: threadId,
                                originalTitle: `æ›¸ç±_${threadId}`,
                                bookNameTraditional: `æ›¸ç±_${threadId}`,
                            };

                            // Use dummy book name if from-url option
                            if (bookSelector.value === "from-url") {
                                bookName = dummyMetadata.bookName;
                            } else if (!bookName) {
                                bookName = dummyMetadata.bookName;
                            }

                            // Continue with download using dummy metadata
                            proceedWithDownload(
                                chapters,
                                bookId,
                                bookName,
                                dummyMetadata
                            );
                        } else {
                            // If "from-url" option, override sourceUrl with search URL
                            if (bookSelector.value === "from-url") {
                                const searchUrlLink =
                                    document.getElementById("searchUrlLink");
                                if (
                                    searchUrlLink &&
                                    searchUrlLink.href &&
                                    searchUrlLink.href !== "#"
                                ) {
                                    metadata.sourceUrl = searchUrlLink.href;
                                }
                            }

                            // Use extracted book name if from-url option
                            if (bookSelector.value === "from-url") {
                                bookName = metadata.bookName || null;
                            }

                            // Show metadata modal for confirmation
                            showBookMetadataModal(
                                metadata,
                                chapters,
                                bookId,
                                bookName
                            );
                        }
                    } catch (error) {
                        console.error("Metadata extraction error:", error);
                        showStatus(
                            "æå–è³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œå°‡ä½¿ç”¨é è¨­å€¼",
                            "warning"
                        );
                        // Create dummy metadata from first chapter URL
                        const urlTidMatch =
                            chapters[0]?.url?.match(/tid=(\d+)/);
                        const threadId = urlTidMatch
                            ? urlTidMatch[1]
                            : "unknown";
                        const dummyMetadata = {
                            bookName: `æ›¸ç±_${threadId}`,
                            author: "",
                            category: "",
                            description: "",
                            tags: [],
                            sourceUrl:
                                bookSelector.value === "from-url"
                                    ? document.getElementById("searchUrlLink")
                                          ?.href ||
                                      chapters[0]?.url ||
                                      ""
                                    : chapters[0]?.url || "",
                            threadId: threadId,
                            originalTitle: `æ›¸ç±_${threadId}`,
                            bookNameTraditional: `æ›¸ç±_${threadId}`,
                        };

                        // Use dummy book name if from-url option
                        if (bookSelector.value === "from-url") {
                            bookName = dummyMetadata.bookName;
                        } else if (!bookName) {
                            bookName = dummyMetadata.bookName;
                        }

                        // Continue with download using dummy metadata
                        proceedWithDownload(
                            chapters,
                            bookId,
                            bookName,
                            dummyMetadata
                        );
                    }
                } else {
                    // Existing book, proceed directly in background (non-blocking)
                    proceedWithDownloadInBackground(
                        chapters,
                        bookId,
                        bookName,
                        null
                    );
                }
            }

            function showBookMetadataModal(
                metadata,
                chapters,
                bookId,
                bookName
            ) {
                // Populate form with extracted metadata
                document.getElementById("metadataBookName").value =
                    metadata.bookName || bookName || "";
                document.getElementById("metadataBookNameTraditional").value =
                    metadata.bookNameTraditional || "";
                document.getElementById("metadataAuthor").value =
                    metadata.author || "";
                document.getElementById("metadataCategory").value =
                    metadata.category || "";
                document.getElementById("metadataTags").value = (
                    metadata.tags || []
                ).join(", ");
                document.getElementById("metadataDescription").value =
                    metadata.description || "";
                document.getElementById("metadataSourceUrl").value =
                    metadata.sourceUrl || "";

                // Store download data
                pendingDownloadData = { chapters, bookId, bookName };

                // Update modal title and button
                const modalTitle = document.querySelector(
                    "#bookMetadataModal .progress-header h3"
                );
                const confirmButton = document.querySelector(
                    '#bookMetadataModal button[onclick="confirmBookMetadata()"]'
                );
                modalTitle.textContent = "ç¢ºèªæ›¸ç±è³‡è¨Š";
                confirmButton.textContent = "ç¢ºèªä¸¦é–‹å§‹ä¸‹è¼‰";

                // Show modal
                const modal = document.getElementById("bookMetadataModal");
                const modalContent = document.getElementById("bookMetadataModalContent");
                modal.classList.add("active");
                
                // Initialize or reset modal position
                modalContent.style.position = "fixed";
                modalContent.style.top = "50%";
                modalContent.style.left = "50%";
                modalContent.style.transform = "translate(-50%, -50%)";
                modalContent.style.margin = "0";
            }

            function closeBookMetadataModal() {
                const modalContent = document.getElementById("bookMetadataModalContent");
                if (modalContent) {
                    // Reset modal position when closing
                    modalContent.style.transform = "translate(-50%, -50%)";
                }
                document
                    .getElementById("bookMetadataModal")
                    .classList.remove("active");
                pendingDownloadData = null;
            }

            async function confirmBookMetadata() {
                if (!pendingDownloadData) {
                    showStatus("ä¸‹è¼‰è³‡æ–™éºå¤±ï¼Œè«‹é‡æ–°é¸æ“‡ç« ç¯€", "error");
                    return;
                }

                // Get form values
                const bookMetadata = {
                    bookName: document
                        .getElementById("metadataBookName")
                        .value.trim(),
                    bookNameTraditional: document
                        .getElementById("metadataBookNameTraditional")
                        .value.trim(),
                    author: document
                        .getElementById("metadataAuthor")
                        .value.trim(),
                    category: document
                        .getElementById("metadataCategory")
                        .value.trim(),
                    tags: document
                        .getElementById("metadataTags")
                        .value.split(",")
                        .map((t) => t.trim())
                        .filter((t) => t),
                    description: document
                        .getElementById("metadataDescription")
                        .value.trim(),
                    sourceUrl: document
                        .getElementById("metadataSourceUrl")
                        .value.trim(),
                };

                if (!bookMetadata.bookName) {
                    showStatus("è«‹è¼¸å…¥æ›¸å", "error");
                    return;
                }

                // Store data before closing modal (which sets pendingDownloadData to null)
                const isEdit = pendingDownloadData.isEdit || false;
                const downloadChapters = pendingDownloadData.chapters;
                const downloadBookId = pendingDownloadData.bookId;
                const downloadBookName = pendingDownloadData.bookName;

                closeBookMetadataModal();

                // If editing existing book
                if (isEdit) {
                    try {
                        showStatus("æ­£åœ¨æ›´æ–°æ›¸ç±è³‡è¨Š...", "");
                        const response = await fetch(
                            `/api/books/${downloadBookId}`,
                            {
                                method: "PUT",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({
                                    book_name_simplified: bookMetadata.bookName,
                                    book_name_traditional:
                                        bookMetadata.bookNameTraditional,
                                    author: bookMetadata.author,
                                    category: bookMetadata.category,
                                    description: bookMetadata.description,
                                    source_url: bookMetadata.sourceUrl,
                                    tags: bookMetadata.tags,
                                }),
                            }
                        );

                        const data = await response.json();
                        if (data.error) {
                            showStatus("æ›´æ–°å¤±æ•—: " + data.error, "error");
                        } else {
                            showStatus("æ›¸ç±è³‡è¨Šå·²æ›´æ–°", "success");
                            await loadBooks();
                        }
                    } catch (error) {
                        console.error("Update error:", error);
                        showStatus("æ›´æ–°æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                    }
                } else {
                    // Creating new book and downloading
                    proceedWithDownload(
                        downloadChapters,
                        downloadBookId,
                        bookMetadata.bookName,
                        bookMetadata
                    );
                }
            }

            async function proceedWithDownload(
                chapters,
                bookId,
                bookName,
                bookMetadata
            ) {
                // Always add to background workers (async)
                addDownloadToWorkers(chapters, bookId, bookName, bookMetadata);
                
                selectedThreads.clear();
                updateSelectionUI();
                // Re-display results to update checkbox states, but keep results visible
                if (searchResults.length > 0) {
                    displayResults(searchResults);
                }
            }

            // Non-blocking version for existing books - runs in background
            function proceedWithDownloadInBackground(
                chapters,
                bookId,
                bookName,
                bookMetadata
            ) {
                // Show immediate feedback
                showStatus("æ­£åœ¨å•Ÿå‹•ä¸‹è¼‰ä»»å‹™...", "success");
                selectedThreads.clear();
                updateSelectionUI();
                // Re-display results to update checkbox states, but keep results visible
                if (searchResults.length > 0) {
                    displayResults(searchResults);
                }

                // Start download in background without blocking
                fetch("/api/download/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        chapters,
                        bookId,
                        bookName,
                        bookMetadata,
                    }),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.error) {
                            showStatus("ä¸‹è¼‰å¤±æ•—: " + data.message, "error");
                        } else {
                            showStatus(
                                `ä¸‹è¼‰ä»»å‹™å·²å•Ÿå‹• (ID: ${data.jobId})`,
                                "success"
                            );
                            // Open progress view
                            showDownloadProgress(
                                data.jobId,
                                data.totalChapters
                            );
                            // Reload books in background
                            loadBooks().catch((error) => {
                                console.error("Error reloading books:", error);
                            });
                        }
                    })
                    .catch((error) => {
                        console.error("Download error:", error);
                        showStatus("ä¸‹è¼‰æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                    });
            }

            // Books Management
            let currentSortColumn = null;
            let currentSortDirection = "asc"; // "asc" or "desc"

            async function loadBooks() {
                try {
                    const response = await fetch("/api/books");
                    if (!response.ok) {
                        throw new Error(
                            `HTTP ${response.status}: ${response.statusText}`
                        );
                    }
                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    allBooks = Array.isArray(data) ? data : [];
                    console.log("Loaded books:", allBooks.length, allBooks);
                    applyBookFilter();
                    updateBookSelector();
                    displayBooks();
                } catch (error) {
                    console.error("Error loading books:", error);
                    showStatus("è¼‰å…¥æ›¸ç±å¤±æ•—: " + error.message, "error");
                }
            }

            function sortBooks(column) {
                if (currentSortColumn === column) {
                    // Toggle direction if clicking same column
                    currentSortDirection = currentSortDirection === "asc" ? "desc" : "asc";
                } else {
                    currentSortColumn = column;
                    currentSortDirection = "asc";
                }

                books.sort((a, b) => {
                    let aVal, bVal;

                    switch (column) {
                        case "name":
                            aVal = (a.book_name_traditional || a.book_name_simplified || "").toLowerCase();
                            bVal = (b.book_name_traditional || b.book_name_simplified || "").toLowerCase();
                            break;
                        case "author":
                            aVal = (a.author || "").toLowerCase();
                            bVal = (b.author || "").toLowerCase();
                            break;
                        case "rating":
                            aVal = a.rating || 0;
                            bVal = b.rating || 0;
                            break;
                        case "chapters":
                            aVal = a.total_chapters || 0;
                            bVal = b.total_chapters || 0;
                            break;
                        case "last_updated":
                            aVal = a.last_updated ? new Date(a.last_updated).getTime() : 0;
                            bVal = b.last_updated ? new Date(b.last_updated).getTime() : 0;
                            break;
                        default:
                            return 0;
                    }

                    if (typeof aVal === "string") {
                        return currentSortDirection === "asc"
                            ? aVal.localeCompare(bVal)
                            : bVal.localeCompare(aVal);
                    } else {
                        return currentSortDirection === "asc"
                            ? aVal - bVal
                            : bVal - aVal;
                    }
                });

                displayBooks();
            }

            function updateBookSelector() {
                const selector = document.getElementById("bookSelector");
                selector.innerHTML = '<option value="new">å»ºç«‹æ–°æ›¸ç±</option>';
                allBooks.forEach((book) => {
                    const option = document.createElement("option");
                    option.value = book.id;
                    option.textContent =
                        book.book_name_traditional || book.book_name_simplified;
                    selector.appendChild(option);
                });
            }

            function displayBooks() {
                const booksGrid = document.getElementById("booksGrid");

                if (books.length === 0) {
                    if (bookSearchQuery) {
                        booksGrid.innerHTML =
                            '<div class="empty-state">æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæœå°‹æ¢ä»¶çš„æ›¸ç±</div>';
                    } else {
                        booksGrid.innerHTML =
                            '<div class="empty-state">é‚„æ²’æœ‰æ›¸ç±</div>';
                    }
                    return;
                }

                let html = `
                    <table class="books-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" id="selectAllBooks" onchange="toggleSelectAllBooks(event)">
                                </th>
                                <th class="sortable ${currentSortColumn === "name" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('name')">æ›¸å</th>
                                <th class="sortable ${currentSortColumn === "author" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('author')">ä½œè€…</th>
                                <th class="sortable ${currentSortColumn === "rating" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('rating')">è©•åˆ†</th>
                                <th class="sortable ${currentSortColumn === "chapters" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('chapters')">ç« ç¯€ç¯„åœ</th>
                                <th>ç™¼å¸ƒæ—¥æœŸ</th>
                                <th class="sortable ${currentSortColumn === "last_updated" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('last_updated')">æœ€å¾Œæ›´æ–°</th>
                                <th style="width: 500px;">æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                books.forEach((book) => {
                    const isSelected = selectedBooks.has(book.id);
                    const chapterRange =
                        book.min_chapter && book.max_chapter
                            ? `ç¬¬${book.min_chapter}ç«  ~ ç¬¬${book.max_chapter}ç« `
                            : "ç„¡ç« ç¯€";

                    const rating = book.rating || 0;
                    const ratingStars = Array.from({ length: 5 }, (_, i) => {
                        const starValue = i + 1;
                        return `<span class="rating-star ${starValue <= rating ? "active" : ""}" 
                            data-rating="${starValue}" 
                            data-book-id="${book.id}"
                            onclick="event.stopPropagation(); setBookRating(${book.id}, ${starValue})"
                            onmouseover="event.stopPropagation(); highlightRating(${book.id}, ${starValue})"
                            onmouseout="event.stopPropagation(); resetRatingHighlight(${book.id})"
                            >â˜…</span>`;
                    }).join("");

                    html += `
                        <tr class="book-row ${isSelected ? "selected" : ""}" onclick="toggleBookSelection(${book.id}, event)">
                            <td onclick="event.stopPropagation();">
                                <input type="checkbox" class="book-checkbox" ${
                                    isSelected ? "checked" : ""
                                } onclick="event.stopPropagation(); toggleBookSelection(${book.id}, event)">
                            </td>
                            <td class="book-title">${
                                book.book_name_traditional ||
                                book.book_name_simplified
                            }</td>
                            <td>${book.author || "æœªçŸ¥"}</td>
                            <td onclick="event.stopPropagation();">
                                <div class="rating-stars" id="rating-${book.id}">${ratingStars}</div>
                            </td>
                            <td>${chapterRange}</td>
                            <td>${book.release_date || "æœªçŸ¥"}</td>
                            <td>${
                                book.last_updated
                                    ? new Date(
                                          book.last_updated
                                      ).toLocaleDateString("zh-TW")
                                    : "æœªçŸ¥"
                            }</td>
                            <td class="book-actions" onclick="event.stopPropagation();">
                                <button class="btn btn-success" onclick="viewBookDetails(${book.id})">æŸ¥çœ‹ç« ç¯€</button>
                                <button class="btn btn-primary" onclick="editBookMetadata(${book.id})">ç·¨è¼¯è³‡è¨Š</button>
                                <button class="btn btn-primary" onclick="searchMissingChapters(${book.id})">æœå°‹ç¼ºå¤±ç« ç¯€</button>
                                <button class="btn btn-primary" onclick="searchDownChapters(${book.id})">å‘ä¸‹æœå°‹</button>
                                <button class="btn btn-primary" onclick="searchNewChapters(${book.id})">æœå°‹æ–°ç« ç¯€</button>
                                <button class="btn btn-success" onclick="exportBookToJoplin(${book.id})">åŒ¯å‡ºåˆ° Joplin</button>
                                <button class="btn btn-danger" onclick="deleteBook(${book.id})">åˆªé™¤</button>
                            </td>
                        </tr>
                    `;
                });

                html += `
                        </tbody>
                    </table>
                `;

                booksGrid.innerHTML = html;
                updateBulkActions();
                updateSelectAllCheckbox();
                updateBookSearchUI();
                
                // Setup drag rating for all books
                setupDragRating();
            }

            // Book search and autocomplete functions
            function handleBookSearchInput(event) {
                const query = event.target.value.trim();
                bookSearchQuery = query;
                bookFilters.search = query;
                applyBookFilter();
                updateBookAutocomplete(query);
                updateBookSearchUI();
            }

            function handleAuthorFilterInput(event) {
                bookFilters.author = event.target.value.trim();
                applyBookFilter();
            }

            function handleRatingFilterChange() {
                const minRating = parseInt(document.getElementById("filterMinRating").value) || 0;
                const maxRating = parseInt(document.getElementById("filterMaxRating").value) || 5;
                bookFilters.minRating = minRating;
                bookFilters.maxRating = maxRating;
                applyBookFilter();
            }

            function handleChapterFilterChange() {
                const minChapters = parseInt(document.getElementById("filterMinChapters").value) || 0;
                const maxChaptersInput = document.getElementById("filterMaxChapters").value;
                const maxChapters = maxChaptersInput === "" ? null : parseInt(maxChaptersInput);
                bookFilters.minChapters = minChapters;
                bookFilters.maxChapters = maxChapters;
                applyBookFilter();
            }

            function clearAllFilters() {
                bookSearchQuery = "";
                bookFilters = {
                    search: "",
                    minRating: 0,
                    maxRating: 5,
                    minChapters: 0,
                    maxChapters: null,
                    author: ""
                };
                document.getElementById("bookSearchInput").value = "";
                document.getElementById("filterAuthor").value = "";
                document.getElementById("filterMinRating").value = "0";
                document.getElementById("filterMaxRating").value = "5";
                document.getElementById("filterMinChapters").value = "0";
                document.getElementById("filterMaxChapters").value = "";
                applyBookFilter();
                updateBookSearchUI();
            }

            function handleBookSearchKeydown(event) {
                if (event.key === 'Escape') {
                    clearBookSearch();
                }
            }

            function clearBookSearch() {
                const searchInput = document.getElementById("bookSearchInput");
                if (searchInput) {
                    searchInput.value = "";
                    bookSearchQuery = "";
                    bookFilters.search = "";
                    applyBookFilter();
                    updateBookSearchUI();
                    hideBookAutocomplete();
                }
            }

            function updateBookSearchUI() {
                const clearBtn = document.getElementById("clearBookSearchBtn");
                const searchInfo = document.getElementById("bookSearchInfo");
                const searchCount = document.getElementById("bookSearchCount");
                
                const hasActiveFilters = bookFilters.search || bookFilters.author || 
                    bookFilters.minRating > 0 || bookFilters.maxRating < 5 || 
                    bookFilters.minChapters > 0 || bookFilters.maxChapters !== null;
                
                if (bookSearchQuery || hasActiveFilters) {
                    // Show clear button
                    if (clearBtn) {
                        clearBtn.style.display = "block";
                    }
                    // Show search info
                    if (searchInfo) {
                        searchInfo.style.display = "block";
                    }
                    // Update count
                    if (searchCount) {
                        const total = allBooks.length;
                        const filtered = books.length;
                        if (filtered === total) {
                            searchCount.textContent = `é¡¯ç¤ºå…¨éƒ¨ ${total} æœ¬æ›¸ç±`;
                        } else {
                            searchCount.textContent = `æ‰¾åˆ° ${filtered} / ${total} æœ¬æ›¸ç±`;
                            searchCount.style.color = "#007bff";
                            searchCount.style.fontWeight = "600";
                        }
                    }
                } else {
                    // Hide clear button
                    if (clearBtn) {
                        clearBtn.style.display = "none";
                    }
                    // Hide search info
                    if (searchInfo) {
                        searchInfo.style.display = "none";
                    }
                }
            }

            function applyBookFilter() {
                books = allBooks.filter((book) => {
                    // Search filter (book name or author)
                    if (bookFilters.search) {
                        const query = normalizeToHalfWidth(bookFilters.search.toLowerCase());
                        const bookName = normalizeToHalfWidth(
                            (book.book_name_traditional || book.book_name_simplified || "").toLowerCase()
                        );
                        const author = normalizeToHalfWidth(
                            (book.author || "").toLowerCase()
                        );
                        if (!bookName.includes(query) && !author.includes(query)) {
                            return false;
                        }
                    }

                    // Author filter
                    if (bookFilters.author) {
                        const authorQuery = normalizeToHalfWidth(bookFilters.author.toLowerCase());
                        const author = normalizeToHalfWidth((book.author || "").toLowerCase());
                        if (!author.includes(authorQuery)) {
                            return false;
                        }
                    }

                    // Rating filter
                    const rating = book.rating || 0;
                    if (rating < bookFilters.minRating || rating > bookFilters.maxRating) {
                        return false;
                    }

                    // Chapter count filter
                    const chapterCount = book.total_chapters || 0;
                    if (chapterCount < bookFilters.minChapters) {
                        return false;
                    }
                    if (bookFilters.maxChapters !== null && chapterCount > bookFilters.maxChapters) {
                        return false;
                    }

                    return true;
                });

                // Apply sorting if active
                if (currentSortColumn) {
                    sortBooks(currentSortColumn);
                } else {
                    displayBooks();
                }
            }

            function updateBookAutocomplete(query) {
                const autocomplete = document.getElementById("bookAutocomplete");
                if (!autocomplete) return;

                if (!query || query.length < 1) {
                    autocomplete.style.display = "none";
                    return;
                }

                const normalizedQuery = normalizeToHalfWidth(query.toLowerCase());
                const matches = [];

                // Find matching books (limit to 10)
                for (const book of allBooks) {
                    if (matches.length >= 10) break;

                    const bookName = normalizeToHalfWidth(
                        (book.book_name_traditional || book.book_name_simplified || "").toLowerCase()
                    );
                    const author = normalizeToHalfWidth(
                        (book.author || "").toLowerCase()
                    );

                    const nameMatch = bookName.includes(normalizedQuery);
                    const authorMatch = author.includes(normalizedQuery);

                    if (nameMatch || authorMatch) {
                        matches.push({
                            book,
                            matchType: nameMatch ? "name" : "author",
                        });
                    }
                }

                if (matches.length === 0) {
                    autocomplete.style.display = "none";
                    return;
                }

                let html = "";
                matches.forEach(({ book, matchType }) => {
                    const bookName = book.book_name_traditional || book.book_name_simplified || "æœªçŸ¥";
                    const author = book.author || "æœªçŸ¥";
                    
                    // Highlight matching text
                    const highlightBookName = highlightMatch(bookName, query);
                    const highlightAuthor = highlightMatch(author, query);

                    html += `
                        <div class="book-autocomplete-item" onclick="selectBookFromAutocomplete('${book.id}')">
                            <div class="book-autocomplete-item-title">${highlightBookName}</div>
                            <div class="book-autocomplete-item-author">ä½œè€…: ${highlightAuthor}</div>
                        </div>
                    `;
                });

                autocomplete.innerHTML = html;
                autocomplete.style.display = "block";
            }

            function highlightMatch(text, query) {
                if (!query) return text;
                const normalizedText = normalizeToHalfWidth(text);
                const normalizedQuery = normalizeToHalfWidth(query);
                const index = normalizedText.toLowerCase().indexOf(normalizedQuery.toLowerCase());
                
                if (index === -1) return text;
                
                const before = text.substring(0, index);
                const match = text.substring(index, index + query.length);
                const after = text.substring(index + query.length);
                
                return `${before}<span class="book-autocomplete-item-highlight">${match}</span>${after}`;
            }

            function selectBookFromAutocomplete(bookId) {
                const bookIdNum = parseInt(bookId);
                const book = allBooks.find((b) => b.id === bookIdNum);
                if (book) {
                    const bookName = book.book_name_traditional || book.book_name_simplified || "";
                    const author = book.author || "";
                    const searchInput = document.getElementById("bookSearchInput");
                    if (searchInput) {
                        searchInput.value = `${bookName} ${author}`.trim();
                        bookSearchQuery = searchInput.value.trim();
                        applyBookFilter();
                        displayBooks();
                    }
                }
                hideBookAutocomplete();
            }

            function showBookAutocomplete() {
                const autocomplete = document.getElementById("bookAutocomplete");
                const searchInput = document.getElementById("bookSearchInput");
                if (autocomplete && searchInput && searchInput.value.trim()) {
                    updateBookAutocomplete(searchInput.value.trim());
                }
            }

            function hideBookAutocomplete() {
                // Delay hiding to allow click events on autocomplete items
                setTimeout(() => {
                    const autocomplete = document.getElementById("bookAutocomplete");
                    if (autocomplete) {
                        autocomplete.style.display = "none";
                    }
                }, 200);
            }

            function highlightRating(bookId, rating) {
                const ratingContainer = document.getElementById(`rating-${bookId}`);
                if (!ratingContainer) return;
                
                const stars = ratingContainer.querySelectorAll(".rating-star");
                stars.forEach((star, index) => {
                    if (index < rating) {
                        star.style.color = "#ffc107";
                    } else {
                        star.style.color = "#ddd";
                    }
                });
            }

            function resetRatingHighlight(bookId) {
                const ratingContainer = document.getElementById(`rating-${bookId}`);
                if (!ratingContainer) return;
                
                const book = allBooks.find(b => b.id === bookId);
                const currentRating = book?.rating || 0;
                
                const stars = ratingContainer.querySelectorAll(".rating-star");
                stars.forEach((star, index) => {
                    if (index < currentRating) {
                        star.style.color = "#ffc107";
                    } else {
                        star.style.color = "#ddd";
                    }
                });
            }

            async function setBookRating(bookId, rating) {
                try {
                    const response = await fetch(`/api/books/${bookId}`, {
                        method: "PUT",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ rating: rating }),
                    });

                    const data = await response.json();
                    if (data.error) {
                        showStatus("æ›´æ–°è©•åˆ†å¤±æ•—: " + data.message, "error");
                        return;
                    }

                    // Update local book data
                    const book = books.find(b => b.id === bookId);
                    const allBook = allBooks.find(b => b.id === bookId);
                    if (book) {
                        book.rating = rating;
                    }
                    if (allBook) {
                        allBook.rating = rating;
                    }

                    // Update display
                    displayBooks();
                    showStatus("è©•åˆ†å·²æ›´æ–°", "success");
                } catch (error) {
                    console.error("Error setting rating:", error);
                    showStatus("æ›´æ–°è©•åˆ†æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            function setupDragRating() {
                // Setup drag and drop for rating stars
                books.forEach((book) => {
                    const ratingContainer = document.getElementById(`rating-${book.id}`);
                    if (!ratingContainer) return;

                    let isDragging = false;
                    let currentDragRating = 0;

                    ratingContainer.addEventListener("mousedown", (e) => {
                        if (e.target.classList.contains("rating-star")) {
                            isDragging = true;
                            currentDragRating = parseInt(e.target.dataset.rating);
                            highlightRating(book.id, currentDragRating);
                            e.preventDefault();
                        }
                    });

                    ratingContainer.addEventListener("mousemove", (e) => {
                        if (isDragging) {
                            const star = e.target.closest(".rating-star");
                            if (star) {
                                currentDragRating = parseInt(star.dataset.rating);
                                highlightRating(book.id, currentDragRating);
                            }
                        }
                    });

                    ratingContainer.addEventListener("mouseup", (e) => {
                        if (isDragging) {
                            isDragging = false;
                            const star = e.target.closest(".rating-star");
                            if (star) {
                                currentDragRating = parseInt(star.dataset.rating);
                                setBookRating(book.id, currentDragRating);
                            } else if (currentDragRating > 0) {
                                setBookRating(book.id, currentDragRating);
                            } else {
                                resetRatingHighlight(book.id);
                            }
                        }
                    });

                    ratingContainer.addEventListener("mouseleave", (e) => {
                        if (isDragging) {
                            // Check if we're still over a star
                            const star = e.relatedTarget?.closest(".rating-star");
                            if (!star) {
                                isDragging = false;
                                resetRatingHighlight(book.id);
                            }
                        }
                    });

                    // Also handle touch events for mobile
                    ratingContainer.addEventListener("touchstart", (e) => {
                        const star = e.target.closest(".rating-star");
                        if (star) {
                            isDragging = true;
                            currentDragRating = parseInt(star.dataset.rating);
                            highlightRating(book.id, currentDragRating);
                            e.preventDefault();
                        }
                    });

                    ratingContainer.addEventListener("touchmove", (e) => {
                        if (isDragging) {
                            const touch = e.touches[0];
                            const star = document.elementFromPoint(touch.clientX, touch.clientY)?.closest(".rating-star");
                            if (star) {
                                currentDragRating = parseInt(star.dataset.rating);
                                highlightRating(book.id, currentDragRating);
                            }
                            e.preventDefault();
                        }
                    });

                    ratingContainer.addEventListener("touchend", (e) => {
                        if (isDragging) {
                            isDragging = false;
                            if (currentDragRating > 0) {
                                setBookRating(book.id, currentDragRating);
                            } else {
                                resetRatingHighlight(book.id);
                            }
                            e.preventDefault();
                        }
                    });
                });
            }

            function toggleSelectAllBooks(event) {
                const checked = event.target.checked;
                books.forEach((book) => {
                    if (checked) {
                        selectedBooks.add(book.id);
                    } else {
                        selectedBooks.delete(book.id);
                    }
                });
                displayBooks();
                updateBulkActions();
            }

            function updateSelectAllCheckbox() {
                const selectAllCheckbox = document.getElementById("selectAllBooks");
                if (selectAllCheckbox && books.length > 0) {
                    const allSelected = books.every((book) => selectedBooks.has(book.id));
                    const someSelected = books.some((book) => selectedBooks.has(book.id));
                    selectAllCheckbox.checked = allSelected;
                    selectAllCheckbox.indeterminate = someSelected && !allSelected;
                }
            }

            function toggleBookSelection(bookId, event) {
                if (selectedBooks.has(bookId)) {
                    selectedBooks.delete(bookId);
                } else {
                    selectedBooks.add(bookId);
                }
                displayBooks();
            }

            function updateBulkActions() {
                const count = selectedBooks.size;
                const bulkActions = document.getElementById("bulkActions");
                const bulkActionsInfo =
                    document.getElementById("bulkActionsInfo");
                const exportBtn = document.getElementById("exportToJoplinBtn");

                if (count > 0) {
                    bulkActions.classList.add("active");
                    bulkActionsInfo.textContent = `å·²é¸æ“‡ ${count} æœ¬æ›¸ç±`;
                    exportBtn.disabled = false;
                } else {
                    bulkActions.classList.remove("active");
                    exportBtn.disabled = true;
                }
            }

            async function exportSelectedToJoplin() {
                const bookIds = Array.from(selectedBooks);
                if (bookIds.length === 0) {
                    showStatus("è«‹é¸æ“‡è¦åŒ¯å‡ºçš„æ›¸ç±", "error");
                    return;
                }

                showStatus(`æ­£åœ¨åŒ¯å‡º ${bookIds.length} æœ¬æ›¸ç±åˆ° Joplin...`, "");

                try {
                    for (const bookId of bookIds) {
                        const response = await fetch(
                            `/api/joplin/export/${bookId}`,
                            {
                                method: "POST",
                            }
                        );
                        const data = await response.json();
                        if (data.error) {
                            showStatus(
                                `åŒ¯å‡ºæ›¸ç± ID ${bookId} å¤±æ•—: ${data.message}`,
                                "error"
                            );
                        }
                    }
                    showStatus(
                        `æˆåŠŸåŒ¯å‡º ${bookIds.length} æœ¬æ›¸ç±åˆ° Joplin`,
                        "success"
                    );
                    selectedBooks.clear();
                    displayBooks();
                } catch (error) {
                    console.error("Export error:", error);
                    showStatus("åŒ¯å‡ºæ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            async function exportBookToJoplin(bookId) {
                showStatus("æ­£åœ¨åŒ¯å‡ºåˆ° Joplin...", "");

                try {
                    const response = await fetch(
                        `/api/joplin/export/${bookId}`,
                        {
                            method: "POST",
                        }
                    );
                    const data = await response.json();
                    if (data.error) {
                        showStatus("åŒ¯å‡ºå¤±æ•—: " + data.message, "error");
                    } else {
                        showStatus("æˆåŠŸåŒ¯å‡ºåˆ° Joplin", "success");
                    }
                } catch (error) {
                    console.error("Export error:", error);
                    showStatus("åŒ¯å‡ºæ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            let currentBookDetailsId = null;
            let currentViewingBookId = null;

            async function viewBookDetails(bookId) {
                try {
                    currentViewingBookId = bookId;
                    currentBookDetailsId = bookId;
                    showStatus("è¼‰å…¥æ›¸ç±ç« ç¯€...", "");

                    // Switch to chapters tab
                    switchTab("chapters");

                    // Load chapters
                    await loadChaptersForBook(bookId);

                    // Show back button, reformat button, and toolbar
                    document.getElementById("backToBooksBtn").style.display =
                        "inline-block";
                    document.getElementById(
                        "reformatChaptersBtn"
                    ).style.display = "inline-block";
                    const toolbar = document.getElementById("chapterToolbar");
                    if (toolbar) {
                        toolbar.style.display = "block";
                    }

                    showStatus("ç« ç¯€å·²è¼‰å…¥", "success");
                } catch (error) {
                    console.error("Error loading book chapters:", error);
                    showStatus("è¼‰å…¥ç« ç¯€å¤±æ•—: " + error.message, "error");
                }
            }

            function backToBooks() {
                currentViewingBookId = null;
                document.getElementById("backToBooksBtn").style.display =
                    "none";
                document.getElementById("reformatChaptersBtn").style.display =
                    "none";
                // Keep toolbar visible but show message that no book is selected
                document.getElementById("chaptersTabTitle").textContent =
                    "ç« ç¯€åˆ—è¡¨";
                document.getElementById("chaptersList").innerHTML = "";
                const urlInput = document.getElementById("chapterUrlInput");
                if (urlInput) {
                    urlInput.value = "";
                }
                switchTab("books");
            }

            async function addChapterFromUrl() {
                if (!currentViewingBookId) {
                    showStatus("è«‹å…ˆé¸æ“‡ä¸€æœ¬æ›¸ç±", "error");
                    return;
                }

                const urlInput = document.getElementById("chapterUrlInput");
                const url = urlInput.value.trim();

                if (!url) {
                    showStatus("è«‹è¼¸å…¥ç« ç¯€ URL", "error");
                    return;
                }

                // Validate URL format
                if (!url.includes("cool18.com") && !url.includes("tid=")) {
                    showStatus("è«‹è¼¸å…¥æœ‰æ•ˆçš„ Cool18 ç« ç¯€ URL", "error");
                    return;
                }

                try {
                    showStatus("æ­£åœ¨ä¸‹è¼‰ç« ç¯€...", "");

                    // Create chapter data for download (title will be extracted during download)
                    const chapterData = {
                        url: url,
                        title: "", // Will be extracted during download
                    };

                    // Start download for this single chapter
                    const downloadResponse = await fetch("/api/download/start", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            chapters: [chapterData],
                            bookId: currentViewingBookId,
                        }),
                    });

                    const downloadResult = await downloadResponse.json();

                    if (downloadResult.error) {
                        throw new Error(downloadResult.error);
                    }

                    showStatus("ç« ç¯€ä¸‹è¼‰å·²é–‹å§‹ï¼Œè«‹æŸ¥çœ‹æ©Ÿå™¨äººç‹€æ…‹", "success");
                    urlInput.value = "";

                    // Refresh chapters after a delay
                    setTimeout(() => {
                        refreshChapters();
                    }, 2000);
                } catch (error) {
                    console.error("Error adding chapter from URL:", error);
                    showStatus("ä¸‹è¼‰ç« ç¯€å¤±æ•—: " + error.message, "error");
                }
            }

            async function handleChapterFileUpload(event) {
                if (!currentViewingBookId) {
                    showStatus("è«‹å…ˆé¸æ“‡ä¸€æœ¬æ›¸ç±", "error");
                    event.target.value = "";
                    return;
                }

                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                try {
                    showStatus("æ­£åœ¨ä¸Šå‚³æª”æ¡ˆ...", "");

                    // Upload file
                    const formData = new FormData();
                    formData.append("file", file);

                    const uploadResponse = await fetch("/api/upload", {
                        method: "POST",
                        body: formData,
                    });

                    const uploadResult = await uploadResponse.json();

                    if (uploadResult.error) {
                        throw new Error(uploadResult.error);
                    }

                    // Process file with the current book ID
                    const processResponse = await fetch("/api/upload/process", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            filename: uploadResult.filename,
                            originalName: file.name,
                            bookId: currentViewingBookId,
                        }),
                    });

                    const processResult = await processResponse.json();

                    if (processResult.error) {
                        throw new Error(processResult.error);
                    }

                    showStatus("æª”æ¡ˆè™•ç†ä¸­ï¼Œè«‹æŸ¥çœ‹æ©Ÿå™¨äººç‹€æ…‹", "success");
                    event.target.value = "";

                    // Refresh chapters after a delay
                    setTimeout(() => {
                        refreshChapters();
                    }, 2000);
                } catch (error) {
                    console.error("Error uploading chapter file:", error);
                    showStatus("ä¸Šå‚³æª”æ¡ˆå¤±æ•—: " + error.message, "error");
                    event.target.value = "";
                }
            }

            async function reformatAllChapters() {
                if (!currentViewingBookId) {
                    showStatus("æ²’æœ‰æ­£åœ¨æŸ¥çœ‹çš„æ›¸ç±", "error");
                    return;
                }

                if (
                    !confirm(
                        "ç¢ºå®šè¦é‡æ–°æ ¼å¼åŒ–æ­¤æ›¸ç±çš„æ‰€æœ‰ç« ç¯€å—ï¼Ÿé€™å°‡æ›´æ–°æ‰€æœ‰ç« ç¯€çš„æ ¼å¼ã€‚"
                    )
                ) {
                    return;
                }

                try {
                    showStatus("æ­£åœ¨é‡æ–°æ ¼å¼åŒ–ç« ç¯€...", "");

                    const response = await fetch(
                        `/api/books/${currentViewingBookId}/reformat-chapters`,
                        {
                            method: "POST",
                        }
                    );

                    const data = await response.json();

                    if (data.error) {
                        showStatus("é‡æ–°æ ¼å¼åŒ–å¤±æ•—: " + data.message, "error");
                    } else {
                        showStatus(
                            `æˆåŠŸé‡æ–°æ ¼å¼åŒ– ${data.reformatted}/${
                                data.total
                            } å€‹ç« ç¯€${
                                data.errors > 0
                                    ? ` (${data.errors} å€‹éŒ¯èª¤)`
                                    : ""
                            }`,
                            "success"
                        );
                        // Reload chapters to show updated content
                        await loadChaptersForBook(currentViewingBookId);
                    }
                } catch (error) {
                    console.error("Reformat error:", error);
                    showStatus(
                        "é‡æ–°æ ¼å¼åŒ–æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message,
                        "error"
                    );
                }
            }

            async function loadChaptersForBook(bookId) {
                try {
                    // Fetch book info
                    const bookResponse = await fetch(`/api/books/${bookId}`);
                    const book = await bookResponse.json();

                    if (book.error) {
                        showStatus("è¼‰å…¥æ›¸ç±è³‡è¨Šå¤±æ•—: " + book.error, "error");
                        return;
                    }

                    // Update title
                    document.getElementById(
                        "chaptersTabTitle"
                    ).textContent = `ç« ç¯€åˆ—è¡¨ - ${
                        book.book_name_traditional ||
                        book.book_name_simplified ||
                        "æœªçŸ¥æ›¸ç±"
                    }`;

                    // Fetch chapters
                    const chaptersResponse = await fetch(
                        `/api/books/${bookId}/chapters`
                    );
                    const chapters = await chaptersResponse.json();

                    if (chapters.error) {
                        showStatus("è¼‰å…¥ç« ç¯€å¤±æ•—: " + chapters.error, "error");
                        return;
                    }

                    // Display chapters
                    displayChapters(chapters, book);
                } catch (error) {
                    console.error("Error loading chapters:", error);
                    showStatus("è¼‰å…¥ç« ç¯€å¤±æ•—: " + error.message, "error");
                }
            }

            function displayChapters(chapters, book) {
                const chaptersList = document.getElementById("chaptersList");

                if (!chapters || chapters.length === 0) {
                    chaptersList.innerHTML =
                        '<div class="empty-state">æ²’æœ‰ç« ç¯€</div>';
                    return;
                }

                // Sort chapters by chapter_number
                const sortedChapters = [...chapters].sort((a, b) => {
                    const numA =
                        a.chapter_number !== null ? a.chapter_number : 999999;
                    const numB =
                        b.chapter_number !== null ? b.chapter_number : 999999;
                    return numA - numB;
                });

                let html = `
                    <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                        <h4>æ›¸ç±è³‡è¨Š</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                            <div><strong>æ›¸åï¼ˆç°¡é«”ï¼‰:</strong> ${
                                book.book_name_simplified || "æœªçŸ¥"
                            }</div>
                            <div><strong>æ›¸åï¼ˆç¹é«”ï¼‰:</strong> ${
                                book.book_name_traditional || "æœªçŸ¥"
                            }</div>
                            <div><strong>ä½œè€…:</strong> ${
                                book.author || "æœªçŸ¥"
                            }</div>
                            <div><strong>åˆ†é¡:</strong> ${
                                book.category || "æœªçŸ¥"
                            }</div>
                            <div><strong>ç¸½ç« ç¯€æ•¸:</strong> ${
                                book.total_chapters || 0
                            }</div>
                            <div><strong>ä¾†æºç¶²å€:</strong> ${
                                book.source_url
                                    ? `<a href="${book.source_url}" target="_blank">æŸ¥çœ‹</a>`
                                    : "ç„¡"
                            }</div>
                        </div>
                        ${
                            book.description
                                ? `<div style="margin-top: 10px;"><strong>æè¿°:</strong><br/>${book.description}</div>`
                                : ""
                        }
                        ${
                            book.tags && book.tags.length > 0
                                ? `<div style="margin-top: 10px;"><strong>æ¨™ç±¤:</strong> ${book.tags.join(
                                      ", "
                                  )}</div>`
                                : ""
                        }
                    </div>
                    <div>
                        <h4>ç« ç¯€åˆ—è¡¨ (${sortedChapters.length} å€‹ç« ç¯€)</h4>
                        <div style="margin-top: 10px;">
                `;

                sortedChapters.forEach((chapter) => {
                    const statusClass =
                        chapter.status === "downloaded"
                            ? "success"
                            : chapter.status === "failed"
                            ? "error"
                            : "";
                    const hasContent =
                        chapter.content && chapter.content.trim().length > 0;

                    html += `
                        <div class="chapter-item" style="padding: 15px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">
                                        ç¬¬${
                                            chapter.chapter_number !== null
                                                ? chapter.chapter_number
                                                : "æœªçŸ¥"
                                        }ç« 
                                        ${
                                            chapter.chapter_title ||
                                            chapter.chapter_title_simplified
                                                ? ` - ${
                                                      chapter.chapter_title ||
                                                      chapter.chapter_title_simplified
                                                  }`
                                                : ""
                                        }
                                    </div>
                                    <div style="color: #666; font-size: 14px; margin-bottom: 5px;">
                                        <span class="status ${statusClass}">${
                        chapter.status === "downloaded"
                            ? "å·²ä¸‹è¼‰"
                            : chapter.status === "failed"
                            ? "å¤±æ•—"
                            : chapter.status || "æœªçŸ¥"
                    }</span>
                                        ${
                                            hasContent
                                                ? `<span style="margin-left: 10px;">å…§å®¹: ${chapter.content.length} å­—å…ƒ</span>`
                                                : '<span style="margin-left: 10px; color: #999;">ç„¡å…§å®¹</span>'
                                        }
                                    </div>
                                    ${
                                        chapter.cool18_url
                                            ? `<div style="margin-top: 5px;"><a href="${chapter.cool18_url}" target="_blank" style="color: #007bff;">æŸ¥çœ‹åŸæ–‡</a></div>`
                                            : ""
                                    }
                                </div>
                                <div style="display: flex; gap: 5px; margin-left: 10px;">
                                    ${
                                        hasContent
                                            ? `<button class="btn btn-primary" onclick="viewChapterContent(${chapter.id}, ${currentViewingBookId})">æŸ¥çœ‹å…§å®¹</button>`
                                            : ""
                                    }
                                    <button class="btn btn-primary" onclick="editChapter(${
                                        chapter.id
                                    }, ${currentViewingBookId})">ç·¨è¼¯</button>
                                    <button class="btn btn-danger" onclick="deleteChapter(${
                                        chapter.id
                                    }, ${currentViewingBookId})">åˆªé™¤</button>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += "</div></div>";
                chaptersList.innerHTML = html;
            }

            async function refreshChapters() {
                if (currentViewingBookId) {
                    await loadChaptersForBook(currentViewingBookId);
                } else {
                    showStatus("æ²’æœ‰æ­£åœ¨æŸ¥çœ‹çš„æ›¸ç±", "error");
                }
            }

            async function viewChapterContent(chapterId, bookId) {
                try {
                    showStatus("è¼‰å…¥ç« ç¯€å…§å®¹...", "");
                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`
                    );
                    const chapter = await response.json();

                    if (chapter.error) {
                        showStatus(
                            "è¼‰å…¥ç« ç¯€å…§å®¹å¤±æ•—: " + chapter.error,
                            "error"
                        );
                        return;
                    }

                    // Create modal for viewing chapter content
                    let modalHtml = `
                        <div id="chapterContentModal" class="modal active">
                            <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
                                <div class="progress-header">
                                    <h3>ç« ç¯€å…§å®¹ - ç¬¬${
                                        chapter.chapter_number !== null
                                            ? chapter.chapter_number
                                            : "æœªçŸ¥"
                                    }ç« </h3>
                                    <button class="close-button" onclick="closeChapterContentModal()">&times;</button>
                                </div>
                                <div style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 100px);">
                                    <div style="margin-bottom: 15px;">
                                        <strong>ç« ç¯€æ¨™é¡Œ:</strong> ${
                                            chapter.chapter_title ||
                                            chapter.chapter_title_simplified ||
                                            "ç„¡æ¨™é¡Œ"
                                        }
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <strong>ç« ç¯€ç·¨è™Ÿ:</strong> ${
                                            chapter.chapter_number !== null
                                                ? chapter.chapter_number
                                                : "æœªçŸ¥"
                                        }
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <strong>ç‹€æ…‹:</strong> <span class="status ${
                                            chapter.status === "downloaded"
                                                ? "success"
                                                : chapter.status === "failed"
                                                ? "error"
                                                : ""
                                        }">${
                        chapter.status === "downloaded"
                            ? "å·²ä¸‹è¼‰"
                            : chapter.status === "failed"
                            ? "å¤±æ•—"
                            : chapter.status || "æœªçŸ¥"
                    }</span>
                                    </div>
                                    ${
                                        chapter.cool18_url
                                            ? `<div style="margin-bottom: 15px;"><strong>ä¾†æº:</strong> <a href="${chapter.cool18_url}" target="_blank">æŸ¥çœ‹åŸæ–‡</a></div>`
                                            : ""
                                    }
                                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; white-space: pre-wrap; line-height: 1.6;">
                                        ${chapter.content || "ç„¡å…§å®¹"}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Remove existing modal if any
                    const existingModal = document.getElementById(
                        "chapterContentModal"
                    );
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Add modal to body
                    document.body.insertAdjacentHTML("beforeend", modalHtml);
                } catch (error) {
                    console.error("Error loading chapter content:", error);
                    showStatus("è¼‰å…¥ç« ç¯€å…§å®¹å¤±æ•—: " + error.message, "error");
                }
            }

            function closeChapterContentModal() {
                const modal = document.getElementById("chapterContentModal");
                if (modal) {
                    modal.remove();
                }
            }

            async function editChapter(chapterId, bookId) {
                try {
                    showStatus("è¼‰å…¥ç« ç¯€è³‡è¨Š...", "");
                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`
                    );
                    const chapter = await response.json();

                    if (chapter.error) {
                        showStatus(
                            "è¼‰å…¥ç« ç¯€è³‡è¨Šå¤±æ•—: " + chapter.error,
                            "error"
                        );
                        return;
                    }

                    // Create modal for editing chapter
                    let modalHtml = `
                        <div id="chapterEditModal" class="modal active">
                            <div class="modal-content" style="max-width: 700px;">
                                <div class="progress-header">
                                    <h3>ç·¨è¼¯ç« ç¯€</h3>
                                    <button class="close-button" onclick="closeChapterEditModal()">&times;</button>
                                </div>
                                <div style="padding: 20px;">
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>ç« ç¯€ç·¨è™Ÿ:</strong></label>
                                        <input type="number" id="editChapterNumber" value="${
                                            chapter.chapter_number !== null
                                                ? chapter.chapter_number
                                                : ""
                                        }" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>ç« ç¯€æ¨™é¡Œï¼ˆç¹é«”ï¼‰:</strong></label>
                                        <input type="text" id="editChapterTitle" value="${
                                            chapter.chapter_title || ""
                                        }" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>ç« ç¯€æ¨™é¡Œï¼ˆç°¡é«”ï¼‰:</strong></label>
                                        <input type="text" id="editChapterTitleSimplified" value="${
                                            chapter.chapter_title_simplified ||
                                            ""
                                        }" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>ç‹€æ…‹:</strong></label>
                                        <select id="editChapterStatus" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                            <option value="pending" ${
                                                chapter.status === "pending"
                                                    ? "selected"
                                                    : ""
                                            }>å¾…è™•ç†</option>
                                            <option value="downloaded" ${
                                                chapter.status === "downloaded"
                                                    ? "selected"
                                                    : ""
                                            }>å·²ä¸‹è¼‰</option>
                                            <option value="failed" ${
                                                chapter.status === "failed"
                                                    ? "selected"
                                                    : ""
                                            }>å¤±æ•—</option>
                                        </select>
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>å…§å®¹:</strong></label>
                                        <textarea id="editChapterContent" rows="10" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">${(
                                            chapter.content || ""
                                        )
                                            .replace(/&/g, "&amp;")
                                            .replace(/</g, "&lt;")
                                            .replace(/>/g, "&gt;")
                                            .replace(/"/g, "&quot;")
                                            .replace(/'/g, "&#39;")}</textarea>
                                    </div>
                                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                        <button class="btn btn-secondary" onclick="closeChapterEditModal()">å–æ¶ˆ</button>
                                        <button class="btn btn-success" onclick="saveChapterEdit(${chapterId}, ${bookId})">å„²å­˜</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Remove existing modal if any
                    const existingModal =
                        document.getElementById("chapterEditModal");
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Add modal to body
                    document.body.insertAdjacentHTML("beforeend", modalHtml);
                } catch (error) {
                    console.error("Error loading chapter for edit:", error);
                    showStatus("è¼‰å…¥ç« ç¯€è³‡è¨Šå¤±æ•—: " + error.message, "error");
                }
            }

            function closeChapterEditModal() {
                const modal = document.getElementById("chapterEditModal");
                if (modal) {
                    modal.remove();
                }
            }

            async function saveChapterEdit(chapterId, bookId) {
                try {
                    const chapterNumber =
                        document.getElementById("editChapterNumber").value;
                    const chapterTitle =
                        document.getElementById("editChapterTitle").value;
                    const chapterTitleSimplified = document.getElementById(
                        "editChapterTitleSimplified"
                    ).value;
                    const chapterStatus =
                        document.getElementById("editChapterStatus").value;
                    const chapterContent =
                        document.getElementById("editChapterContent").value;

                    showStatus("å„²å­˜ä¸­...", "");

                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`,
                        {
                            method: "PUT",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                chapter_number: chapterNumber
                                    ? parseInt(chapterNumber)
                                    : null,
                                chapter_title: chapterTitle || null,
                                chapter_title_simplified:
                                    chapterTitleSimplified || null,
                                status: chapterStatus,
                                content: chapterContent || null,
                            }),
                        }
                    );

                    const data = await response.json();

                    if (data.error) {
                        showStatus(
                            "å„²å­˜å¤±æ•—: " + (data.message || data.error),
                            "error"
                        );
                        return;
                    }

                    closeChapterEditModal();
                    showStatus("ç« ç¯€å·²æ›´æ–°", "success");

                    // Refresh chapters list
                    if (currentViewingBookId) {
                        await loadChaptersForBook(currentViewingBookId);
                    }
                } catch (error) {
                    console.error("Error saving chapter:", error);
                    showStatus("å„²å­˜å¤±æ•—: " + error.message, "error");
                }
            }

            async function deleteChapter(chapterId, bookId) {
                if (!confirm("ç¢ºå®šè¦åˆªé™¤æ­¤ç« ç¯€å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚")) {
                    return;
                }

                try {
                    showStatus("åˆªé™¤ä¸­...", "");
                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`,
                        {
                            method: "DELETE",
                        }
                    );

                    const data = await response.json();

                    if (data.error) {
                        showStatus(
                            "åˆªé™¤å¤±æ•—: " + (data.message || data.error),
                            "error"
                        );
                        return;
                    }

                    showStatus("ç« ç¯€å·²åˆªé™¤", "success");

                    // Refresh chapters list
                    if (currentViewingBookId) {
                        await loadChaptersForBook(currentViewingBookId);
                    }
                } catch (error) {
                    console.error("Error deleting chapter:", error);
                    showStatus("åˆªé™¤å¤±æ•—: " + error.message, "error");
                }
            }

            async function deleteBook(bookId) {
                if (
                    !confirm(
                        "ç¢ºå®šè¦åˆªé™¤æ­¤æ›¸ç±å—ï¼Ÿæ­¤æ“ä½œå°‡åŒæ™‚åˆªé™¤æ‰€æœ‰ç›¸é—œç« ç¯€ï¼Œä¸”ç„¡æ³•å¾©åŸã€‚"
                    )
                ) {
                    return;
                }

                try {
                    showStatus("åˆªé™¤ä¸­...", "");
                    const response = await fetch(`/api/books/${bookId}`, {
                        method: "DELETE",
                    });

                    const data = await response.json();

                    if (data.error) {
                        showStatus(
                            "åˆªé™¤å¤±æ•—: " + (data.message || data.error),
                            "error"
                        );
                        return;
                    }

                    showStatus("æ›¸ç±å·²åˆªé™¤", "success");

                    // Refresh books list
                    await refreshBooks();

                    // If we're viewing this book's chapters, go back to books tab
                    if (currentViewingBookId === bookId) {
                        backToBooks();
                    }
                } catch (error) {
                    console.error("Error deleting book:", error);
                    showStatus("åˆªé™¤å¤±æ•—: " + error.message, "error");
                }
            }

            function closeBookDetailsModal() {
                document
                    .getElementById("bookDetailsModal")
                    .classList.remove("active");
                currentBookDetailsId = null;
            }

            async function rescanBookChapters() {
                if (!currentBookDetailsId) {
                    showStatus("æ²’æœ‰é¸ä¸­çš„æ›¸ç±", "error");
                    return;
                }

                const rescanBtn = document.getElementById("rescanChaptersBtn");
                const originalText = rescanBtn.textContent;
                rescanBtn.disabled = true;
                rescanBtn.textContent = "æƒæä¸­...";

                try {
                    showStatus("æ­£åœ¨é‡æ–°æƒæç« ç¯€è³‡è¨Š...", "");
                    const response = await fetch(
                        `/api/books/${currentBookDetailsId}/rescan-chapters`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        }
                    );

                    const data = await response.json();
                    if (data.error) {
                        showStatus("é‡æ–°æƒæå¤±æ•—: " + data.message, "error");
                    } else {
                        showStatus(
                            data.message || `å·²æ›´æ–° ${data.updated} å€‹ç« ç¯€`,
                            "success"
                        );
                        // Reload book details to show updated information
                        await viewBookDetails(currentBookDetailsId);
                        // Also reload books list
                        await loadBooks();
                    }
                } catch (error) {
                    console.error("Error rescanning chapters:", error);
                    showStatus("é‡æ–°æƒææ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                } finally {
                    rescanBtn.disabled = false;
                    rescanBtn.textContent = originalText;
                }
            }

            async function editBookMetadata(bookId) {
                try {
                    const response = await fetch(`/api/books/${bookId}`);
                    const book = await response.json();

                    if (book.error) {
                        showStatus("è¼‰å…¥æ›¸ç±è³‡è¨Šå¤±æ•—: " + book.error, "error");
                        return;
                    }

                    // Populate form with existing book data
                    document.getElementById("metadataBookName").value =
                        book.book_name_simplified || "";
                    document.getElementById(
                        "metadataBookNameTraditional"
                    ).value = book.book_name_traditional || "";
                    document.getElementById("metadataAuthor").value =
                        book.author || "";
                    document.getElementById("metadataCategory").value =
                        book.category || "";
                    document.getElementById("metadataTags").value = (
                        book.tags || []
                    ).join(", ");
                    document.getElementById("metadataDescription").value =
                        book.description || "";
                    document.getElementById("metadataSourceUrl").value =
                        book.source_url || "";

                    // Store book ID for update
                    pendingDownloadData = { bookId, isEdit: true };

                    // Update modal title and button
                    const modalTitle = document.querySelector(
                        "#bookMetadataModal .progress-header h3"
                    );
                    const confirmButton = document.querySelector(
                        '#bookMetadataModal button[onclick="confirmBookMetadata()"]'
                    );
                    modalTitle.textContent = "ç·¨è¼¯æ›¸ç±è³‡è¨Š";
                    confirmButton.textContent = "ç¢ºèªæ›´æ–°";

                    // Show modal
                    document
                        .getElementById("bookMetadataModal")
                        .classList.add("active");
                } catch (error) {
                    console.error("Error loading book:", error);
                    showStatus(
                        "è¼‰å…¥æ›¸ç±è³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message,
                        "error"
                    );
                }
            }

            async function searchMissingChapters(bookId) {
                try {
                    // Get book info for display
                    const bookResponse = await fetch(`/api/books/${bookId}`);
                    const book = await bookResponse.json();

                    if (book.error) {
                        showStatus("è¼‰å…¥æ›¸ç±è³‡è¨Šå¤±æ•—: " + book.error, "error");
                        return;
                    }

                    const bookName = book.book_name_traditional || book.book_name_simplified || `æ›¸ç± ID ${bookId}`;
                    
                    // Add to queue instead of blocking
                    addMissingChapterSearchToQueue(bookId, bookName);
                } catch (error) {
                    console.error("Error adding missing chapter search to queue:", error);
                    showStatus("åŠ å…¥ä½‡åˆ—æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            function showMissingChaptersModal(bookId, missingData, searchData) {
                const modal = document.getElementById("missingChaptersModal");
                const content = document.getElementById(
                    "missingChaptersContent"
                );

                let html = `
                <div style="margin-bottom: 20px;">
                    <h4>ç¼ºå¤±ç« ç¯€åˆ†æ</h4>
                    <p>ç¸½ç« ç¯€ç¯„åœ: ç¬¬${missingData.minChapter}ç«  ~ ç¬¬${missingData.maxChapter}ç« </p>
                    <p>å·²ä¸‹è¼‰: ${missingData.totalChapters} ç« </p>
                    <p>ç¼ºå¤±: ${missingData.missingChapters.length} ç« </p>
                </div>
            `;

                if (searchData.foundChapters.length === 0) {
                    html += `
                    <div style="padding: 20px; background: #fff3cd; border-radius: 4px; margin-bottom: 20px;">
                        <p>æœªæ‰¾åˆ°ä»»ä½•ç¼ºå¤±ç« ç¯€çš„çµæœã€‚</p>
                        <p>ç¼ºå¤±çš„ç« ç¯€: ${missingData.missingChapters.join(
                            ", "
                        )}</p>
                    </div>
                `;
                } else {
                    html += `
                    <div style="margin-bottom: 20px;">
                        <h4>æ‰¾åˆ° ${searchData.foundChapters.length} å€‹ç« ç¯€</h4>
                        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                `;

                    const selectedChapters = new Set();
                    searchData.foundChapters.forEach((ch) => {
                        const isMulti = ch.isMultiChapter ? " (å¤šç« ç¯€)" : "";
                        html += `
                        <div style="padding: 10px; border-bottom: 1px solid #eee;">
                            <label style="display: flex; align-items: start; cursor: pointer;">
                                <input type="checkbox" value="${
                                    ch.url
                                }" data-chapter="${ch.chapterNumber}" 
                                    style="margin-right: 10px; margin-top: 3px;" 
                                    onchange="toggleMissingChapter(this, ${
                                        ch.chapterNumber
                                    })">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold;">ç¬¬${
                                        ch.chapterNumber
                                    }ç« ${isMulti}</div>
                                    <div style="color: #666; font-size: 14px; margin-top: 5px;">${
                                        ch.title
                                    }</div>
                                    ${
                                        ch.isMultiChapter
                                            ? `<div style="color: #007bff; font-size: 12px; margin-top: 3px;">åŒ…å«ç« ç¯€: ${
                                                  ch.range ||
                                                  ch.chapters.join(", ")
                                              }</div>`
                                            : ""
                                    }
                                    <div style="color: #999; font-size: 12px; margin-top: 3px;">${
                                        ch.date || ""
                                    }</div>
                                </div>
                            </label>
                        </div>
                    `;
                    });

                    html += `
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeMissingChaptersModal()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
                        <button onclick="downloadMissingChapters(${bookId})" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">ä¸‹è¼‰é¸ä¸­çš„ç« ç¯€</button>
                    </div>
                `;
                }

                content.innerHTML = html;
                window.missingChaptersData = { bookId, searchData };
                modal.classList.add("active");
            }

            function closeMissingChaptersModal() {
                document
                    .getElementById("missingChaptersModal")
                    .classList.remove("active");
                window.missingChaptersData = null;
            }

            function toggleMissingChapter(checkbox, chapterNumber) {
                if (!window.missingChaptersData) return;
                // This is handled by the checkbox state
            }

            async function downloadMissingChapters(bookId) {
                if (!window.missingChaptersData) return;

                const checkboxes = document.querySelectorAll(
                    '#missingChaptersContent input[type="checkbox"]:checked'
                );
                if (checkboxes.length === 0) {
                    showStatus("è«‹è‡³å°‘é¸æ“‡ä¸€å€‹ç« ç¯€", "error");
                    return;
                }

                const chapters = Array.from(checkboxes).map((cb) => {
                    const chapterData =
                        window.missingChaptersData.searchData.foundChapters.find(
                            (ch) => ch.url === cb.value
                        );
                    return {
                        url: cb.value,
                        title: chapterData.title,
                        chapterNum: parseInt(cb.dataset.chapter),
                    };
                });

                closeMissingChaptersModal();

                // Get book name
                const bookResponse = await fetch(`/api/books/${bookId}`);
                const book = await bookResponse.json();

                // Add to background workers instead of blocking
                addDownloadToWorkers(
                    chapters,
                    bookId,
                    book.book_name_simplified,
                    null
                );
            }

            // Background Workers Management
            function addDownloadToWorkers(chapters, bookId, bookName, bookMetadata) {
                showStatus("æ­£åœ¨å•Ÿå‹•ä¸‹è¼‰ä»»å‹™...", "success");

                // Start download in background
                fetch("/api/download/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        chapters,
                        bookId,
                        bookName,
                        bookMetadata,
                    }),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.error) {
                            showStatus("ä¸‹è¼‰å¤±æ•—: " + data.message, "error");
                        } else {
                            // Add to workers list
                            const worker = {
                                id: `download-${data.jobId}`,
                                type: "download",
                                jobId: data.jobId,
                                bookId: data.bookId || bookId,
                                bookName: bookName || "æœªçŸ¥æ›¸ç±",
                                totalChapters: data.totalChapters || chapters.length,
                                completedChapters: 0,
                                failedChapters: 0,
                                status: "processing",
                                startTime: new Date().toISOString(),
                            };

                            backgroundWorkers.push(worker);
                            updateWorkersDisplay();
                            startWorkerProgressTracking(worker);
                            showStatus(`ä¸‹è¼‰ä»»å‹™å·²åŠ å…¥èƒŒæ™¯è™•ç† (ID: ${data.jobId})`, "success");
                            
                            // Reload books in background
                            loadBooks().catch((error) => {
                                console.error("Error reloading books:", error);
                            });
                        }
                    })
                    .catch((error) => {
                        console.error("Download error:", error);
                        showStatus("ä¸‹è¼‰æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                    });
            }

            function startWorkerProgressTracking(worker) {
                // Connect to SSE stream for this worker
                const eventSource = new EventSource(
                    `/api/download/${worker.jobId}/stream`
                );

                eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        updateWorkerProgress(worker.id, data);
                    } catch (error) {
                        console.error("Error parsing worker progress data:", error);
                    }
                };

                eventSource.onerror = (error) => {
                    console.error("Worker SSE error:", error);
                    // Don't close, let it reconnect
                };

                workerEventSources.set(worker.id, eventSource);
            }

            function updateWorkerProgress(workerId, data) {
                const worker = backgroundWorkers.find((w) => w.id === workerId);
                if (!worker) return;

                switch (data.type) {
                    case "chapter-complete":
                        worker.completedChapters++;
                        break;
                    case "chapter-error":
                        worker.failedChapters++;
                        break;
                    case "job-complete":
                        worker.status = "completed";
                        worker.completedChapters = data.completed || worker.completedChapters;
                        worker.failedChapters = data.failed || worker.failedChapters;
                        // Close SSE connection
                        const eventSource = workerEventSources.get(workerId);
                        if (eventSource) {
                            eventSource.close();
                            workerEventSources.delete(workerId);
                        }
                        break;
                }

                updateWorkersDisplay();
            }

            function updateWorkersDisplay() {
                const workersList = document.getElementById("workersList");
                if (!workersList) return;

                if (backgroundWorkers.length === 0) {
                    workersList.innerHTML =
                        '<div class="empty-state">æ²’æœ‰èƒŒæ™¯ä»»å‹™</div>';
                    return;
                }

                let html = "";
                backgroundWorkers.forEach((worker) => {
                    const progress =
                        worker.totalChapters > 0
                            ? Math.round(
                                  ((worker.completedChapters + worker.failedChapters) /
                                      worker.totalChapters) *
                                      100
                              )
                            : 0;

                    const statusClass = worker.status;
                    const statusText =
                        worker.status === "pending"
                            ? "ç­‰å¾…ä¸­"
                            : worker.status === "processing"
                            ? "è™•ç†ä¸­"
                            : worker.status === "completed"
                            ? "å·²å®Œæˆ"
                            : "å¤±æ•—";

                    html += `
                        <div class="worker-item">
                            <div class="worker-item-header">
                                <div class="worker-item-title">
                                    ${worker.type === "download" ? "ğŸ“¥" : "ğŸ“¤"} ${
                        worker.bookName
                    }
                                </div>
                                <span class="worker-item-status ${statusClass}">${statusText}</span>
                            </div>
                            <div class="worker-item-progress">
                                <div class="worker-item-progress-bar">
                                    <div class="worker-item-progress-fill" style="width: ${progress}%"></div>
                                </div>
                                <div class="worker-item-info">
                                    <span>ç¸½æ•¸: ${worker.totalChapters}</span>
                                    <span>å·²å®Œæˆ: ${worker.completedChapters}</span>
                                    <span>å¤±æ•—: ${worker.failedChapters}</span>
                                    <span>é€²åº¦: ${progress}%</span>
                                </div>
                            </div>
                            <div class="worker-item-actions">
                                <button class="btn btn-primary" onclick="viewWorkerDetails('${worker.id}')">æŸ¥çœ‹è©³æƒ…</button>
                                ${
                                    worker.status === "processing"
                                        ? ""
                                        : `<button class="btn btn-secondary" onclick="removeWorker('${worker.id}')">ç§»é™¤</button>`
                                }
                            </div>
                        </div>
                    `;
                });

                workersList.innerHTML = html;
            }

            async function refreshWorkers() {
                // Load historical jobs from database
                try {
                    const response = await fetch("/api/download?limit=50");
                    const jobs = await response.json();
                    
                    if (jobs && Array.isArray(jobs)) {
                        // Merge with active workers (prioritize active ones)
                        const activeWorkerIds = new Set(backgroundWorkers.map(w => w.id));
                        const historicalWorkers = jobs
                            .filter(job => !activeWorkerIds.has(`download-${job.id}`))
                            .map(job => ({
                                id: `download-${job.id}`,
                                type: "download",
                                jobId: job.id,
                                bookId: job.book_id,
                                bookName: job.book_name || "æœªçŸ¥æ›¸ç±",
                                totalChapters: job.total_chapters || 0,
                                completedChapters: job.completed_chapters || 0,
                                failedChapters: job.failed_chapters || 0,
                                status: job.status || "unknown",
                                startTime: job.created_at,
                                completedAt: job.completed_at,
                                isHistorical: true,
                            }));
                        
                        // Update existing workers or add new ones
                        backgroundWorkers.forEach((worker) => {
                            if (worker.type === "download" && worker.status === "processing") {
                                const job = jobs.find(j => j.id === worker.jobId);
                                if (job) {
                                    worker.completedChapters = job.completed_chapters || 0;
                                    worker.failedChapters = job.failed_chapters || 0;
                                    if (job.status === "completed" || job.status === "failed") {
                                        worker.status = job.status;
                                        const eventSource = workerEventSources.get(worker.id);
                                        if (eventSource) {
                                            eventSource.close();
                                            workerEventSources.delete(worker.id);
                                        }
                                    }
                                } else {
                                    // Job not found, try to fetch it
                                    fetch(`/api/download/${worker.jobId}`)
                                        .then((response) => response.json())
                                        .then((data) => {
                                            if (data) {
                                                worker.completedChapters = data.completed_chapters || 0;
                                                worker.failedChapters = data.failed_chapters || 0;
                                                if (data.status === "completed" || data.status === "failed") {
                                                    worker.status = data.status;
                                                    const eventSource = workerEventSources.get(worker.id);
                                                    if (eventSource) {
                                                        eventSource.close();
                                                        workerEventSources.delete(worker.id);
                                                    }
                                                }
                                                updateWorkersDisplay();
                                            }
                                        })
                                        .catch((error) => {
                                            console.error("Error refreshing worker:", error);
                                        });
                                }
                            }
                        });
                        
                        // Add historical workers
                        backgroundWorkers.push(...historicalWorkers);
                        updateWorkersDisplay();
                    }
                } catch (error) {
                    console.error("Error loading historical jobs:", error);
                }
            }

            function viewWorkerDetails(workerId) {
                const worker = backgroundWorkers.find((w) => w.id === workerId);
                if (!worker) return;

                if (worker.type === "download") {
                    showDownloadProgress(worker.jobId, worker.totalChapters);
                }
            }

            function removeWorker(workerId) {
                const worker = backgroundWorkers.find((w) => w.id === workerId);
                if (!worker) return;

                // Close SSE connection if exists
                const eventSource = workerEventSources.get(workerId);
                if (eventSource) {
                    eventSource.close();
                    workerEventSources.delete(workerId);
                }

                // Remove from list
                backgroundWorkers = backgroundWorkers.filter((w) => w.id !== workerId);
                updateWorkersDisplay();
            }

            async function retryWorker(workerId) {
                const worker = backgroundWorkers.find((w) => w.id === workerId);
                if (!worker || worker.type !== "download") return;

                try {
                    showStatus("æ­£åœ¨é‡è©¦ä»»å‹™...", "");
                    const response = await fetch(`/api/download/${worker.jobId}/retry`, {
                        method: "POST",
                    });
                    const data = await response.json();

                    if (data.error) {
                        showStatus("é‡è©¦å¤±æ•—: " + data.message, "error");
                    } else {
                        showStatus(`é‡è©¦ä»»å‹™å·²å»ºç«‹ (æ–°ä»»å‹™ ID: ${data.jobId})`, "success");
                        
                        // Add new retry job to workers
                        const newWorker = {
                            id: `download-${data.jobId}`,
                            type: "download",
                            jobId: data.jobId,
                            bookId: worker.bookId,
                            bookName: worker.bookName,
                            totalChapters: data.totalChapters || 0,
                            completedChapters: 0,
                            failedChapters: 0,
                            status: "processing",
                            startTime: new Date().toISOString(),
                        };

                        backgroundWorkers.push(newWorker);
                        updateWorkersDisplay();
                        startWorkerProgressTracking(newWorker);
                    }
                } catch (error) {
                    console.error("Error retrying worker:", error);
                    showStatus("é‡è©¦æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            async function searchDownChapters(bookId) {
                try {
                    showStatus("æ­£åœ¨å‘ä¸‹æœå°‹ç« ç¯€ï¼ˆæœ€å¤š5é ï¼Œç›´åˆ°ç¬¬1ç« ï¼‰...", "");

                    const searchResponse = await fetch(
                        `/api/books/${bookId}/search-down`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        }
                    );

                    const searchData = await searchResponse.json();

                    if (searchData.error) {
                        showStatus("æœå°‹å¤±æ•—: " + searchData.error, "error");
                        return;
                    }

                    if (searchData.foundChapters.length === 0) {
                        showStatus(`æœªæ‰¾åˆ°ä»»ä½•è¼ƒä½ç·¨è™Ÿçš„ç« ç¯€ï¼ˆç•¶å‰æœ€ä½ï¼šç¬¬${searchData.minChapter}ç« ï¼‰`, "success");
                        return;
                    }

                    // Show results in modal
                    showSearchResultsModal(bookId, searchData, "å‘ä¸‹æœå°‹çµæœ", `æ‰¾åˆ° ${searchData.foundChapters.length} å€‹è¼ƒä½ç·¨è™Ÿçš„ç« ç¯€ï¼ˆç•¶å‰æœ€ä½ï¼šç¬¬${searchData.minChapter}ç« ï¼‰`);
                } catch (error) {
                    console.error("Error searching down for chapters:", error);
                    showStatus("æœå°‹æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            async function searchNewChapters(bookId) {
                try {
                    showStatus("æ­£åœ¨æœå°‹æ–°ç« ç¯€ï¼ˆæœ€å¤š3é ï¼‰...", "");

                    const searchResponse = await fetch(
                        `/api/books/${bookId}/search-new`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        }
                    );

                    const searchData = await searchResponse.json();

                    if (searchData.error) {
                        showStatus("æœå°‹å¤±æ•—: " + searchData.error, "error");
                        return;
                    }

                    if (searchData.foundChapters.length === 0) {
                        showStatus(`æœªæ‰¾åˆ°ä»»ä½•æ–°ç« ç¯€ï¼ˆç•¶å‰æœ€é«˜ï¼šç¬¬${searchData.maxChapter}ç« ï¼‰`, "success");
                        return;
                    }

                    // Show results in modal
                    showSearchResultsModal(bookId, searchData, "æœå°‹æ–°ç« ç¯€çµæœ", `æ‰¾åˆ° ${searchData.foundChapters.length} å€‹æ–°ç« ç¯€ï¼ˆç•¶å‰æœ€é«˜ï¼šç¬¬${searchData.maxChapter}ç« ï¼‰`);
                } catch (error) {
                    console.error("Error searching for new chapters:", error);
                    showStatus("æœå°‹æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            function showSearchResultsModal(bookId, searchData, title, description) {
                // Create or reuse modal
                let modal = document.getElementById("searchResultsModal");
                if (!modal) {
                    modal = document.createElement("div");
                    modal.id = "searchResultsModal";
                    modal.className = "modal";
                    modal.innerHTML = `
                        <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
                            <div class="progress-header">
                                <h3 id="searchResultsTitle">${title}</h3>
                                <button class="close-button" onclick="closeSearchResultsModal()">&times;</button>
                            </div>
                            <div id="searchResultsContent" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 100px);"></div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                }

                const content = document.getElementById("searchResultsContent");
                const titleElement = document.getElementById("searchResultsTitle");
                if (titleElement) {
                    titleElement.textContent = title;
                }

                let html = `
                    <div style="margin-bottom: 20px;">
                        <p>${description}</p>
                        <p style="color: #666; font-size: 14px;">
                            å·²æœå°‹ ${searchData.pagesSearched} é 
                            ${searchData.authorSearched ? `ï¼ˆæ›¸åï¼š${searchData.searchKeyword}ï¼Œä½œè€…ï¼š${searchData.authorSearched}ï¼‰` : `ï¼ˆæ›¸åï¼š${searchData.searchKeyword}ï¼‰`}
                        </p>
                    </div>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                `;

                searchData.foundChapters.forEach((ch) => {
                    const isMulti = ch.isMultiChapter ? " (å¤šç« ç¯€)" : "";
                    html += `
                        <div style="padding: 10px; border-bottom: 1px solid #eee;">
                            <label style="display: flex; align-items: start; cursor: pointer;">
                                <input type="checkbox" value="${ch.url}" data-chapter="${ch.chapterNumber}" 
                                    style="margin-right: 10px; margin-top: 3px;" 
                                    checked>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold;">ç¬¬${ch.chapterNumber}ç« ${isMulti}</div>
                                    <div style="color: #666; font-size: 14px; margin-top: 5px;">${ch.title}</div>
                                    ${ch.isMultiChapter
                                        ? `<div style="color: #007bff; font-size: 12px; margin-top: 3px;">åŒ…å«ç« ç¯€: ${ch.range || ch.chapters.join(", ")}</div>`
                                        : ""
                                    }
                                    <div style="color: #999; font-size: 12px; margin-top: 3px;">${ch.date || ""}</div>
                                    <div style="margin-top: 5px;"><a href="${ch.url}" target="_blank" style="color: #007bff; font-size: 12px;">æŸ¥çœ‹åŸæ–‡</a></div>
                                </div>
                            </label>
                        </div>
                    `;
                });

                html += `
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                        <button onclick="closeSearchResultsModal()" class="btn btn-secondary">å–æ¶ˆ</button>
                        <button onclick="downloadSearchResults(${bookId})" class="btn btn-success">ä¸‹è¼‰é¸ä¸­çš„ç« ç¯€</button>
                    </div>
                `;

                content.innerHTML = html;
                window.searchResultsData = { bookId, searchData };
                modal.classList.add("active");
            }

            function closeSearchResultsModal() {
                const modal = document.getElementById("searchResultsModal");
                if (modal) {
                    modal.classList.remove("active");
                }
                window.searchResultsData = null;
            }

            async function downloadSearchResults(bookId) {
                if (!window.searchResultsData) return;

                const checkboxes = document.querySelectorAll(
                    '#searchResultsContent input[type="checkbox"]:checked'
                );
                if (checkboxes.length === 0) {
                    showStatus("è«‹è‡³å°‘é¸æ“‡ä¸€å€‹ç« ç¯€", "error");
                    return;
                }

                const chapters = Array.from(checkboxes).map((cb) => {
                    const chapterData =
                        window.searchResultsData.searchData.foundChapters.find(
                            (ch) => ch.url === cb.value
                        );
                    return {
                        url: cb.value,
                        title: chapterData.title,
                        chapterNum: parseInt(cb.dataset.chapter),
                    };
                });

                closeSearchResultsModal();

                // Get book name
                const bookResponse = await fetch(`/api/books/${bookId}`);
                const book = await bookResponse.json();

                // Add to background workers instead of blocking
                addDownloadToWorkers(
                    chapters,
                    bookId,
                    book.book_name_simplified,
                    null
                );
            }

            function refreshBooks() {
                console.log("Refreshing books...");
                loadBooks()
                    .then(() => {
                        console.log(
                            "Books refreshed, total books:",
                            books.length
                        );
                        showStatus(
                            `å·²é‡æ–°æ•´ç†ï¼Œå…± ${books.length} æœ¬æ›¸ç±`,
                            "success"
                        );
                    })
                    .catch((error) => {
                        console.error("Error refreshing books:", error);
                        showStatus("é‡æ–°æ•´ç†å¤±æ•—: " + error.message, "error");
                    });
            }

            let statusHideTimeout = null;

            function showStatus(message, type = "") {
                const statusDiv = document.getElementById("status");
                if (!statusDiv) {
                    console.warn(
                        "Status element not found when showing status",
                        { message, type }
                    );
                    console.error("Status message:", message, "Type:", type);
                    return;
                }

                // Clear any existing timeout
                if (statusHideTimeout) {
                    clearTimeout(statusHideTimeout);
                    statusHideTimeout = null;
                }

                statusDiv.classList.remove("d-none");
                // Set Bootstrap alert classes
                statusDiv.className = "alert";
                if (type === "error") {
                    statusDiv.classList.add("alert-danger");
                } else if (type === "success") {
                    statusDiv.classList.add("alert-success");
                } else {
                    statusDiv.classList.add("alert-info");
                }
                statusDiv.textContent = message;

                // Only auto-hide success messages, not errors
                if (type === "success") {
                    statusHideTimeout = setTimeout(() => {
                        if (statusDiv) {
                            statusDiv.classList.add("d-none");
                        }
                        statusHideTimeout = null;
                    }, 5000);
                }
                // Errors stay visible until manually dismissed or new message shown
            }

            // Download Progress
            let progressEventSource = null;

            function showDownloadProgress(jobId, totalChapters) {
                const modal = document.getElementById("progressModal");
                const progressBar = document.getElementById("progressBar");
                const progressLogs = document.getElementById("progressLogs");
                const progressCompleted =
                    document.getElementById("progressCompleted");
                const progressTotal = document.getElementById("progressTotal");
                const progressFailed =
                    document.getElementById("progressFailed");

                modal.classList.add("active");
                progressBar.style.width = "0%";
                progressBar.textContent = "0%";
                progressLogs.innerHTML = "";
                progressCompleted.textContent = "0";
                progressTotal.textContent = totalChapters || "0";
                progressFailed.textContent = "0";

                // Close any existing connection
                if (progressEventSource) {
                    progressEventSource.close();
                }

                // Connect to SSE stream
                progressEventSource = new EventSource(
                    `/api/download/${jobId}/stream`
                );

                progressEventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleProgressUpdate(
                            data,
                            progressBar,
                            progressLogs,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                    } catch (error) {
                        console.error("Error parsing progress data:", error);
                    }
                };

                progressEventSource.onerror = (error) => {
                    console.error("SSE error:", error);
                    addProgressLog(
                        progressLogs,
                        "é€£æ¥éŒ¯èª¤ï¼Œè«‹åˆ·æ–°é é¢æŸ¥çœ‹ç‹€æ…‹",
                        "error"
                    );
                };
            }

            function handleProgressUpdate(
                data,
                progressBar,
                progressLogs,
                progressCompleted,
                progressTotal,
                progressFailed,
                totalChapters
            ) {
                switch (data.type) {
                    case "connected":
                        addProgressLog(
                            progressLogs,
                            "å·²é€£æ¥åˆ°ä¸‹è¼‰æœå‹™",
                            "success"
                        );
                        break;
                    case "job-start":
                        addProgressLog(progressLogs, data.message, "success");
                        break;
                    case "chapter-start":
                        addProgressLog(progressLogs, data.message);
                        break;
                    case "chapter-complete":
                        addProgressLog(progressLogs, data.message, "success");
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        break;
                    case "chapter-skipped":
                        addProgressLog(progressLogs, data.message);
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        break;
                    case "chapter-error":
                        addProgressLog(progressLogs, data.message, "error");
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        break;
                    case "job-complete":
                        addProgressLog(progressLogs, data.message, "success");
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        if (progressEventSource) {
                            progressEventSource.close();
                            progressEventSource = null;
                        }
                        // Auto-close after 3 seconds
                        setTimeout(() => {
                            closeProgressModal();
                            loadBooks();
                        }, 3000);
                        break;
                    case "job-error":
                        addProgressLog(progressLogs, data.message, "error");
                        if (progressEventSource) {
                            progressEventSource.close();
                            progressEventSource = null;
                        }
                        break;
                }
            }

            function addProgressLog(logsContainer, message, type = "") {
                const logItem = document.createElement("div");
                logItem.className = `progress-log-item ${type}`;
                logItem.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logsContainer.appendChild(logItem);
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }

            function updateProgress(
                progressBar,
                progressCompleted,
                progressTotal,
                progressFailed,
                totalChapters
            ) {
                // Fetch current status from API
                const jobId = progressEventSource
                    ? progressEventSource.url.match(
                          /\/download\/(\d+)\/stream/
                      )[1]
                    : null;
                if (jobId) {
                    fetch(`/api/download/${jobId}/status`)
                        .then((res) => res.json())
                        .then((job) => {
                            const completed = job.completed_chapters || 0;
                            const failed = job.failed_chapters || 0;
                            const total =
                                job.total_chapters || totalChapters || 0;
                            const percentage =
                                total > 0
                                    ? Math.round((completed / total) * 100)
                                    : 0;

                            progressBar.style.width = `${percentage}%`;
                            progressBar.textContent = `${percentage}%`;
                            progressCompleted.textContent = completed;
                            progressTotal.textContent = total;
                            progressFailed.textContent = failed;
                        })
                        .catch((error) =>
                            console.error("Error fetching progress:", error)
                        );
                }
            }

            function closeProgressModal() {
                const modal = document.getElementById("progressModal");
                modal.classList.remove("active");
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
            }

            // Upload Management
            let uploadedFiles = [];
            let currentFileAnalysis = null;
            let pendingFileForProcessing = null;

            function setupUploadArea() {
                const uploadArea = document.getElementById("uploadArea");
                const fileInput = document.getElementById("fileInput");
                const uploadTab = document.getElementById("uploadTab");

                if (!uploadArea) {
                    console.error("Upload area not found");
                    return;
                }

                let dragCounter = 0; // Track drag enter/leave to handle child elements

                // Prevent default drag behaviors on the entire page
                document.addEventListener("dragover", (e) => {
                    // Only prevent default when dragging files
                    if (
                        e.dataTransfer &&
                        e.dataTransfer.types.includes("Files")
                    ) {
                        e.preventDefault();
                    }
                });

                document.addEventListener("drop", (e) => {
                    // Only prevent default when dragging files
                    if (
                        e.dataTransfer &&
                        e.dataTransfer.types.includes("Files")
                    ) {
                        e.preventDefault();
                    }
                });

                // Drag and drop handlers for upload area
                uploadArea.addEventListener("dragenter", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragCounter++;
                    uploadArea.classList.add("dragover");
                });

                uploadArea.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Set dropEffect to show it's a valid drop target
                    e.dataTransfer.dropEffect = "copy";
                });

                uploadArea.addEventListener("dragleave", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragCounter--;
                    // Only remove dragover if we've actually left the upload area
                    if (dragCounter === 0) {
                        uploadArea.classList.remove("dragover");
                    }
                });

                uploadArea.addEventListener("drop", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragCounter = 0;
                    uploadArea.classList.remove("dragover");

                    const files = Array.from(e.dataTransfer.files);
                    if (files.length > 0) {
                        handleFiles(files);
                    }
                });

                // Also allow drag and drop on the entire upload tab area
                if (uploadTab) {
                    uploadTab.addEventListener("dragenter", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (!uploadArea.contains(e.target)) {
                                uploadArea.classList.add("dragover");
                            }
                        }
                    });

                    uploadTab.addEventListener("dragover", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.dataTransfer.dropEffect = "copy";
                            if (!uploadArea.contains(e.target)) {
                                uploadArea.classList.add("dragover");
                            }
                        }
                    });

                    uploadTab.addEventListener("dragleave", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            // Only remove if leaving the tab entirely
                            if (!uploadTab.contains(e.relatedTarget)) {
                                uploadArea.classList.remove("dragover");
                            }
                        }
                    });

                    uploadTab.addEventListener("drop", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            uploadArea.classList.remove("dragover");

                            const files = Array.from(e.dataTransfer.files);
                            if (files.length > 0) {
                                handleFiles(files);
                            }
                        }
                    });
                }
            }

            function handleFileSelect(event) {
                const files = Array.from(event.target.files);
                handleFiles(files);
            }

            async function handleFiles(files) {
                const validFiles = files.filter((file) => {
                    const ext = file.name.split(".").pop().toLowerCase();
                    return ["txt", "html", "md"].includes(ext);
                });

                if (validFiles.length === 0) {
                    showUploadStatus(
                        "è«‹é¸æ“‡æœ‰æ•ˆçš„æª”æ¡ˆæ ¼å¼ (.txt, .html, .md)",
                        "error"
                    );
                    return;
                }

                showUploadStatus(`æ­£åœ¨ä¸Šå‚³ ${validFiles.length} å€‹æª”æ¡ˆ...`, "");

                for (const file of validFiles) {
                    try {
                        const formData = new FormData();
                        formData.append("file", file);

                        const response = await fetch("/api/upload", {
                            method: "POST",
                            body: formData,
                        });

                        const data = await response.json();
                        if (data.error) {
                            showUploadStatus(
                                `ä¸Šå‚³ ${file.name} å¤±æ•—: ${data.message}`,
                                "error"
                            );
                        } else {
                            uploadedFiles.push({
                                filename: data.filename,
                                originalName: file.name,
                                size: file.size,
                                path: data.path,
                            });
                        }
                    } catch (error) {
                        showUploadStatus(
                            `ä¸Šå‚³ ${file.name} æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`,
                            "error"
                        );
                    }
                }

                if (uploadedFiles.length > 0) {
                    showUploadStatus(
                        `æˆåŠŸä¸Šå‚³ ${uploadedFiles.length} å€‹æª”æ¡ˆ`,
                        "success"
                    );
                    displayUploadedFiles();
                    await loadBooksForUpload();

                    // Automatically analyze the first file to extract book info
                    if (uploadedFiles.length > 0) {
                        await analyzeFirstFileForBookInfo();
                    }
                }
            }

            async function analyzeFirstFileForBookInfo() {
                if (uploadedFiles.length === 0) return;
                
                // Make sure modal is closed first
                const modal = document.getElementById("uploadBookSelectionModal");
                if (modal) {
                    modal.classList.remove("active");
                }

                const firstFile = uploadedFiles[0];
                showUploadStatus("æ­£åœ¨åˆ†æç¬¬ä¸€å€‹æª”æ¡ˆä»¥æå–æ›¸ç±è³‡è¨Š...", "");

                try {
                    const response = await fetch("/api/upload/analyze", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            filename: firstFile.filename,
                            originalName: firstFile.originalName,
                        }),
                    });

                    const data = await response.json();
                    if (data.error) {
                        showUploadStatus(
                            `åˆ†æå¤±æ•—: ${data.message}`,
                            "error"
                        );
                        return;
                    }

                    // Store analysis for all files
                    currentFileAnalysis = {
                        ...data,
                        allFiles: uploadedFiles,
                    };

                    // Show book selection modal with extracted info
                    showBookSelectionModal(data);
                } catch (error) {
                    console.error("Analyze error:", error);
                    showUploadStatus(
                        "åˆ†ææ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message,
                        "error"
                    );
                }
            }

            function showBookSelectionModal(analysis) {
                const modal = document.getElementById("uploadBookSelectionModal");
                if (!modal) {
                    console.error("Upload book selection modal not found");
                    return;
                }

                // Populate book metadata form from analysis
                const bookNameInput = document.getElementById("uploadNewBookName");
                if (bookNameInput && analysis.bookNameSimplified) {
                    bookNameInput.value = analysis.bookNameSimplified;
                }

                const authorInput = document.getElementById("uploadNewBookAuthor");
                if (authorInput && analysis.metadata?.author) {
                    authorInput.value = analysis.metadata.author;
                }

                const categoryInput = document.getElementById("uploadNewBookCategory");
                if (categoryInput && analysis.metadata?.category) {
                    categoryInput.value = analysis.metadata.category;
                }

                const descriptionInput = document.getElementById("uploadNewBookDescription");
                if (descriptionInput && analysis.metadata?.description) {
                    descriptionInput.value = analysis.metadata.description;
                }

                const sourceUrlInput = document.getElementById("uploadNewBookSourceUrl");
                if (sourceUrlInput && analysis.metadata?.sourceUrl) {
                    sourceUrlInput.value = analysis.metadata.sourceUrl;
                }

                // Show matched books
                const selector = document.getElementById("uploadBookSelector");
                if (selector && analysis.matchedBooks) {
                    selector.innerHTML = '<option value="new">å»ºç«‹æ–°æ›¸ç±</option>';
                    analysis.matchedBooks.forEach((book) => {
                        const option = document.createElement("option");
                        option.value = book.id;
                        option.textContent =
                            book.book_name_traditional || book.book_name_simplified;
                        selector.appendChild(option);
                    });
                    
                    // Automatically select the first matched book if there is one
                    if (analysis.matchedBooks.length > 0) {
                        selector.value = analysis.matchedBooks[0].id;
                    }
                }

                // Show metadata form if creating new book
                toggleUploadBookMetadataForm();

                // Show file count
                const fileCountInfo = document.getElementById("uploadFileCountInfo");
                if (fileCountInfo) {
                    fileCountInfo.textContent = `å…± ${uploadedFiles.length} å€‹æª”æ¡ˆå°‡è¢«è™•ç†`;
                }

                // Show chapter preview
                const chapterPreview = document.getElementById("uploadChapterPreview");
                if (chapterPreview && analysis.chapters) {
                    const previewText = analysis.chapters
                        .slice(0, 10)
                        .map((ch, idx) => `${idx + 1}. ${ch.titleTraditional || ch.title}`)
                        .join("\n");
                    chapterPreview.textContent = previewText || "ç„¡ç« ç¯€è³‡è¨Š";
                    if (analysis.totalChapters > 10) {
                        chapterPreview.textContent += `\n... é‚„æœ‰ ${analysis.totalChapters - 10} å€‹ç« ç¯€`;
                    }
                }

                modal.classList.add("active");
            }

            function displayUploadedFiles() {
                const uploadedFilesDiv =
                    document.getElementById("uploadedFiles");
                const uploadedFilesList =
                    document.getElementById("uploadedFilesList");

                if (uploadedFiles.length === 0) {
                    uploadedFilesDiv.style.display = "none";
                    return;
                }

                uploadedFilesDiv.style.display = "block";

                let html = "";
                uploadedFiles.forEach((file, index) => {
                    const sizeKB = (file.size / 1024).toFixed(2);
                    html += `
                    <div class="uploaded-file-item">
                        <div class="uploaded-file-info">
                            <div class="uploaded-file-name">${file.originalName}</div>
                            <div class="uploaded-file-size">${sizeKB} KB</div>
                        </div>
                        <div class="uploaded-file-actions">
                            <button class="btn btn-success" onclick="extractAndCreateBookFromFile(${index})" title="å¾æª”æ¡ˆæå–æ›¸ç±è³‡è¨Šä¸¦å»ºç«‹æ–°æ›¸">æå–ä¸¦å»ºç«‹</button>
                            <button class="btn btn-secondary" onclick="removeUploadedFile(${index})">ç§»é™¤</button>
                        </div>
                    </div>
                `;
                });

                uploadedFilesList.innerHTML = html;
                const uploadProcessSection = document.getElementById("uploadProcessSection");
                if (uploadProcessSection) {
                    uploadProcessSection.style.display = "block";
                }
            }

            function removeUploadedFile(index) {
                uploadedFiles.splice(index, 1);
                displayUploadedFiles();
            }

            async function extractAndCreateBookFromFile(index) {
                if (index < 0 || index >= uploadedFiles.length) {
                    showUploadStatus("ç„¡æ•ˆçš„æª”æ¡ˆç´¢å¼•", "error");
                    return;
                }

                const file = uploadedFiles[index];
                showUploadStatus(`æ­£åœ¨å¾ ${file.originalName} æå–æ›¸ç±è³‡è¨Šä¸¦å»ºç«‹æ–°æ›¸...`, "");

                try {
                    const response = await fetch("/api/upload/extract-and-create", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            filename: file.filename,
                            originalName: file.originalName,
                        }),
                    });

                    const data = await response.json();
                    if (data.error) {
                        showUploadStatus("æå–ä¸¦å»ºç«‹æ›¸ç±å¤±æ•—: " + data.message, "error");
                    } else {
                        // Check if any chapters were actually processed
                        if (data.chaptersInserted === 0 && data.chaptersUpdated === 0) {
                            if (data.totalChapters === 0) {
                                showUploadStatus(
                                    `è­¦å‘Šï¼šæª”æ¡ˆä¸­æ²’æœ‰æ‰¾åˆ°ç« ç¯€ã€‚æ›¸ç±ã€Œ${data.bookName}ã€å·²${data.isNewBook ? 'å»ºç«‹' : 'å­˜åœ¨'}ï¼Œä½†æ²’æœ‰ç« ç¯€è¢«æ·»åŠ ã€‚`,
                                    "error"
                                );
                            } else if (data.chaptersErrored > 0) {
                                showUploadStatus(
                                    `éŒ¯èª¤ï¼šæ‰€æœ‰ç« ç¯€è™•ç†å¤±æ•—ï¼ˆ${data.chaptersErrored}/${data.totalChapters}ï¼‰ã€‚è«‹æª¢æŸ¥ä¼ºæœå™¨æ—¥èªŒã€‚`,
                                    "error"
                                );
                            } else {
                                showUploadStatus(
                                    `è­¦å‘Šï¼šæ²’æœ‰ç« ç¯€è¢«æ·»åŠ æˆ–æ›´æ–°ã€‚ç¸½ç« ç¯€æ•¸ï¼š${data.totalChapters}`,
                                    "error"
                                );
                            }
                        } else {
                            if (data.isMerged) {
                                showUploadStatus(
                                    `å·²åˆä½µåˆ°ç¾æœ‰æ›¸ç±ã€Œ${data.bookName}ã€ï¼å·²è™•ç† ${data.chaptersInserted} å€‹æ–°ç« ç¯€ï¼Œ${data.chaptersUpdated} å€‹ç« ç¯€å·²æ›´æ–°${data.chaptersErrored > 0 ? `ï¼Œ${data.chaptersErrored} å€‹å¤±æ•—` : ''}`,
                                    data.chaptersErrored > 0 ? "error" : "success"
                                );
                            } else {
                                showUploadStatus(
                                    `æˆåŠŸå»ºç«‹æ›¸ç±ã€Œ${data.bookName}ã€ï¼å·²è™•ç† ${data.chaptersInserted} å€‹ç« ç¯€${data.chaptersErrored > 0 ? `ï¼Œ${data.chaptersErrored} å€‹å¤±æ•—` : ''}`,
                                    data.chaptersErrored > 0 ? "error" : "success"
                                );
                            }
                            
                            // Remove the processed file from the list
                            uploadedFiles.splice(index, 1);
                            displayUploadedFiles();
                            
                            // Reload books list
                            await loadBooks();
                            
                            // Switch to books tab after a delay to show the book
                            setTimeout(() => {
                                switchTab("books");
                            }, 2000);
                        }
                    }
                } catch (error) {
                    console.error("Error extracting and creating book:", error);
                    showUploadStatus("æå–ä¸¦å»ºç«‹æ›¸ç±æ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message, "error");
                }
            }

            async function loadBooksForUpload() {
                try {
                    const response = await fetch("/api/books");
                    allBooks = await response.json();
                    updateUploadBookSelector();
                } catch (error) {
                    console.error("Error loading books:", error);
                }
            }

            function updateUploadBookSelector() {
                const selector = document.getElementById("uploadBookSelector");
                selector.innerHTML = '<option value="new">å»ºç«‹æ–°æ›¸ç±</option>';
                allBooks.forEach((book) => {
                    const option = document.createElement("option");
                    option.value = book.id;
                    option.textContent =
                        book.book_name_traditional || book.book_name_simplified;
                    selector.appendChild(option);
                });
            }

            function toggleUploadBookMetadataForm() {
                const selector = document.getElementById("uploadBookSelector");
                const newBookForm = document.getElementById("uploadNewBookForm");
                if (newBookForm) {
                    newBookForm.style.display =
                        selector.value === "new" ? "block" : "none";
                }
            }

            function closeUploadBookSelectionModal() {
                const modal = document.getElementById("uploadBookSelectionModal");
                if (modal) {
                    modal.classList.remove("active");
                }
                // Clear uploaded files and analysis when modal is closed without processing
                uploadedFiles = [];
                currentFileAnalysis = null;
                displayUploadedFiles();
            }

            function showUploadStatus(message, type = "") {
                const statusDiv = document.getElementById("uploadStatus");
                statusDiv.style.display = "block";
                statusDiv.className = "status " + type;
                statusDiv.textContent = message;
                if (type === "success" || type === "error") {
                    setTimeout(() => {
                        statusDiv.style.display = "none";
                    }, 5000);
                }
            }

            async function processUploadedFiles() {
                if (uploadedFiles.length === 0) {
                    showUploadStatus("æ²’æœ‰å¯è™•ç†çš„æª”æ¡ˆ", "error");
                    return;
                }

                const bookSelector =
                    document.getElementById("uploadBookSelector");
                
                let bookId =
                    bookSelector.value === "new"
                        ? null
                        : parseInt(bookSelector.value);
                let bookName = null;
                let bookMetadata = null;

                if (bookSelector.value === "new") {
                    // Get form data for new book
                    let newBookName = document
                        .getElementById("uploadNewBookName")
                        .value.trim();
                    
                    if (!newBookName) {
                        showUploadStatus("è«‹è¼¸å…¥æ–°æ›¸ç±åç¨±", "error");
                        return;
                    }
                    
                    // Normalize all form inputs: convert full-width to half-width
                    bookName = normalizeToHalfWidth(newBookName);
                    
                    // Get metadata from form and normalize
                    bookMetadata = {
                        author: document.getElementById("uploadNewBookAuthor")?.value.trim() 
                            ? normalizeToHalfWidth(document.getElementById("uploadNewBookAuthor").value.trim())
                            : null,
                        category: document.getElementById("uploadNewBookCategory")?.value.trim()
                            ? normalizeToHalfWidth(document.getElementById("uploadNewBookCategory").value.trim())
                            : null,
                        description: document.getElementById("uploadNewBookDescription")?.value.trim()
                            ? normalizeToHalfWidth(document.getElementById("uploadNewBookDescription").value.trim())
                            : null,
                        sourceUrl: document.getElementById("uploadNewBookSourceUrl")?.value.trim()
                            ? normalizeToHalfWidth(document.getElementById("uploadNewBookSourceUrl").value.trim())
                            : null,
                    };
                } else {
                    const selectedBook = allBooks.find((b) => b.id === bookId);
                    bookName = selectedBook
                        ? selectedBook.book_name_simplified
                        : null;
                }

                // Close modal
                const modal = document.getElementById("uploadBookSelectionModal");
                if (modal) {
                    modal.classList.remove("active");
                }

                showUploadStatus(`æ­£åœ¨è™•ç† ${uploadedFiles.length} å€‹æª”æ¡ˆåˆ°åŒä¸€æœ¬æ›¸ç±...`, "");

                try {
                    let finalBookId = bookId;
                    let processedCount = 0;
                    let errorCount = 0;

                    // Process all files into the same book
                    for (let i = 0; i < uploadedFiles.length; i++) {
                        const file = uploadedFiles[i];
                        try {
                            const requestBody = {
                                filename: file.filename,
                                originalName: file.originalName,
                                bookId: finalBookId, // Use the same bookId for all files
                                bookName: bookName,
                            };
                            
                            // Include metadata only for the first file when creating new book
                            if (i === 0 && !finalBookId && bookMetadata) {
                                requestBody.bookMetadata = bookMetadata;
                            }
                            
                            const response = await fetch("/api/upload/process", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify(requestBody),
                            });

                            const data = await response.json();
                            if (data.error) {
                                errorCount++;
                                showUploadStatus(
                                    `è™•ç† ${file.originalName} å¤±æ•—: ${data.message}`,
                                    "error"
                                );
                            } else {
                                processedCount++;
                                // Update bookId after first file creates the book
                                if (!finalBookId && data.bookId) {
                                    finalBookId = data.bookId;
                                }
                                showUploadStatus(
                                    `å·²è™•ç† ${processedCount}/${uploadedFiles.length} å€‹æª”æ¡ˆ...`,
                                    ""
                                );
                            }
                        } catch (error) {
                            errorCount++;
                            console.error(`Error processing ${file.originalName}:`, error);
                        }
                    }

                    if (processedCount > 0) {
                        showUploadStatus(
                            `æˆåŠŸè™•ç† ${processedCount} å€‹æª”æ¡ˆ${errorCount > 0 ? `ï¼Œ${errorCount} å€‹å¤±æ•—` : ""}`,
                            "success"
                        );
                    } else {
                        showUploadStatus("æ‰€æœ‰æª”æ¡ˆè™•ç†å¤±æ•—", "error");
                    }

                    uploadedFiles = [];
                    displayUploadedFiles();
                    currentFileAnalysis = null;
                    await loadBooks();

                    // Switch to books tab to see the result
                    setTimeout(() => {
                        switchTab("books");
                    }, 2000);
                } catch (error) {
                    console.error("Process error:", error);
                    showUploadStatus(
                        "è™•ç†æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: " + error.message,
                        "error"
                    );
                }
            }

            // Bot Status Management
            let botStatusEventSource = null;
            let botOperations = [];

            function formatDuration(startTime) {
                if (!startTime) return "";
                const start = new Date(startTime);
                const now = new Date();
                const diff = Math.floor((now - start) / 1000);
                const minutes = Math.floor(diff / 60);
                const seconds = diff % 60;
                if (minutes > 0) {
                    return `${minutes}åˆ†${seconds}ç§’`;
                }
                return `${seconds}ç§’`;
            }

            function formatOperationType(type) {
                const types = {
                    search: "æœå°‹",
                    download: "ä¸‹è¼‰",
                    upload: "ä¸Šå‚³",
                    export: "åŒ¯å‡º",
                };
                return types[type] || type;
            }

            function formatOperationStatus(status) {
                const statuses = {
                    active: "é€²è¡Œä¸­",
                    completed: "å·²å®Œæˆ",
                    failed: "å¤±æ•—",
                };
                return statuses[status] || status;
            }

            async function loadBotStatus() {
                try {
                    const response = await fetch("/api/bot-status/operations");
                    const data = await response.json();

                    if (data.success) {
                        botOperations = data.operations || [];
                        updateBotStatusIndicator(data.isActive);
                        updateBotStatusSummary(data.summary);
                        displayOperations(botOperations);
                    }
                } catch (error) {
                    console.error("Error loading bot status:", error);
                }
            }

            function updateBotStatusIndicator(isActive) {
                const indicator = document.getElementById("botStatusIndicator");
                if (isActive) {
                    indicator.textContent = "é‹ä½œä¸­";
                    indicator.classList.add("active");
                } else {
                    indicator.textContent = "é–’ç½®";
                    indicator.classList.remove("active");
                }
            }

            function updateBotStatusSummary(summary) {
                document.getElementById("summaryTotal").textContent =
                    summary.total || 0;
                document.getElementById("summaryActive").textContent =
                    summary.active || 0;

                let completed = 0;
                let failed = 0;
                Object.values(summary.byType || {}).forEach((type) => {
                    completed += type.completed || 0;
                    failed += type.failed || 0;
                });

                document.getElementById("summaryCompleted").textContent =
                    completed;
                document.getElementById("summaryFailed").textContent = failed;
            }

            function displayOperations(operations) {
                const operationsList =
                    document.getElementById("operationsList");

                if (operations.length === 0) {
                    operationsList.innerHTML =
                        '<div class="empty-operations">ç›®å‰æ²’æœ‰é€²è¡Œä¸­çš„æ“ä½œ</div>';
                    return;
                }

                // Sort operations: active first, then by start time
                const sorted = [...operations].sort((a, b) => {
                    if (a.status === "active" && b.status !== "active")
                        return -1;
                    if (a.status !== "active" && b.status === "active")
                        return 1;
                    return new Date(b.startTime) - new Date(a.startTime);
                });

                let html = "";
                sorted.forEach((op) => {
                    const statusClass = op.status || "active";
                    const progress = op.progress || 0;
                    const progressClass =
                        op.status === "completed"
                            ? "completed"
                            : op.status === "failed"
                            ? "failed"
                            : "";

                    let details = "";
                    if (op.type === "search") {
                        details = `
                        <div>é—œéµå­—: ${op.keyword || "N/A"}</div>
                        <div>é æ•¸: ${op.pages || "N/A"}</div>
                        ${
                            op.totalResults !== undefined
                                ? `<div>çµæœæ•¸: ${op.totalResults}</div>`
                                : ""
                        }
                    `;
                    } else if (op.type === "download") {
                        details = `
                        <div>æ›¸ç±: ${op.bookName || "N/A"}</div>
                        <div>ç¸½ç« ç¯€: ${op.totalChapters || 0}</div>
                        <div>å·²å®Œæˆ: ${op.completedChapters || 0}</div>
                        ${
                            op.failedChapters > 0
                                ? `<div style="color: #dc3545;">å¤±æ•—: ${op.failedChapters}</div>`
                                : ""
                        }
                    `;
                    } else if (op.type === "upload") {
                        details = `
                        <div>æª”æ¡ˆ: ${op.filename || "N/A"}</div>
                        ${op.bookName ? `<div>æ›¸ç±: ${op.bookName}</div>` : ""}
                        ${
                            op.totalChapters !== undefined
                                ? `<div>ç¸½ç« ç¯€: ${op.totalChapters || 0}</div>`
                                : ""
                        }
                        ${
                            op.completedChapters !== undefined
                                ? `<div>å·²å®Œæˆ: ${
                                      op.completedChapters || 0
                                  }</div>`
                                : ""
                        }
                        ${
                            op.chaptersInserted !== undefined
                                ? `<div>æ’å…¥: ${op.chaptersInserted || 0}</div>`
                                : ""
                        }
                        ${
                            op.chaptersUpdated !== undefined
                                ? `<div>æ›´æ–°: ${op.chaptersUpdated || 0}</div>`
                                : ""
                        }
                        ${
                            op.failedChapters > 0 || op.chaptersErrored > 0
                                ? `<div style="color: #dc3545;">å¤±æ•—: ${
                                      op.failedChapters ||
                                      op.chaptersErrored ||
                                      0
                                  }</div>`
                                : ""
                        }
                    `;
                    } else if (op.type === "export") {
                        details = `
                        <div>æ›¸ç± ID: ${op.bookId || "N/A"}</div>
                    `;
                    }

                    if (op.error) {
                        details += `<div style="color: #dc3545;">éŒ¯èª¤: ${op.error}</div>`;
                    }

                    html += `
                    <div class="operation-card ${statusClass}">
                        <div class="operation-header">
                            <div>
                                <span class="operation-title">${formatOperationType(
                                    op.type
                                )}</span>
                                <span class="operation-type-badge ${op.type}">${
                        op.type
                    }</span>
                            </div>
                            <span class="operation-status ${statusClass}">${formatOperationStatus(
                        op.status
                    )}</span>
                        </div>
                        ${
                            (op.type === "download" || op.type === "upload") &&
                            op.totalChapters > 0
                                ? `
                            <div class="operation-progress">
                                <div class="operation-progress-bar">
                                    <div class="operation-progress-fill ${progressClass}" style="width: ${progress}%;">
                                        ${progress}%
                                    </div>
                                </div>
                            </div>
                        `
                                : ""
                        }
                        <div class="operation-details">
                            ${details}
                        </div>
                        <div class="operation-time">
                            é–‹å§‹æ™‚é–“: ${
                                op.startTime
                                    ? new Date(op.startTime).toLocaleString(
                                          "zh-TW"
                                      )
                                    : "N/A"
                            }
                            ${
                                op.status === "active"
                                    ? ` | åŸ·è¡Œæ™‚é–“: ${formatDuration(
                                          op.startTime
                                      )}`
                                    : ""
                            }
                            ${
                                op.endTime
                                    ? ` | çµæŸæ™‚é–“: ${new Date(
                                          op.endTime
                                      ).toLocaleString("zh-TW")}`
                                    : ""
                            }
                        </div>
                    </div>
                `;
                });

                operationsList.innerHTML = html;
            }

            function refreshBotStatus() {
                loadBotStatus();
            }

            // Chunk tab functions
            async function refreshChunks() {
                try {
                    const response = await fetch("/api/chunks/books");
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const data = await response.json();
                    displayChunkBooks(data);
                } catch (error) {
                    console.error("Error loading chunk books:", error);
                    alert("è¼‰å…¥åˆ†å¡Šæ›¸ç±å¤±æ•—ï¼š" + error.message);
                }
            }

            function displayChunkBooks(data) {
                const waitingList = document.getElementById("waitingBooksList");
                const readyList = document.getElementById("readyBooksList");
                const availableList = document.getElementById("availableBooksList");

                // Display waiting books
                if (data.waiting && data.waiting.length > 0) {
                    waitingList.innerHTML = data.waiting.map(book => `
                        <div class="list-group-item">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h5 class="mb-1">${book.book_name_traditional || book.book_name_simplified}</h5>
                                    <p class="mb-1 text-muted">
                                        ç‹€æ…‹: ${book.chunkStatus === 'queued' ? 'æ’éšŠä¸­' : 'è™•ç†ä¸­'} | 
                                        ç« ç¯€æ•¸: ${book.totalChapters}
                                    </p>
                                </div>
                                <span class="badge bg-warning">${book.chunkStatus === 'queued' ? 'æ’éšŠä¸­' : 'è™•ç†ä¸­'}</span>
                            </div>
                        </div>
                    `).join('');
                } else {
                    waitingList.innerHTML = '<div class="list-group-item text-muted">ç›®å‰æ²’æœ‰ç­‰å¾…è™•ç†çš„æ›¸ç±</div>';
                }

                // Display ready books
                if (data.ready && data.ready.length > 0) {
                    readyList.innerHTML = data.ready.map(book => `
                        <div class="list-group-item">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h5 class="mb-1">${book.book_name_traditional || book.book_name_simplified}</h5>
                                    <p class="mb-1 text-muted">
                                        ç« ç¯€æ•¸: ${book.totalChapters}
                                    </p>
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn btn-primary btn-sm" onclick="showChunkPreview(${book.id})">
                                        é è¦½åˆ†å¡Š
                                    </button>
                                    <button class="btn btn-warning btn-sm" onclick="rebuildChunks(${book.id})">
                                        é‡å»ºåˆ†å¡Š
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    readyList.innerHTML = '<div class="list-group-item text-muted">ç›®å‰æ²’æœ‰å¯é è¦½çš„æ›¸ç±</div>';
                }

                // Display available books
                if (data.available && data.available.length > 0) {
                    availableList.innerHTML = data.available.map(book => `
                        <div class="list-group-item">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h5 class="mb-1">${book.book_name_traditional || book.book_name_simplified}</h5>
                                    <p class="mb-1 text-muted">
                                        ç« ç¯€æ•¸: ${book.totalChapters}
                                    </p>
                                </div>
                                <div>
                                    <button class="btn btn-success btn-sm" onclick="generateChunks(${book.id})">
                                        ç”Ÿæˆåˆ†å¡Š
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('');
                } else {
                    availableList.innerHTML = '<div class="list-group-item text-muted">ç›®å‰æ²’æœ‰å¯ç”Ÿæˆåˆ†å¡Šçš„æ›¸ç±</div>';
                }
            }

            async function generateChunks(bookId) {
                try {
                    const chunkSize = parseInt(document.getElementById("chunkSizeInput").value) || 1000;
                    const response = await fetch(`/api/chunks/books/${bookId}/generate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ chunkSize }),
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    alert("åˆ†å¡Šç”Ÿæˆå·²é–‹å§‹ï¼Œè«‹ç¨å€™...");
                    refreshChunks();
                } catch (error) {
                    console.error("Error generating chunks:", error);
                    alert("ç”Ÿæˆåˆ†å¡Šå¤±æ•—ï¼š" + error.message);
                }
            }

            async function rebuildChunks(bookId) {
                if (!confirm("ç¢ºå®šè¦é‡å»ºåˆ†å¡Šå—ï¼Ÿé€™å°‡åˆªé™¤ç¾æœ‰çš„åˆ†å¡Šä¸¦ä½¿ç”¨ç•¶å‰è¨­å®šé‡æ–°ç”Ÿæˆã€‚")) {
                    return;
                }

                try {
                    const chunkSize = parseInt(document.getElementById("chunkSizeInput").value) || 1000;
                    const response = await fetch(`/api/chunks/books/${bookId}/generate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ chunkSize }),
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    alert("åˆ†å¡Šé‡å»ºå·²é–‹å§‹ï¼Œè«‹ç¨å€™...");
                    refreshChunks();
                } catch (error) {
                    console.error("Error rebuilding chunks:", error);
                    alert("é‡å»ºåˆ†å¡Šå¤±æ•—ï¼š" + error.message);
                }
            }

            let currentPreviewBookId = null;

            async function showChunkPreview(bookId) {
                try {
                    currentPreviewBookId = bookId;
                    const response = await fetch(`/api/chunks/books/${bookId}/preview`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    const modal = document.getElementById("chunkPreviewModal");
                    const title = document.getElementById("chunkPreviewTitle");
                    const content = document.getElementById("chunkPreviewContent");

                    title.textContent = `${data.book.book_name_traditional || data.book.book_name_simplified} - åˆ†å¡Šé è¦½`;

                    // Ensure chunks is an array
                    const chunks = Array.isArray(data.chunks) ? data.chunks : [];

                    let html = `
                        <div class="mb-3">
                            <p><strong>ä½œè€…ï¼š</strong>${data.book.author || 'æœªçŸ¥'}</p>
                            <p><strong>åˆ†é¡ï¼š</strong>${data.book.category || 'æœªçŸ¥'}</p>
                            <p><strong>ç¸½åˆ†å¡Šæ•¸ï¼š</strong>${data.totalChunks || chunks.length}</p>
                            <p><strong>æ¯å¡Šæœ€å¤§è¡Œæ•¸ï¼š</strong>${data.chunkSize || 1000}</p>
                        </div>
                        <hr>
                        <div class="chunks-list">
                    `;

                    if (chunks.length === 0) {
                        html += '<div class="alert alert-warning">ç›®å‰æ²’æœ‰åˆ†å¡Šè³‡æ–™</div>';
                    } else {
                        chunks.forEach(chunk => {
                        const chapterRange = chunk.firstChapter !== null && chunk.lastChapter !== null
                            ? (chunk.firstChapter === chunk.lastChapter
                                ? `ç¬¬ ${chunk.firstChapter} ç« `
                                : `ç¬¬ ${chunk.firstChapter} ç«  è‡³ ç¬¬ ${chunk.lastChapter} ç« `)
                            : 'æœªçŸ¥ç« ç¯€';
                        
                        html += `
                            <div class="card mb-3">
                                <div class="card-header">
                                    <h5>åˆ†å¡Š ${chunk.chunkNumber} / ${chunk.totalChunks}</h5>
                                </div>
                                <div class="card-body">
                                    <p><strong>ç« ç¯€ç¯„åœï¼š</strong>${chapterRange}</p>
                                    <p><strong>è¡Œæ•¸ç¯„åœï¼š</strong>ç¬¬ ${chunk.lineStart} è¡Œ è‡³ ç¬¬ ${chunk.lineEnd} è¡Œ</p>
                                    <p><strong>åŒ…å«ç« ç¯€æ•¸ï¼š</strong>${chunk.chapterCount}</p>
                                    <button class="btn btn-sm btn-primary" onclick="showChunkContent(${bookId}, ${chunk.chunkNumber})">
                                        æŸ¥çœ‹å…§å®¹
                                    </button>
                                </div>
                            </div>
                        `;
                        });
                    }

                    html += '</div>';
                    content.innerHTML = html;
                    modal.classList.add("active");
                } catch (error) {
                    console.error("Error loading chunk preview:", error);
                    alert("è¼‰å…¥åˆ†å¡Šé è¦½å¤±æ•—ï¼š" + error.message);
                }
            }

            async function showChunkContent(bookId, chunkNumber) {
                try {
                    currentPreviewBookId = bookId;
                    const response = await fetch(`/api/chunks/books/${bookId}/chunks/${chunkNumber}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const chunk = await response.json();
                    const modal = document.getElementById("chunkPreviewModal");
                    const title = document.getElementById("chunkPreviewTitle");
                    const content = document.getElementById("chunkPreviewContent");

                    title.textContent = `åˆ†å¡Š ${chunk.chunkNumber} / ${chunk.totalChunks}`;

                    let html = `
                        <div class="mb-3">
                            <button class="btn btn-secondary btn-sm" onclick="showChunkPreview(${bookId})">
                                è¿”å›åˆ—è¡¨
                            </button>
                        </div>
                        <div class="chunk-content" style="white-space: pre-wrap; font-family: monospace; background: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 70vh; overflow-y: auto;">
                            ${escapeHtml(chunk.content)}
                        </div>
                    `;

                    content.innerHTML = html;
                } catch (error) {
                    console.error("Error loading chunk content:", error);
                    alert("è¼‰å…¥åˆ†å¡Šå…§å®¹å¤±æ•—ï¼š" + error.message);
                }
            }

            function closeChunkPreview() {
                const modal = document.getElementById("chunkPreviewModal");
                modal.classList.remove("active");
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            function startBotStatusStream() {
                // Close existing connection
                if (botStatusEventSource) {
                    botStatusEventSource.close();
                }

                // Connect to SSE stream
                botStatusEventSource = new EventSource(
                    "/api/bot-status/stream"
                );

                botStatusEventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === "status-update") {
                            botOperations = data.operations || [];
                            updateBotStatusIndicator(data.isActive);
                            updateBotStatusSummary(data.summary);

                            // Only update display if bot status tab is active
                            const botStatusTab =
                                document.getElementById("botStatusTab");
                            if (
                                botStatusTab &&
                                botStatusTab.classList.contains("active")
                            ) {
                                displayOperations(botOperations);
                            }
                        }
                    } catch (error) {
                        console.error("Error parsing bot status data:", error);
                    }
                };

                botStatusEventSource.onerror = (error) => {
                    console.error("Bot status SSE error:", error);
                    // Reconnect after 3 seconds
                    setTimeout(() => {
                        if (
                            botStatusEventSource &&
                            botStatusEventSource.readyState ===
                                EventSource.CLOSED
                        ) {
                            startBotStatusStream();
                        }
                    }, 3000);
                };
            }

            const searchHtmlInput = document.getElementById("searchHtmlInput");
            if (searchHtmlInput) {
                searchHtmlInput.addEventListener(
                    "change",
                    handleSearchHtmlUpload
                );
            }

            // Initialize
            // Load saved search state from localStorage
            loadSearchStateFromLocalStorage();

            // Restore search results display if available
            if (searchResults.length > 0) {
                displayResults(searchResults);
                updateSearchUrlDisplay();
                // Show retry and delete buttons if we have a last search
                if (lastSearchId) {
                    const retryBtn = document.getElementById("retrySearchBtn");
                    const deleteBtn =
                        document.getElementById("deleteSearchBtn");
                    if (retryBtn) retryBtn.style.display = "inline-block";
                    if (deleteBtn) deleteBtn.style.display = "inline-block";
                }
            }

            loadBooks();
            updateQueueDisplay();
            setupUploadArea();
            loadBotStatus();
            startBotStatusStream();
            
            // Setup draggable modal for book metadata
            (function setupDraggableModal() {
                const modalHeader = document.getElementById("bookMetadataModalHeader");
                const modalContent = document.getElementById("bookMetadataModalContent");
                
                if (!modalHeader || !modalContent) return;
                
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                modalHeader.addEventListener("mousedown", dragStart);
                document.addEventListener("mousemove", drag);
                document.addEventListener("mouseup", dragEnd);
                
                function dragStart(e) {
                    // Don't drag if clicking the close button
                    if (e.target.tagName === "BUTTON" || e.target.closest("button")) {
                        return;
                    }
                    
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === modalHeader || modalHeader.contains(e.target)) {
                        isDragging = true;
                        modalContent.style.cursor = "grabbing";
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        setTranslate(currentX, currentY, modalContent);
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    modalContent.style.cursor = "";
                }
                
                function setTranslate(xPos, yPos, el) {
                    el.style.transform = `translate(${xPos}px, ${yPos}px)`;
                    el.style.top = "50%";
                    el.style.left = "50%";
                }
                
                // Reset position when modal is closed
                const originalCloseModal = closeBookMetadataModal;
                closeBookMetadataModal = function() {
                    xOffset = 0;
                    yOffset = 0;
                    originalCloseModal();
                };
            })();
        </script>
        <!-- Bootstrap 5 JS Bundle -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    </body>
</html>
