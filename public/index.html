<!DOCTYPE html>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Alex Library</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    "Microsoft JhengHei", sans-serif;
                background: #f5f5f5;
                padding: 20px;
            }
            .container {
                max-width: 1400px;
                margin: 0 auto;
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                overflow: hidden;
            }
            .header {
                background: #007bff;
                color: white;
                padding: 20px 30px;
            }
            .header h1 {
                margin: 0;
                font-size: 24px;
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .header-icon {
                width: 32px;
                height: 32px;
                vertical-align: middle;
            }
            .tabs {
                display: flex;
                background: #e9ecef;
                border-bottom: 2px solid #dee2e6;
            }
            .tab {
                padding: 15px 30px;
                cursor: pointer;
                background: transparent;
                border: none;
                font-size: 16px;
                color: #495057;
                transition: all 0.3s;
                position: relative;
            }
            .tab:hover {
                background: #dee2e6;
            }
            .tab.active {
                background: white;
                color: #007bff;
                font-weight: bold;
            }
            .tab.active::after {
                content: "";
                position: absolute;
                bottom: -2px;
                left: 0;
                right: 0;
                height: 2px;
                background: #007bff;
            }
            .tab-content {
                display: none;
                padding: 30px;
            }
            .tab-content.active {
                display: block;
            }
            .search-section {
                margin-bottom: 30px;
                display: flex;
                gap: 10px;
            }
            input[type="text"] {
                flex: 1;
                padding: 12px;
                font-size: 16px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            button {
                padding: 12px 24px;
                background: #007bff;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
            }
            button:hover {
                background: #0056b3;
            }
            button:disabled {
                background: #ccc;
                cursor: not-allowed;
            }
            button.secondary {
                background: #6c757d;
            }
            button.secondary:hover {
                background: #5a6268;
            }
            button.success {
                background: #28a745;
            }
            button.success:hover {
                background: #218838;
            }
            .status {
                padding: 10px;
                background: #e7f3ff;
                border-left: 4px solid #007bff;
                margin: 20px 0;
                display: none;
            }
            .status.error {
                background: #ffe7e7;
                border-left-color: #dc3545;
            }
            .status.success {
                background: #e7f7e7;
                border-left-color: #28a745;
            }
            .queue-section {
                margin-top: 20px;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 4px;
            }
            .queue-item {
                padding: 10px;
                background: white;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                margin-bottom: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .queue-item.processing {
                border-left: 4px solid #007bff;
            }
            .queue-item.completed {
                border-left: 4px solid #28a745;
            }
            .queue-item.error {
                border-left: 4px solid #dc3545;
            }
            .queue-keyword {
                font-weight: bold;
            }
            .queue-status {
                font-size: 14px;
                color: #666;
            }
            .results-header {
                display: flex;
                flex-direction: column;
                gap: 15px;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #eee;
            }
            .results-controls {
                display: flex;
                align-items: center;
                gap: 20px;
                flex-wrap: wrap;
            }
            .results-controls .book-selector {
                display: flex;
                align-items: center;
                gap: 10px;
                flex-wrap: wrap;
            }
            .thread-item {
                padding: 15px;
                border: 1px solid #ddd;
                border-radius: 4px;
                margin-bottom: 10px;
                display: flex;
                align-items: start;
                gap: 15px;
            }
            .thread-item:hover {
                background: #f9f9f9;
            }
            .thread-checkbox {
                margin-top: 3px;
            }
            .thread-content {
                flex: 1;
            }
            .thread-title {
                font-weight: bold;
                font-size: 16px;
                margin-bottom: 5px;
                color: #333;
            }
            .thread-meta {
                font-size: 14px;
                color: #666;
                margin-top: 5px;
            }
            .thread-meta span {
                margin-right: 15px;
            }
            .chapter-badge {
                display: inline-block;
                padding: 2px 8px;
                background: #007bff;
                color: white;
                border-radius: 3px;
                font-size: 12px;
                margin-left: 10px;
            }
            .book-badge {
                display: inline-block;
                padding: 2px 8px;
                background: #28a745;
                color: white;
                border-radius: 3px;
                font-size: 12px;
                margin-left: 10px;
            }
            .selection-section {
                margin-top: 20px;
                padding: 20px;
                background: #f9f9f9;
                border-radius: 4px;
                display: none;
            }
            .selection-section.active {
                display: block;
            }
            .book-selector {
                margin-bottom: 15px;
            }
            .book-selector label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            .book-selector select,
            .book-selector input {
                width: 100%;
                padding: 8px;
                font-size: 14px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            .selected-count {
                margin-bottom: 15px;
                font-weight: bold;
                color: #007bff;
            }
            .books-grid {
                margin-top: 20px;
                overflow-x: auto;
            }
            .books-table {
                width: 100%;
                border-collapse: collapse;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                overflow: hidden;
            }
            .books-table thead {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
            }
            .books-table th {
                padding: 12px;
                text-align: left;
                font-weight: 600;
                color: #333;
                border-bottom: 2px solid #ddd;
            }
            .books-table tbody tr {
                border-bottom: 1px solid #eee;
                cursor: pointer;
            }
            .books-table tbody tr:hover {
                background: #f8f9fa;
            }
            .books-table tbody tr.selected {
                background: #f0f7ff;
                border-color: #007bff;
            }
            .books-table tbody tr.selected:hover {
                background: #e6f2ff;
            }
            .books-table td {
                padding: 12px;
                vertical-align: middle;
            }
            .book-title {
                font-weight: 600;
                color: #333;
            }
            .book-checkbox {
                margin: 0;
            }
            .book-actions {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }
            .book-actions .button {
                padding: 6px 12px;
                font-size: 13px;
                white-space: nowrap;
            }
            .book-row {
                transition: background-color 0.2s;
            }
            .rating-stars {
                display: flex;
                gap: 2px;
                cursor: pointer;
                user-select: none;
            }
            .rating-star {
                font-size: 20px;
                color: #ddd;
                transition: color 0.2s;
            }
            .rating-star.active {
                color: #ffc107;
            }
            .rating-star:hover {
                color: #ffc107;
            }
            .books-table th.sortable {
                cursor: pointer;
                position: relative;
                padding-right: 25px;
            }
            .books-table th.sortable::after {
                content: "‚áÖ";
                position: absolute;
                right: 8px;
                opacity: 0.5;
                font-size: 14px;
            }
            .books-table th.sort-asc::after {
                content: "‚Üë";
                opacity: 1;
            }
            .books-table th.sort-desc::after {
                content: "‚Üì";
                opacity: 1;
            }
            .results-list {
                max-height: 600px;
                overflow-y: auto;
            }
            .empty-state {
                text-align: center;
                padding: 40px;
                color: #999;
            }
            .bulk-actions {
                position: sticky;
                bottom: 0;
                background: white;
                padding: 15px;
                border-top: 2px solid #eee;
                margin-top: 20px;
                display: none;
            }
            .bulk-actions.active {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .bulk-actions-info {
                font-weight: bold;
                color: #007bff;
            }
            .upload-area {
                border: 2px dashed #ddd;
                border-radius: 8px;
                padding: 40px;
                text-align: center;
                background: #f9f9f9;
                transition: all 0.3s;
                cursor: pointer;
                margin-bottom: 20px;
            }
            .upload-area:hover {
                border-color: #007bff;
                background: #f0f7ff;
            }
            .upload-area.dragover {
                border-color: #007bff;
                background: #e7f3ff;
            }
            .upload-area-icon {
                font-size: 48px;
                color: #999;
                margin-bottom: 15px;
            }
            .upload-area-text {
                font-size: 16px;
                color: #666;
                margin-bottom: 10px;
            }
            .upload-area-hint {
                font-size: 14px;
                color: #999;
            }
            .uploaded-files {
                margin-top: 20px;
            }
            .uploaded-file-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                margin-bottom: 10px;
            }
            .uploaded-file-info {
                flex: 1;
            }
            .uploaded-file-name {
                font-weight: bold;
                margin-bottom: 5px;
            }
            .uploaded-file-size {
                font-size: 14px;
                color: #666;
            }
            .uploaded-file-actions {
                display: flex;
                gap: 10px;
            }
            .file-input {
                display: none;
            }
            .progress-modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                justify-content: center;
                align-items: center;
            }
            .progress-modal.active {
                display: flex;
            }
            .modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                justify-content: center;
                align-items: center;
            }
            .modal.active {
                display: flex;
            }
            .modal-content {
                background: white;
                padding: 30px;
                border-radius: 8px;
                max-width: 700px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                position: relative;
            }
            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }
            .modal-header h3 {
                margin: 0;
            }
            .modal-close {
                background: none;
                border: none;
                font-size: 28px;
                cursor: pointer;
                color: #999;
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .modal-close:hover {
                color: #333;
            }
            .modal-body {
                margin-bottom: 20px;
            }
            .modal-footer {
                display: flex;
                justify-content: flex-end;
                gap: 10px;
                margin-top: 20px;
            }
            .progress-content {
                background: white;
                padding: 30px;
                border-radius: 8px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                position: relative;
            }
            .progress-content.draggable {
                cursor: move;
            }
            .progress-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                cursor: move;
                user-select: none;
            }
            .progress-header h3 {
                margin: 0;
                flex: 1;
            }
            .progress-bar-container {
                width: 100%;
                height: 30px;
                background: #f0f0f0;
                border-radius: 15px;
                overflow: hidden;
                margin-bottom: 20px;
            }
            .progress-bar {
                height: 100%;
                background: #007bff;
                transition: width 0.3s;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 12px;
            }
            .progress-logs {
                max-height: 300px;
                overflow-y: auto;
                background: #f9f9f9;
                padding: 15px;
                border-radius: 4px;
                font-family: monospace;
                font-size: 12px;
            }
            .progress-log-item {
                margin-bottom: 5px;
                padding: 5px;
            }
            .progress-log-item.error {
                color: #dc3545;
            }
            .progress-log-item.success {
                color: #28a745;
            }
            .bot-status-indicator {
                display: inline-block;
                margin-left: 15px;
                padding: 5px 12px;
                border-radius: 12px;
                font-size: 12px;
                font-weight: normal;
                background: #6c757d;
                color: white;
            }
            .bot-status-indicator.active {
                background: #28a745;
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.7;
                }
            }
            .bot-status-summary {
                display: flex;
                gap: 20px;
                margin-bottom: 20px;
                padding: 15px;
                background: #f8f9fa;
                border-radius: 4px;
            }
            .bot-status-summary-item {
                flex: 1;
                text-align: center;
            }
            .bot-status-summary-item-value {
                font-size: 24px;
                font-weight: bold;
                color: #007bff;
            }
            .bot-status-summary-item-label {
                font-size: 14px;
                color: #666;
                margin-top: 5px;
            }
            .operation-card {
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 15px;
                margin-bottom: 15px;
                background: white;
            }
            .operation-card.active {
                border-left: 4px solid #007bff;
            }
            .operation-card.completed {
                border-left: 4px solid #28a745;
            }
            .operation-card.failed {
                border-left: 4px solid #dc3545;
            }
            .operation-header {
                display: flex;
                justify-content: space-between;
                align-items: start;
                margin-bottom: 10px;
            }
            .operation-title {
                font-weight: bold;
                font-size: 16px;
            }
            .operation-type-badge {
                display: inline-block;
                padding: 2px 8px;
                border-radius: 3px;
                font-size: 12px;
                margin-left: 10px;
            }
            .operation-type-badge.search {
                background: #17a2b8;
                color: white;
            }
            .operation-type-badge.download {
                background: #007bff;
                color: white;
            }
            .operation-type-badge.upload {
                background: #ffc107;
                color: #333;
            }
            .operation-type-badge.export {
                background: #28a745;
                color: white;
            }
            .operation-status {
                font-size: 12px;
                padding: 3px 8px;
                border-radius: 3px;
                background: #e9ecef;
                color: #495057;
            }
            .operation-status.active {
                background: #cfe2ff;
                color: #084298;
            }
            .operation-status.completed {
                background: #d1e7dd;
                color: #0f5132;
            }
            .operation-status.failed {
                background: #f8d7da;
                color: #842029;
            }
            .operation-progress {
                margin-top: 10px;
            }
            .operation-progress-bar {
                width: 100%;
                height: 20px;
                background: #e9ecef;
                border-radius: 10px;
                overflow: hidden;
                margin-bottom: 5px;
            }
            .operation-progress-fill {
                height: 100%;
                background: #007bff;
                transition: width 0.3s;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 11px;
            }
            .operation-progress-fill.completed {
                background: #28a745;
            }
            .operation-progress-fill.failed {
                background: #dc3545;
            }
            .operation-details {
                font-size: 14px;
                color: #666;
                margin-top: 10px;
            }
            .operation-details div {
                margin-bottom: 5px;
            }
            .operation-time {
                font-size: 12px;
                color: #999;
                margin-top: 10px;
            }
            .empty-operations {
                text-align: center;
                padding: 40px;
                color: #999;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>
                    <a
                        href="https://game-icons.net/1x1/lorc/cat.html"
                        target="_blank"
                        rel="noopener noreferrer"
                        style="text-decoration: none"
                    >
                        <img
                            src="https://game-icons.net/icons/000000/transparent/1x1/lorc/cat.svg"
                            alt="Cat Icon"
                            class="header-icon"
                            style="filter: brightness(0) invert(1)"
                        />
                    </a>
                    Alex Library
                    <span id="botStatusIndicator" class="bot-status-indicator"
                        >ÈñíÁΩÆ</span
                    >
                </h1>
            </div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('search')">
                    ÊêúÂ∞ã
                </button>
                <button class="tab" onclick="switchTab('results')">
                    ÊêúÂ∞ãÁµêÊûú
                </button>
                <button class="tab" onclick="switchTab('books')">Êõ∏Á±ç</button>
                <button class="tab" onclick="switchTab('chapters')">
                    Á´†ÁØÄ
                </button>
                <button class="tab" onclick="switchTab('upload')">
                    ‰∏äÂÇ≥Ê™îÊ°à
                </button>
                <button class="tab" onclick="switchTab('botStatus')">
                    Ê©üÂô®‰∫∫ÁãÄÊÖã
                </button>
            </div>

            <!-- Search Tab -->
            <div id="searchTab" class="tab-content active">
                <div class="search-section">
                    <input
                        type="text"
                        id="searchInput"
                        placeholder="Ëº∏ÂÖ•ÈóúÈçµÂ≠óÊêúÂ∞ã (‰æãÂ¶Ç: ÈÉΩÂ∏Ç„ÄÅÂè§Ë£ù)"
                        onkeypress="if(event.key==='Enter') addToQueue()"
                    />
                    <button id="searchBtn" onclick="addToQueue()">
                        Âä†ÂÖ•ÊêúÂ∞ã‰ΩáÂàó
                    </button>
                    <button
                        class="button secondary"
                        onclick="triggerSearchHtmlUpload()"
                    >
                        ÂåØÂÖ•ÊêúÂ∞ãHTML
                    </button>
                    <input
                        type="file"
                        id="searchHtmlInput"
                        class="file-input"
                        accept=".html,.htm,.txt"
                    />
                </div>
                <div id="status" class="status"></div>

                <div class="queue-section">
                    <h3>ÊêúÂ∞ã‰ΩáÂàó</h3>
                    <div id="queueList"></div>
                </div>
            </div>

            <!-- Results Tab -->
            <div id="resultsTab" class="tab-content">
                <div class="results-header">
                    <h3>ÊêúÂ∞ãÁµêÊûú</h3>
                    <div class="results-controls">
                        <div class="book-selector">
                            <label>ÈÅ∏ÊìáÊõ∏Á±çÔºö</label>
                            <select
                                id="bookSelector"
                                onchange="toggleBookNameInput()"
                            >
                                <option value="new">Âª∫Á´ãÊñ∞Êõ∏Á±ç</option>
                                <option value="from-url">ÂæûÊêúÂ∞ãÁ∂≤ÂùÄÂª∫Á´ã</option>
                            </select>
                            <input
                                type="text"
                                id="newBookName"
                                placeholder="Êñ∞Êõ∏Á±çÂêçÁ®± (Á∞°È´î‰∏≠Êñá)"
                                style="margin-top: 10px; display: none"
                            />
                        </div>
                        <button
                            onclick="startDownload()"
                            id="downloadBtn"
                            disabled
                        >
                            ‰∏ãËºâÈÅ∏‰∏≠ÁöÑÁ´†ÁØÄ
                        </button>
                    </div>
                </div>
                <div
                    id="searchUrlDisplay"
                    style="
                        display: none;
                        margin-bottom: 20px;
                        padding: 15px;
                        background: #f8f9fa;
                        border-radius: 4px;
                        border-left: 4px solid #007bff;
                    "
                >
                    <div
                        style="font-size: 14px; color: #666; margin-bottom: 5px"
                    >
                        ÁõÆÊ®ôÁ∂≤ÂùÄÔºö
                    </div>
                    <div style="font-size: 16px">
                        <a
                            id="searchUrlLink"
                            href="#"
                            target="_blank"
                            rel="noopener noreferrer"
                            style="
                                color: #007bff;
                                text-decoration: none;
                                word-break: break-all;
                            "
                        >
                            <span id="searchUrlText"></span>
                        </a>
                        <button
                            onclick="copySearchUrl()"
                            style="
                                margin-left: 10px;
                                padding: 5px 10px;
                                background: #6c757d;
                                color: white;
                                border: none;
                                border-radius: 3px;
                                cursor: pointer;
                                font-size: 12px;
                            "
                        >
                            Ë§áË£Ω
                        </button>
                    </div>
                </div>
                <div id="resultsList" class="results-list"></div>

                <div id="selectionSection" class="selection-section">
                    <div class="selected-count" id="selectedCount">
                        Â∑≤ÈÅ∏Êìá 0 ÂÄãÁ´†ÁØÄ
                    </div>
                </div>
            </div>

            <!-- Book Metadata Modal -->
            <div id="bookMetadataModal" class="progress-modal">
                <div id="bookMetadataModalContent" class="progress-content" style="max-width: 700px">
                    <div class="progress-header" id="bookMetadataModalHeader">
                        <h3>Á¢∫Ë™çÊõ∏Á±çË≥áË®ä</h3>
                        <button
                            onclick="closeBookMetadataModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div style="margin-bottom: 20px">
                        <p style="color: #666; margin-bottom: 15px">
                            Ë´ãÁ¢∫Ë™ç‰∏¶Á∑®ËºØ‰ª•‰∏ãË≥áË®äÔºåÈÄô‰∫õË≥áË®äÂ∞áÁî®ÊñºÂª∫Á´ãÊñ∞Êõ∏Á±çÔºö
                        </p>
                        <form id="bookMetadataForm">
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >Êõ∏ÂêçÔºàÁ∞°È´îÔºâ:</label
                                >
                                <input
                                    type="text"
                                    id="metadataBookName"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                    required
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >Êõ∏ÂêçÔºàÁπÅÈ´îÔºâ:</label
                                >
                                <input
                                    type="text"
                                    id="metadataBookNameTraditional"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >‰ΩúËÄÖ:</label
                                >
                                <input
                                    type="text"
                                    id="metadataAuthor"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >È°ûÂà•:</label
                                >
                                <input
                                    type="text"
                                    id="metadataCategory"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >Ê®ôÁ±§ÔºàÁî®ÈÄóËôüÂàÜÈöîÔºâ:</label
                                >
                                <input
                                    type="text"
                                    id="metadataTags"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                    placeholder="‰æãÂ¶Ç: Â∞èË™™, ÈÉΩÂ∏Ç, Êàê‰∫∫"
                                />
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >ÊèèËø∞:</label
                                >
                                <textarea
                                    id="metadataDescription"
                                    rows="4"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                        resize: vertical;
                                    "
                                ></textarea>
                            </div>
                            <div style="margin-bottom: 15px">
                                <label
                                    style="
                                        display: block;
                                        margin-bottom: 5px;
                                        font-weight: bold;
                                    "
                                    >‰æÜÊ∫êÁ∂≤ÂùÄ:</label
                                >
                                <input
                                    type="text"
                                    id="metadataSourceUrl"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                    "
                                    placeholder="Á´†ÁØÄÊàñÊõ∏Á±ç‰æÜÊ∫êÁ∂≤ÂùÄ"
                                />
                            </div>
                        </form>
                    </div>
                    <div
                        style="
                            display: flex;
                            gap: 10px;
                            justify-content: flex-end;
                        "
                    >
                        <button
                            onclick="closeBookMetadataModal()"
                            style="
                                padding: 10px 20px;
                                background: #6c757d;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            ÂèñÊ∂à
                        </button>
                        <button
                            onclick="confirmBookMetadata()"
                            style="
                                padding: 10px 20px;
                                background: #007bff;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            Á¢∫Ë™ç‰∏¶ÈñãÂßã‰∏ãËºâ
                        </button>
                    </div>
                </div>
            </div>

            <!-- Book Details Modal -->
            <div id="bookDetailsModal" class="progress-modal">
                <div
                    class="progress-content"
                    style="max-width: 900px; max-height: 80vh"
                >
                    <div class="progress-header">
                        <h3 id="bookDetailsTitle">Êõ∏Á±çË©≥ÊÉÖ</h3>
                        <button
                            onclick="closeBookDetailsModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div
                        style="
                            margin-bottom: 20px;
                            max-height: 60vh;
                            overflow-y: auto;
                        "
                    >
                        <div id="bookDetailsContent"></div>
                    </div>
                    <div
                        style="
                            display: flex;
                            gap: 10px;
                            justify-content: flex-end;
                        "
                    >
                        <button
                            onclick="rescanBookChapters()"
                            id="rescanChaptersBtn"
                            style="
                                padding: 10px 20px;
                                background: #28a745;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            ÈáçÊñ∞ÊéÉÊèèÁ´†ÁØÄË≥áË®ä
                        </button>
                        <button
                            onclick="closeBookDetailsModal()"
                            style="
                                padding: 10px 20px;
                                background: #6c757d;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            "
                        >
                            ÈóúÈñâ
                        </button>
                    </div>
                </div>
            </div>

            <!-- Missing Chapters Modal -->
            <div id="missingChaptersModal" class="progress-modal">
                <div class="progress-content" style="max-width: 800px">
                    <div class="progress-header">
                        <h3>Áº∫Â§±Á´†ÁØÄÊêúÂ∞ãÁµêÊûú</h3>
                        <button
                            onclick="closeMissingChaptersModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div id="missingChaptersContent"></div>
                </div>
            </div>

            <!-- Progress Modal -->
            <div id="progressModal" class="progress-modal">
                <div class="progress-content">
                    <div class="progress-header">
                        <h3>‰∏ãËºâÈÄ≤Â∫¶</h3>
                        <button
                            onclick="closeProgressModal()"
                            style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                            "
                        >
                            &times;
                        </button>
                    </div>
                    <div class="progress-bar-container">
                        <div
                            id="progressBar"
                            class="progress-bar"
                            style="width: 0%"
                        >
                            0%
                        </div>
                    </div>
                    <div id="progressStats" style="margin-bottom: 15px">
                        <div>
                            Â∑≤ÂÆåÊàê: <span id="progressCompleted">0</span> /
                            <span id="progressTotal">0</span>
                        </div>
                        <div>Â§±Êïó: <span id="progressFailed">0</span></div>
                    </div>
                    <div class="progress-logs" id="progressLogs"></div>
                </div>
            </div>

            <!-- Upload Tab -->
            <div id="uploadTab" class="tab-content">
                <div class="results-header">
                    <h3>‰∏äÂÇ≥Ê™îÊ°àËôïÁêÜ</h3>
                </div>
                <p style="margin-bottom: 20px; color: #666">
                    ÊîØÊè¥ÁöÑÊ™îÊ°àÊ†ºÂºèÔºöhtml.txt (Ë´ñÂ£áÁ¥¢Âºï)„ÄÅÂñÆ‰∏ÄÂü∑Ë°åÁ∑í
                    HTML„ÄÅraw.txt„ÄÅpre_content_0.md
                </p>

                <div
                    class="upload-area"
                    id="uploadArea"
                    onclick="document.getElementById('fileInput').click()"
                >
                    <div class="upload-area-icon">üìÅ</div>
                    <div class="upload-area-text">ÈªûÊìäÊàñÊãñÊîæÊ™îÊ°àÂà∞Ê≠§Ëôï‰∏äÂÇ≥</div>
                    <div class="upload-area-hint">ÊîØÊè¥Â§öÊ™îÊ°à‰∏äÂÇ≥</div>
                </div>
                <input
                    type="file"
                    id="fileInput"
                    class="file-input"
                    multiple
                    accept=".txt,.html,.md"
                    onchange="handleFileSelect(event)"
                />

                <div
                    id="uploadStatus"
                    class="status"
                    style="display: none"
                ></div>

                <div
                    class="uploaded-files"
                    id="uploadedFiles"
                    style="display: none"
                >
                    <h4 style="margin-bottom: 15px">Â∑≤‰∏äÂÇ≥ÁöÑÊ™îÊ°à</h4>
                    <div id="uploadedFilesList"></div>

                    </div>
                </div>

                <!-- Book Selection Modal -->
                <div id="uploadBookSelectionModal" class="modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Á¢∫Ë™çÊõ∏Á±çË≥áË®ä</h3>
                            <button
                                class="modal-close"
                                onclick="closeUploadBookSelectionModal()"
                            >
                                √ó
                            </button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px;">
                                <div id="uploadFileCountInfo" style="font-weight: bold; color: #007bff; margin-bottom: 10px;"></div>
                                <p style="color: #666; font-size: 14px;">
                                    Êõ∏Á±çË≥áË®äÂ∑≤ÂæûÁ¨¨‰∏ÄÂÄãÊ™îÊ°à‰∏≠ÊèêÂèñÔºåË´ãÁ¢∫Ë™çÊàñ‰øÆÊîπÔºö
                                </p>
                            </div>
                            
                            <div class="book-selector" style="margin-bottom: 20px;">
                                <label>ÈÅ∏ÊìáÊõ∏Á±çÔºö</label>
                                <select
                                    id="uploadBookSelector"
                                    onchange="toggleUploadBookMetadataForm()"
                                >
                                    <option value="new">Âª∫Á´ãÊñ∞Êõ∏Á±ç</option>
                                </select>
                            </div>

                            <!-- New Book Metadata Form (shown when "Âª∫Á´ãÊñ∞Êõ∏Á±ç" is selected) -->
                            <div id="uploadNewBookForm" style="display: none; margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-radius: 4px;">
                                <h4 style="margin-bottom: 15px;">Êñ∞Êõ∏Á±çË≥áË®ä</h4>
                                
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">Êõ∏Á±çÂêçÁ®±Ôºö</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookName"
                                        placeholder="Êõ∏Á±çÂêçÁ®± (Á∞°È´î‰∏≠Êñá)"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">‰ΩúËÄÖÔºö</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookAuthor"
                                        placeholder="‰ΩúËÄÖ"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ÂàÜÈ°ûÔºö</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookCategory"
                                        placeholder="ÂàÜÈ°û"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ÊèèËø∞Ôºö</label>
                                    <textarea
                                        id="uploadNewBookDescription"
                                        placeholder="ÊèèËø∞"
                                        rows="3"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"
                                    ></textarea>
                                </div>

                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">‰æÜÊ∫êÁ∂≤ÂùÄÔºö</label>
                                    <input
                                        type="text"
                                        id="uploadNewBookSourceUrl"
                                        placeholder="‰æÜÊ∫êÁ∂≤ÂùÄ"
                                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;"
                                    />
                                </div>
                            </div>

                            <div style="margin-bottom: 20px;">
                                <label>Á´†ÁØÄÈ†êË¶ΩÔºàÂâç10ÂÄãÔºâÔºö</label>
                                <pre id="uploadChapterPreview" style="background: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto; font-size: 13px; white-space: pre-wrap;"></pre>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button
                                class="button secondary"
                                onclick="closeUploadBookSelectionModal()"
                            >
                                ÂèñÊ∂à
                            </button>
                            <button
                                class="button success"
                                onclick="processUploadedFiles()"
                            >
                                Á¢∫Ë™ç‰∏¶ËôïÁêÜÊâÄÊúâÊ™îÊ°à
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Books Tab -->
            <div id="booksTab" class="tab-content">
                <div class="results-header">
                    <h3>ÊàëÁöÑÊõ∏Á±ç</h3>
                    <div>
                        <button
                            class="button secondary"
                            onclick="refreshBooks()"
                        >
                            ÈáçÊñ∞Êï¥ÁêÜ
                        </button>
                        <button
                            class="button success"
                            id="exportToJoplinBtn"
                            onclick="exportSelectedToJoplin()"
                            disabled
                        >
                            ÂåØÂá∫ÈÅ∏‰∏≠Êõ∏Á±çÂà∞ Joplin
                        </button>
                    </div>
                </div>
                <div id="booksGrid" class="books-grid"></div>
                <div id="bulkActions" class="bulk-actions">
                    <div class="bulk-actions-info" id="bulkActionsInfo">
                        Â∑≤ÈÅ∏Êìá 0 Êú¨Êõ∏Á±ç
                    </div>
                    <button
                        class="button success"
                        onclick="exportSelectedToJoplin()"
                    >
                        ÂåØÂá∫ÈÅ∏‰∏≠Êõ∏Á±çÂà∞ Joplin
                    </button>
                </div>
            </div>

            <!-- Chapters Tab -->
            <div id="chaptersTab" class="tab-content">
                <div class="results-header">
                    <h3 id="chaptersTabTitle">Á´†ÁØÄÂàóË°®</h3>
                    <div>
                        <button
                            id="backToBooksBtn"
                            class="button secondary"
                            onclick="backToBooks()"
                            style="display: none; margin-right: 10px"
                        >
                            ËøîÂõûÊõ∏Á±çÂàóË°®
                        </button>
                        <button
                            id="reformatChaptersBtn"
                            class="button success"
                            onclick="reformatAllChapters()"
                            style="display: none; margin-right: 10px"
                        >
                            ÈáçÊñ∞Ê†ºÂºèÂåñÊâÄÊúâÁ´†ÁØÄ
                        </button>
                        <button
                            class="button secondary"
                            onclick="refreshChapters()"
                        >
                            ÈáçÊñ∞Êï¥ÁêÜ
                        </button>
                    </div>
                </div>
                <div id="chaptersList"></div>
            </div>

            <!-- Bot Status Tab -->
            <div id="botStatusTab" class="tab-content">
                <div class="results-header">
                    <h3>Ê©üÂô®‰∫∫ÁãÄÊÖã</h3>
                    <button
                        class="button secondary"
                        onclick="refreshBotStatus()"
                    >
                        ÈáçÊñ∞Êï¥ÁêÜ
                    </button>
                </div>

                <div class="bot-status-summary" id="botStatusSummary">
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryTotal"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">
                            Á∏ΩÊìç‰ΩúÊï∏
                        </div>
                    </div>
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryActive"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">ÈÄ≤Ë°å‰∏≠</div>
                    </div>
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryCompleted"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">Â∑≤ÂÆåÊàê</div>
                    </div>
                    <div class="bot-status-summary-item">
                        <div
                            class="bot-status-summary-item-value"
                            id="summaryFailed"
                        >
                            0
                        </div>
                        <div class="bot-status-summary-item-label">Â§±Êïó</div>
                    </div>
                </div>

                <div id="operationsList"></div>
            </div>
        </div>

        <script>
            // Global state
            let searchQueue = [];
            let searchResults = [];
            let selectedThreads = new Set();
            let books = [];
            let selectedBooks = new Set();
            let currentSearchId = null;
            let lastSearchParams = null; // Store last search keyword and pages for retry
            let lastSearchId = null; // Store last search ID for deletion
            let currentSearchKeyword = null; // Store current search keyword for URL display

            // LocalStorage persistence helpers
            function saveSearchStateToLocalStorage() {
                try {
                    localStorage.setItem(
                        "alexLib_searchQueue",
                        JSON.stringify(searchQueue)
                    );
                    localStorage.setItem(
                        "alexLib_searchResults",
                        JSON.stringify(searchResults)
                    );
                    localStorage.setItem(
                        "alexLib_currentSearchKeyword",
                        currentSearchKeyword || ""
                    );
                    localStorage.setItem(
                        "alexLib_lastSearchParams",
                        JSON.stringify(lastSearchParams)
                    );
                    localStorage.setItem(
                        "alexLib_lastSearchId",
                        lastSearchId || ""
                    );
                } catch (error) {
                    console.error(
                        "Error saving search state to localStorage:",
                        error
                    );
                }
            }

            function loadSearchStateFromLocalStorage() {
                try {
                    const savedQueue = localStorage.getItem(
                        "alexLib_searchQueue"
                    );
                    if (savedQueue) {
                        searchQueue = JSON.parse(savedQueue);
                        // Filter out any items that were processing (they won't complete after restart)
                        searchQueue = searchQueue.filter(
                            (item) => item.status !== "processing"
                        );
                    }

                    const savedResults = localStorage.getItem(
                        "alexLib_searchResults"
                    );
                    if (savedResults) {
                        searchResults = JSON.parse(savedResults);
                    }

                    const savedKeyword = localStorage.getItem(
                        "alexLib_currentSearchKeyword"
                    );
                    if (savedKeyword) {
                        currentSearchKeyword = savedKeyword;
                    }

                    const savedParams = localStorage.getItem(
                        "alexLib_lastSearchParams"
                    );
                    if (savedParams) {
                        lastSearchParams = JSON.parse(savedParams);
                    }

                    const savedSearchId = localStorage.getItem(
                        "alexLib_lastSearchId"
                    );
                    if (savedSearchId) {
                        lastSearchId = savedSearchId;
                    }
                } catch (error) {
                    console.error(
                        "Error loading search state from localStorage:",
                        error
                    );
                }
            }

            // Tab switching
            function switchTab(tabName) {
                // Update tab buttons
                document.querySelectorAll(".tab").forEach((tab, index) => {
                    tab.classList.remove("active");
                    if (
                        (tabName === "search" && index === 0) ||
                        (tabName === "results" && index === 1) ||
                        (tabName === "books" && index === 2) ||
                        (tabName === "upload" && index === 3)
                    ) {
                        tab.classList.add("active");
                    }
                });

                // Update tab content
                document
                    .querySelectorAll(".tab-content")
                    .forEach((content) => content.classList.remove("active"));
                document
                    .getElementById(tabName + "Tab")
                    .classList.add("active");

                // Load data when switching tabs
                if (tabName === "books") {
                    loadBooks();
                } else if (tabName === "upload") {
                    loadBooksForUpload();
                    // Make sure modal is closed when switching to upload tab
                    const modal = document.getElementById("uploadBookSelectionModal");
                    if (modal) {
                        modal.classList.remove("active");
                    }
                } else if (tabName === "botStatus") {
                    loadBotStatus();
                }
            }

            // Search Queue Management
            function addToQueue() {
                const keyword = document
                    .getElementById("searchInput")
                    .value.trim();
                if (!keyword) {
                    showStatus("Ë´ãËº∏ÂÖ•ÊêúÂ∞ãÈóúÈçµÂ≠ó", "error");
                    return;
                }

                const searchId = Date.now();
                const queueItem = {
                    id: searchId,
                    keyword: keyword,
                    pages: 3, // Default to 3 pages
                    status: "pending",
                    results: null,
                };

                searchQueue.push(queueItem);
                document.getElementById("searchInput").value = "";
                updateQueueDisplay();
                saveSearchStateToLocalStorage();

                // Start processing if not already processing
                if (!currentSearchId) {
                    processQueue();
                }
            }

            function updateQueueDisplay() {
                const queueList = document.getElementById("queueList");
                if (searchQueue.length === 0) {
                    queueList.innerHTML =
                        '<div class="empty-state">‰ΩáÂàóÁÇ∫Á©∫</div>';
                    return;
                }

                let html = "";
                searchQueue.forEach((item) => {
                    const statusClass =
                        item.status === "processing"
                            ? "processing"
                            : item.status === "completed"
                            ? "completed"
                            : item.status === "error"
                            ? "error"
                            : "";
                    const statusText =
                        item.status === "processing"
                            ? "ÊêúÂ∞ã‰∏≠..."
                            : item.status === "completed"
                            ? `ÂÆåÊàê (${item.results?.length || 0} ÁµêÊûú)`
                            : item.status === "error"
                            ? "ÈåØË™§"
                            : "Á≠âÂæÖ‰∏≠";

                    html += `
                    <div class="queue-item ${statusClass}">
                        <div>
                            <div class="queue-keyword">${item.keyword}</div>
                            <div class="queue-status">${statusText}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            ${
                                item.status === "completed"
                                    ? `<button class="button" onclick="viewResults(${item.id})">Êü•ÁúãÁµêÊûú</button>`
                                    : ""
                            }
                            ${
                                item.status !== "processing"
                                    ? `<button class="button secondary" onclick="retrySearch(${item.id})">ÈáçÊñ∞ÊêúÂ∞ã</button>`
                                    : ""
                            }
                            ${
                                item.status !== "processing"
                                    ? `<button class="button secondary" onclick="removeSearch(${item.id})" style="background: #dc3545; color: white;">ÁßªÈô§</button>`
                                    : ""
                            }
                        </div>
                    </div>
                `;
                });
                queueList.innerHTML = html;
            }

            async function processQueue() {
                const pendingItem = searchQueue.find(
                    (item) => item.status === "pending"
                );
                if (!pendingItem) {
                    currentSearchId = null;
                    updateQueueDisplay(); // Update display when queue is empty
                    return;
                }

                currentSearchId = pendingItem.id;
                pendingItem.status = "processing";
                updateQueueDisplay();

                try {
                    const pages = pendingItem.pages || 3;
                    const response = await fetch(
                        `/api/search?keyword=${encodeURIComponent(
                            pendingItem.keyword
                        )}&pages=${pages}`
                    );
                    const data = await response.json();

                    if (!response.ok || data.error) {
                        pendingItem.status = "error";
                        const errorMessage =
                            data.message ||
                            data.error ||
                            `HTTP ${response.status}`;
                        console.error("ÊêúÂ∞ã API ÂõûÊáâÈåØË™§", {
                            keyword: pendingItem.keyword,
                            status: response.status,
                            error: data.error,
                            message: data.message,
                        });
                        showStatus("ÊêúÂ∞ãÂ§±Êïó: " + errorMessage, "error");
                    } else {
                        pendingItem.status = "completed";
                        pendingItem.results = data.threads || [];
                        pendingItem.dbSearchId = data.searchResultId || null; // Store database ID
                        // Store last search params for retry
                        currentSearchKeyword = pendingItem.keyword;
                        lastSearchParams = {
                            keyword: pendingItem.keyword,
                            pages: pages,
                        };
                        lastSearchId = pendingItem.id;
                        // Show retry and delete buttons (if they exist)
                        const retryBtn =
                            document.getElementById("retrySearchBtn");
                        const deleteBtn =
                            document.getElementById("deleteSearchBtn");
                        if (retryBtn) retryBtn.style.display = "inline-block";
                        if (deleteBtn) deleteBtn.style.display = "inline-block";
                        showStatus(
                            `ÊêúÂ∞ãÂÆåÊàê: ÊâæÂà∞ ${pendingItem.results.length} ÂÄãÁµêÊûú`,
                            "success"
                        );
                        // Save to localStorage
                        saveSearchStateToLocalStorage();
                    }
                } catch (error) {
                    pendingItem.status = "error";
                    console.error("ÊêúÂ∞ãË´ãÊ±ÇÂ§±Êïó", {
                        keyword: pendingItem.keyword,
                        error,
                        stack: error.stack,
                    });
                    const errorMessage = error.message || "Êú™Áü•ÈåØË™§";
                    console.error("ÊêúÂ∞ãÈåØË™§Ë©≥ÊÉÖ:", errorMessage);
                    showStatus("ÊêúÂ∞ãÊôÇÁôºÁîüÈåØË™§: " + errorMessage, "error");
                } finally {
                    updateQueueDisplay();
                    // Process next item
                    setTimeout(() => {
                        processQueue();
                    }, 500);
                }
            }

            function viewResults(searchId) {
                const queueItem = searchQueue.find(
                    (item) => item.id === searchId
                );
                if (!queueItem || !queueItem.results) return;

                searchResults = queueItem.results;
                currentSearchKeyword = queueItem.keyword;
                lastSearchId = searchId;
                lastSearchParams = {
                    keyword: queueItem.keyword,
                    pages: queueItem.pages || 3,
                };
                // Show retry and delete buttons (if they exist)
                const retryBtn = document.getElementById("retrySearchBtn");
                const deleteBtn = document.getElementById("deleteSearchBtn");
                if (retryBtn) retryBtn.style.display = "inline-block";
                if (deleteBtn) deleteBtn.style.display = "inline-block";
                displayResults(searchResults);
                updateSearchUrlDisplay();
                switchTab("results");
                // Save to localStorage
                saveSearchStateToLocalStorage();
            }

            function clearResults() {
                searchResults = [];
                selectedThreads.clear();
                displayResults([]);
                const selectionSection =
                    document.getElementById("selectionSection");
                if (selectionSection) {
                    selectionSection.classList.remove("active");
                }
                lastSearchParams = null;
                lastSearchId = null;
                const retryBtn = document.getElementById("retrySearchBtn");
                const deleteBtn = document.getElementById("deleteSearchBtn");
                if (retryBtn) retryBtn.style.display = "none";
                if (deleteBtn) deleteBtn.style.display = "none";
                // Save to localStorage
                saveSearchStateToLocalStorage();
            }

            async function deleteLastSearch() {
                if (!lastSearchId) {
                    showStatus("Ê≤íÊúâÂèØÂà™Èô§ÁöÑÊêúÂ∞ã", "error");
                    return;
                }

                // Remove from queue
                const queueItem = searchQueue.find(
                    (item) => item.id === lastSearchId
                );
                if (queueItem && queueItem.status === "processing") {
                    showStatus("ÁÑ°Ê≥ïÂà™Èô§Ê≠£Âú®ËôïÁêÜ‰∏≠ÁöÑÊêúÂ∞ã", "error");
                    return;
                }

                // Delete from database if it has a dbSearchId
                if (queueItem && queueItem.dbSearchId) {
                    try {
                        const response = await fetch(
                            `/api/search/${queueItem.dbSearchId}`,
                            {
                                method: "DELETE",
                            }
                        );
                        if (!response.ok) {
                            console.error(
                                "Failed to delete search from database"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "Error deleting search from database:",
                            error
                        );
                    }
                }

                searchQueue = searchQueue.filter(
                    (item) => item.id !== lastSearchId
                );

                // If it was the current search, clear it
                if (currentSearchId === lastSearchId) {
                    currentSearchId = null;
                }

                // Clear results if viewing this search
                if (searchResults.length > 0) {
                    clearResults();
                }

                updateQueueDisplay();
                showStatus("Â∑≤Âà™Èô§ÊêúÂ∞ã", "success");
                // Save to localStorage
                saveSearchStateToLocalStorage();
            }

            function retryLastSearch() {
                if (!lastSearchParams) {
                    showStatus("Ê≤íÊúâÂèØÈáçË©¶ÁöÑÊêúÂ∞ã", "error");
                    return;
                }

                // Add to queue with same params
                const searchId = Date.now();
                const queueItem = {
                    id: searchId,
                    keyword: lastSearchParams.keyword,
                    pages: lastSearchParams.pages,
                    status: "pending",
                    results: null,
                };

                searchQueue.push(queueItem);
                updateQueueDisplay();
                saveSearchStateToLocalStorage();

                // Start processing if not already processing
                if (!currentSearchId) {
                    processQueue();
                }

                showStatus("Â∑≤Âä†ÂÖ•ÊêúÂ∞ã‰ΩáÂàó", "success");
            }

            function retrySearch(searchId) {
                const queueItem = searchQueue.find(
                    (item) => item.id === searchId
                );
                if (!queueItem) return;

                const newItem = {
                    id: Date.now(),
                    keyword: queueItem.keyword,
                    pages: queueItem.pages || 3,
                    status: "pending",
                    results: null,
                };

                searchQueue.push(newItem);
                updateQueueDisplay();
                saveSearchStateToLocalStorage();

                // Start processing if not already processing
                if (!currentSearchId) {
                    processQueue();
                }

                showStatus("Â∑≤ÈáçÊñ∞Âä†ÂÖ•ÊêúÂ∞ã", "success");
            }

            async function removeSearch(searchId) {
                // Don't remove if currently processing
                const queueItem = searchQueue.find(
                    (item) => item.id === searchId
                );
                if (queueItem && queueItem.status === "processing") {
                    showStatus("ÁÑ°Ê≥ïÁßªÈô§Ê≠£Âú®ËôïÁêÜ‰∏≠ÁöÑÊêúÂ∞ã", "error");
                    return;
                }

                // Delete from database if it has a dbSearchId
                if (queueItem && queueItem.dbSearchId) {
                    try {
                        const response = await fetch(
                            `/api/search/${queueItem.dbSearchId}`,
                            {
                                method: "DELETE",
                            }
                        );
                        if (!response.ok) {
                            console.error(
                                "Failed to delete search from database"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "Error deleting search from database:",
                            error
                        );
                    }
                }

                // Remove from queue
                searchQueue = searchQueue.filter(
                    (item) => item.id !== searchId
                );

                // If it was the current search, clear it
                if (currentSearchId === searchId) {
                    currentSearchId = null;
                }

                updateQueueDisplay();
                showStatus("Â∑≤ÁßªÈô§ÊêúÂ∞ã", "success");
            }

            // Update search URL display
            function updateSearchUrlDisplay() {
                const searchUrlDisplay =
                    document.getElementById("searchUrlDisplay");
                const searchUrlLink = document.getElementById("searchUrlLink");
                const searchUrlText = document.getElementById("searchUrlText");

                if (!searchUrlDisplay || !searchUrlLink || !searchUrlText) {
                    return; // Elements don't exist, skip
                }

                if (currentSearchKeyword) {
                    const baseUrl = "https://www.cool18.com/bbs4";
                    const searchUrl = `${baseUrl}/index.php?app=forum&act=search&keyword=${encodeURIComponent(
                        currentSearchKeyword
                    )}&page=1`;
                    searchUrlLink.href = searchUrl;
                    searchUrlText.textContent = searchUrl;
                    searchUrlDisplay.style.display = "block";
                } else {
                    searchUrlDisplay.style.display = "none";
                }
            }

            // Copy search URL to clipboard
            function copySearchUrl() {
                const searchUrlLink = document.getElementById("searchUrlLink");
                if (!searchUrlLink) {
                    showStatus("ÁÑ°Ê≥ïË§áË£ΩÁ∂≤ÂùÄÔºöÊâæ‰∏çÂà∞ÈÄ£ÁµêÂÖÉÁ¥†", "error");
                    return;
                }
                const url = searchUrlLink.href;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard
                        .writeText(url)
                        .then(() => {
                            showStatus("Á∂≤ÂùÄÂ∑≤Ë§áË£ΩÂà∞Ââ™Ë≤ºÁ∞ø", "success");
                        })
                        .catch((err) => {
                            console.error("Failed to copy URL:", err);
                            showStatus("Ë§áË£ΩÂ§±Êïó", "error");
                        });
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement("textarea");
                    textArea.value = url;
                    textArea.style.position = "fixed";
                    textArea.style.opacity = "0";
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand("copy");
                        showStatus("Á∂≤ÂùÄÂ∑≤Ë§áË£ΩÂà∞Ââ™Ë≤ºÁ∞ø", "success");
                    } catch (err) {
                        showStatus("Ë§áË£ΩÂ§±Êïó", "error");
                    }
                    document.body.removeChild(textArea);
                }
            }

            // Results Display
            function displayResults(threads) {
                const resultsList = document.getElementById("resultsList");

                if (threads.length === 0) {
                    resultsList.innerHTML =
                        '<div class="empty-state">Ê≤íÊúâÁµêÊûú</div>';
                    updateSearchUrlDisplay();
                    return;
                }

                let html = "";
                threads.forEach((thread, index) => {
                    const isSelected = selectedThreads.has(index);
                    html += `
                    <div class="thread-item">
                        <input type="checkbox" class="thread-checkbox" data-index="${index}" ${
                        isSelected ? "checked" : ""
                    } onchange="toggleThread(${index})">
                        <div class="thread-content" style="flex: 1;">
                            <div class="thread-title">
                                ${thread.titleTraditional || thread.title}
                                ${
                                    thread.chapterNumber
                                        ? `<span class="chapter-badge">Á¨¨${
                                              thread.chapterNumber
                                          }${
                                              thread.chapterFormat || "Á´†"
                                          }</span>`
                                        : ""
                                }
                                ${
                                    thread.bookNameTraditional
                                        ? `<span class="book-badge">${thread.bookNameTraditional}</span>`
                                        : ""
                                }
                            </div>
                            <div class="thread-meta">
                                ${
                                    thread.url
                                        ? `<span><a href="${thread.url}" target="_blank" rel="noopener noreferrer" style="color: #007bff; text-decoration: none;">üîó Êü•ÁúãÂéüÊñá</a></span>`
                                        : ""
                                }
                                ${
                                    thread.date
                                        ? `<span>Êó•Êúü: ${thread.date}</span>`
                                        : ""
                                }
                                ${
                                    thread.replies !== undefined
                                        ? `<span>ÂõûË¶Ü: ${thread.replies}</span>`
                                        : ""
                                }
                                ${
                                    thread.existingBookId
                                        ? `<span style="color: #28a745;">‚úì Â∑≤Â≠òÂú®ÊñºË≥áÊñôÂ∫´</span>`
                                        : ""
                                }
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button class="button success" onclick="downloadSingleChapter(${index})" style="padding: 8px 16px; font-size: 14px;">‰∏ãËºâÁ´†ÁØÄ</button>
                        </div>
                    </div>
                `;
                });

                resultsList.innerHTML = html;
                updateSearchUrlDisplay();
            }

            function toggleThread(index) {
                const checkbox = document.querySelector(
                    `.thread-checkbox[data-index="${index}"]`
                );
                if (checkbox.checked) {
                    selectedThreads.add(index);
                } else {
                    selectedThreads.delete(index);
                }
                updateSelectionUI();
            }

            function updateSelectionUI() {
                const count = selectedThreads.size;
                document.getElementById(
                    "selectedCount"
                ).textContent = `Â∑≤ÈÅ∏Êìá ${count} ÂÄãÁ´†ÁØÄ`;
                document.getElementById("downloadBtn").disabled = count === 0;

                const selectionSection =
                    document.getElementById("selectionSection");
                if (count > 0) {
                    selectionSection.classList.add("active");
                } else {
                    selectionSection.classList.remove("active");
                }
            }

            function toggleBookNameInput() {
                const selector = document.getElementById("bookSelector");
                const newBookInput = document.getElementById("newBookName");
                newBookInput.style.display =
                    selector.value === "new" ? "block" : "none";
            }

            let pendingDownloadData = null; // Store download data while showing metadata modal

            async function downloadSingleChapter(index) {
                const thread = searchResults[index];
                if (!thread || !thread.url) {
                    showStatus("ÁÑ°Ê≥ïÂèñÂæóÁ´†ÁØÄË≥áË®ä", "error");
                    return;
                }

                showStatus("Ê≠£Âú®ÊèêÂèñÊõ∏Á±çË≥áË®ä...", "");

                try {
                    // Extract metadata from chapter URL
                    const response = await fetch(
                        "/api/books/extract-metadata",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ url: thread.url }),
                        }
                    );

                    const data = await response.json();

                    if (!response.ok || data.error) {
                        const errorMsg =
                            data.message ||
                            data.error ||
                            `HTTP ${response.status}`;
                        console.error("Metadata extraction failed:", {
                            status: response.status,
                            error: data.error,
                            message: data.message,
                            url: thread.url,
                        });
                        showStatus("ÊèêÂèñË≥áË®äÂ§±Êïó: " + errorMsg, "error");
                        return;
                    }

                    // Prepare chapter data
                    const chapter = {
                        url: thread.url,
                        title: thread.title || thread.titleTraditional || "",
                        chapterNum: thread.chapterNumber || null,
                    };

                    // Show metadata modal for confirmation/editing
                    showBookMetadataModalForSingleChapter(data, chapter);
                } catch (error) {
                    console.error("Metadata extraction error:", error);
                    showStatus(
                        "ÊèêÂèñË≥áË®äÊôÇÁôºÁîüÈåØË™§: " + (error.message || "Êú™Áü•ÈåØË™§"),
                        "error"
                    );
                }
            }

            function showBookMetadataModalForSingleChapter(metadata, chapter) {
                // Populate form with extracted metadata
                document.getElementById("metadataBookName").value =
                    metadata.bookName || "";
                document.getElementById("metadataBookNameTraditional").value =
                    metadata.bookNameTraditional || "";
                document.getElementById("metadataAuthor").value =
                    metadata.author || "";
                document.getElementById("metadataCategory").value =
                    metadata.category || "";
                document.getElementById("metadataTags").value = (
                    metadata.tags || []
                ).join(", ");
                document.getElementById("metadataDescription").value =
                    metadata.description || "";
                document.getElementById("metadataSourceUrl").value =
                    metadata.sourceUrl || chapter.url || "";

                // Store download data for single chapter
                pendingDownloadData = {
                    chapters: [chapter],
                    bookId: null,
                    bookName: metadata.bookName || "",
                    isSingleChapter: true,
                };

                // Update modal title and button
                const modalTitle = document.querySelector(
                    "#bookMetadataModal .progress-header h3"
                );
                const confirmButton = document.querySelector(
                    '#bookMetadataModal button[onclick="confirmBookMetadata()"]'
                );
                modalTitle.textContent = "Á¢∫Ë™çÊõ∏Á±çË≥áË®ä‰∏¶‰∏ãËºâÁ´†ÁØÄ";
                confirmButton.textContent = "Á¢∫Ë™ç‰∏¶ÈñãÂßã‰∏ãËºâ";

                // Show modal
                const modal = document.getElementById("bookMetadataModal");
                const modalContent = document.getElementById("bookMetadataModalContent");
                modal.classList.add("active");
                
                // Initialize or reset modal position
                modalContent.style.position = "fixed";
                modalContent.style.top = "50%";
                modalContent.style.left = "50%";
                modalContent.style.transform = "translate(-50%, -50%)";
                modalContent.style.margin = "0";
            }

            async function startDownload() {
                const selected = Array.from(selectedThreads).map(
                    (i) => searchResults[i]
                );
                const bookSelector = document.getElementById("bookSelector");
                const newBookName = document
                    .getElementById("newBookName")
                    .value.trim();

                let bookId =
                    bookSelector.value === "new" ||
                    bookSelector.value === "from-url"
                        ? null
                        : parseInt(bookSelector.value);
                let bookName = null;

                if (bookSelector.value === "new") {
                    if (!newBookName) {
                        showStatus("Ë´ãËº∏ÂÖ•Êñ∞Êõ∏Á±çÂêçÁ®±", "error");
                        return;
                    }
                    bookName = newBookName;
                } else if (bookSelector.value === "from-url") {
                    // Book name will be extracted from metadata
                    bookName = null;
                } else {
                    const selectedBook = books.find((b) => b.id === bookId);
                    bookName = selectedBook
                        ? selectedBook.book_name_simplified
                        : null;
                }

                const chapters = selected.map((thread) => ({
                    url: thread.url,
                    title: thread.title,
                    chapterNum: thread.chapterNumber,
                }));

                // If creating a new book or from URL, extract metadata from first chapter URL
                if (
                    (bookSelector.value === "new" ||
                        bookSelector.value === "from-url") &&
                    chapters.length > 0
                ) {
                    showStatus("Ê≠£Âú®ÊèêÂèñÊõ∏Á±çË≥áË®ä...", "");
                    try {
                        const response = await fetch(
                            "/api/books/extract-metadata",
                            {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ url: chapters[0].url }),
                            }
                        );

                        const metadata = await response.json();
                        if (metadata.error) {
                            showStatus(
                                "ÊèêÂèñË≥áË®äÂ§±ÊïóÔºåÂ∞á‰ΩøÁî®È†êË®≠ÂÄº: " +
                                    metadata.message,
                                "warning"
                            );
                            // Create dummy metadata from first chapter URL
                            const urlTidMatch =
                                chapters[0].url?.match(/tid=(\d+)/);
                            const threadId = urlTidMatch
                                ? urlTidMatch[1]
                                : "unknown";
                            const dummyMetadata = {
                                bookName: `Êõ∏Á±ç_${threadId}`,
                                author: "",
                                category: "",
                                description: "",
                                tags: [],
                                sourceUrl:
                                    bookSelector.value === "from-url"
                                        ? document.getElementById(
                                              "searchUrlLink"
                                          )?.href || chapters[0].url
                                        : chapters[0].url,
                                threadId: threadId,
                                originalTitle: `Êõ∏Á±ç_${threadId}`,
                                bookNameTraditional: `Êõ∏Á±ç_${threadId}`,
                            };

                            // Use dummy book name if from-url option
                            if (bookSelector.value === "from-url") {
                                bookName = dummyMetadata.bookName;
                            } else if (!bookName) {
                                bookName = dummyMetadata.bookName;
                            }

                            // Continue with download using dummy metadata
                            proceedWithDownload(
                                chapters,
                                bookId,
                                bookName,
                                dummyMetadata
                            );
                        } else {
                            // If "from-url" option, override sourceUrl with search URL
                            if (bookSelector.value === "from-url") {
                                const searchUrlLink =
                                    document.getElementById("searchUrlLink");
                                if (
                                    searchUrlLink &&
                                    searchUrlLink.href &&
                                    searchUrlLink.href !== "#"
                                ) {
                                    metadata.sourceUrl = searchUrlLink.href;
                                }
                            }

                            // Use extracted book name if from-url option
                            if (bookSelector.value === "from-url") {
                                bookName = metadata.bookName || null;
                            }

                            // Show metadata modal for confirmation
                            showBookMetadataModal(
                                metadata,
                                chapters,
                                bookId,
                                bookName
                            );
                        }
                    } catch (error) {
                        console.error("Metadata extraction error:", error);
                        showStatus(
                            "ÊèêÂèñË≥áË®äÊôÇÁôºÁîüÈåØË™§ÔºåÂ∞á‰ΩøÁî®È†êË®≠ÂÄº",
                            "warning"
                        );
                        // Create dummy metadata from first chapter URL
                        const urlTidMatch =
                            chapters[0]?.url?.match(/tid=(\d+)/);
                        const threadId = urlTidMatch
                            ? urlTidMatch[1]
                            : "unknown";
                        const dummyMetadata = {
                            bookName: `Êõ∏Á±ç_${threadId}`,
                            author: "",
                            category: "",
                            description: "",
                            tags: [],
                            sourceUrl:
                                bookSelector.value === "from-url"
                                    ? document.getElementById("searchUrlLink")
                                          ?.href ||
                                      chapters[0]?.url ||
                                      ""
                                    : chapters[0]?.url || "",
                            threadId: threadId,
                            originalTitle: `Êõ∏Á±ç_${threadId}`,
                            bookNameTraditional: `Êõ∏Á±ç_${threadId}`,
                        };

                        // Use dummy book name if from-url option
                        if (bookSelector.value === "from-url") {
                            bookName = dummyMetadata.bookName;
                        } else if (!bookName) {
                            bookName = dummyMetadata.bookName;
                        }

                        // Continue with download using dummy metadata
                        proceedWithDownload(
                            chapters,
                            bookId,
                            bookName,
                            dummyMetadata
                        );
                    }
                } else {
                    // Existing book, proceed directly in background (non-blocking)
                    proceedWithDownloadInBackground(
                        chapters,
                        bookId,
                        bookName,
                        null
                    );
                }
            }

            function showBookMetadataModal(
                metadata,
                chapters,
                bookId,
                bookName
            ) {
                // Populate form with extracted metadata
                document.getElementById("metadataBookName").value =
                    metadata.bookName || bookName || "";
                document.getElementById("metadataBookNameTraditional").value =
                    metadata.bookNameTraditional || "";
                document.getElementById("metadataAuthor").value =
                    metadata.author || "";
                document.getElementById("metadataCategory").value =
                    metadata.category || "";
                document.getElementById("metadataTags").value = (
                    metadata.tags || []
                ).join(", ");
                document.getElementById("metadataDescription").value =
                    metadata.description || "";
                document.getElementById("metadataSourceUrl").value =
                    metadata.sourceUrl || "";

                // Store download data
                pendingDownloadData = { chapters, bookId, bookName };

                // Update modal title and button
                const modalTitle = document.querySelector(
                    "#bookMetadataModal .progress-header h3"
                );
                const confirmButton = document.querySelector(
                    '#bookMetadataModal button[onclick="confirmBookMetadata()"]'
                );
                modalTitle.textContent = "Á¢∫Ë™çÊõ∏Á±çË≥áË®ä";
                confirmButton.textContent = "Á¢∫Ë™ç‰∏¶ÈñãÂßã‰∏ãËºâ";

                // Show modal
                const modal = document.getElementById("bookMetadataModal");
                const modalContent = document.getElementById("bookMetadataModalContent");
                modal.classList.add("active");
                
                // Initialize or reset modal position
                modalContent.style.position = "fixed";
                modalContent.style.top = "50%";
                modalContent.style.left = "50%";
                modalContent.style.transform = "translate(-50%, -50%)";
                modalContent.style.margin = "0";
            }

            function closeBookMetadataModal() {
                const modalContent = document.getElementById("bookMetadataModalContent");
                if (modalContent) {
                    // Reset modal position when closing
                    modalContent.style.transform = "translate(-50%, -50%)";
                }
                document
                    .getElementById("bookMetadataModal")
                    .classList.remove("active");
                pendingDownloadData = null;
            }

            async function confirmBookMetadata() {
                if (!pendingDownloadData) {
                    showStatus("‰∏ãËºâË≥áÊñôÈÅ∫Â§±ÔºåË´ãÈáçÊñ∞ÈÅ∏ÊìáÁ´†ÁØÄ", "error");
                    return;
                }

                // Get form values
                const bookMetadata = {
                    bookName: document
                        .getElementById("metadataBookName")
                        .value.trim(),
                    bookNameTraditional: document
                        .getElementById("metadataBookNameTraditional")
                        .value.trim(),
                    author: document
                        .getElementById("metadataAuthor")
                        .value.trim(),
                    category: document
                        .getElementById("metadataCategory")
                        .value.trim(),
                    tags: document
                        .getElementById("metadataTags")
                        .value.split(",")
                        .map((t) => t.trim())
                        .filter((t) => t),
                    description: document
                        .getElementById("metadataDescription")
                        .value.trim(),
                    sourceUrl: document
                        .getElementById("metadataSourceUrl")
                        .value.trim(),
                };

                if (!bookMetadata.bookName) {
                    showStatus("Ë´ãËº∏ÂÖ•Êõ∏Âêç", "error");
                    return;
                }

                // Store data before closing modal (which sets pendingDownloadData to null)
                const isEdit = pendingDownloadData.isEdit || false;
                const downloadChapters = pendingDownloadData.chapters;
                const downloadBookId = pendingDownloadData.bookId;
                const downloadBookName = pendingDownloadData.bookName;

                closeBookMetadataModal();

                // If editing existing book
                if (isEdit) {
                    try {
                        showStatus("Ê≠£Âú®Êõ¥Êñ∞Êõ∏Á±çË≥áË®ä...", "");
                        const response = await fetch(
                            `/api/books/${downloadBookId}`,
                            {
                                method: "PUT",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({
                                    book_name_simplified: bookMetadata.bookName,
                                    book_name_traditional:
                                        bookMetadata.bookNameTraditional,
                                    author: bookMetadata.author,
                                    category: bookMetadata.category,
                                    description: bookMetadata.description,
                                    source_url: bookMetadata.sourceUrl,
                                    tags: bookMetadata.tags,
                                }),
                            }
                        );

                        const data = await response.json();
                        if (data.error) {
                            showStatus("Êõ¥Êñ∞Â§±Êïó: " + data.error, "error");
                        } else {
                            showStatus("Êõ∏Á±çË≥áË®äÂ∑≤Êõ¥Êñ∞", "success");
                            await loadBooks();
                        }
                    } catch (error) {
                        console.error("Update error:", error);
                        showStatus("Êõ¥Êñ∞ÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                    }
                } else {
                    // Creating new book and downloading
                    proceedWithDownload(
                        downloadChapters,
                        downloadBookId,
                        bookMetadata.bookName,
                        bookMetadata
                    );
                }
            }

            async function proceedWithDownload(
                chapters,
                bookId,
                bookName,
                bookMetadata
            ) {
                showStatus("Ê∫ñÂÇô‰∏ãËºâ...", "");

                try {
                    const response = await fetch("/api/download/start", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            chapters,
                            bookId,
                            bookName,
                            bookMetadata,
                        }),
                    });

                    const data = await response.json();
                    if (data.error) {
                        showStatus("‰∏ãËºâÂ§±Êïó: " + data.message, "error");
                    } else {
                        showStatus(
                            `‰∏ãËºâ‰ªªÂãôÂ∑≤Âª∫Á´ã (ID: ${data.jobId})${
                                data.bookId ? `ÔºåÊõ∏Á±ç ID: ${data.bookId}` : ""
                            }`,
                            "success"
                        );
                        selectedThreads.clear();
                        updateSelectionUI();
                        // Re-display results to update checkbox states, but keep results visible
                        if (searchResults.length > 0) {
                            displayResults(searchResults);
                        }
                        // Open progress view
                        showDownloadProgress(data.jobId, data.totalChapters);
                        // Reload books to show the newly created book
                        await loadBooks();
                        console.log(
                            "Books reloaded after download start, bookId:",
                            data.bookId
                        );
                    }
                } catch (error) {
                    console.error("Download error:", error);
                    showStatus("‰∏ãËºâÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            // Non-blocking version for existing books - runs in background
            function proceedWithDownloadInBackground(
                chapters,
                bookId,
                bookName,
                bookMetadata
            ) {
                // Show immediate feedback
                showStatus("Ê≠£Âú®ÂïüÂãï‰∏ãËºâ‰ªªÂãô...", "success");
                selectedThreads.clear();
                updateSelectionUI();
                // Re-display results to update checkbox states, but keep results visible
                if (searchResults.length > 0) {
                    displayResults(searchResults);
                }

                // Start download in background without blocking
                fetch("/api/download/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        chapters,
                        bookId,
                        bookName,
                        bookMetadata,
                    }),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.error) {
                            showStatus("‰∏ãËºâÂ§±Êïó: " + data.message, "error");
                        } else {
                            showStatus(
                                `‰∏ãËºâ‰ªªÂãôÂ∑≤ÂïüÂãï (ID: ${data.jobId})`,
                                "success"
                            );
                            // Open progress view
                            showDownloadProgress(
                                data.jobId,
                                data.totalChapters
                            );
                            // Reload books in background
                            loadBooks().catch((error) => {
                                console.error("Error reloading books:", error);
                            });
                        }
                    })
                    .catch((error) => {
                        console.error("Download error:", error);
                        showStatus("‰∏ãËºâÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                    });
            }

            // Books Management
            let currentSortColumn = null;
            let currentSortDirection = "asc"; // "asc" or "desc"

            async function loadBooks() {
                try {
                    const response = await fetch("/api/books");
                    if (!response.ok) {
                        throw new Error(
                            `HTTP ${response.status}: ${response.statusText}`
                        );
                    }
                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    books = Array.isArray(data) ? data : [];
                    console.log("Loaded books:", books.length, books);
                    updateBookSelector();
                    displayBooks();
                } catch (error) {
                    console.error("Error loading books:", error);
                    showStatus("ËºâÂÖ•Êõ∏Á±çÂ§±Êïó: " + error.message, "error");
                }
            }

            function sortBooks(column) {
                if (currentSortColumn === column) {
                    // Toggle direction if clicking same column
                    currentSortDirection = currentSortDirection === "asc" ? "desc" : "asc";
                } else {
                    currentSortColumn = column;
                    currentSortDirection = "asc";
                }

                books.sort((a, b) => {
                    let aVal, bVal;

                    switch (column) {
                        case "name":
                            aVal = (a.book_name_traditional || a.book_name_simplified || "").toLowerCase();
                            bVal = (b.book_name_traditional || b.book_name_simplified || "").toLowerCase();
                            break;
                        case "author":
                            aVal = (a.author || "").toLowerCase();
                            bVal = (b.author || "").toLowerCase();
                            break;
                        case "rating":
                            aVal = a.rating || 0;
                            bVal = b.rating || 0;
                            break;
                        case "chapters":
                            aVal = a.total_chapters || 0;
                            bVal = b.total_chapters || 0;
                            break;
                        case "last_updated":
                            aVal = a.last_updated ? new Date(a.last_updated).getTime() : 0;
                            bVal = b.last_updated ? new Date(b.last_updated).getTime() : 0;
                            break;
                        default:
                            return 0;
                    }

                    if (typeof aVal === "string") {
                        return currentSortDirection === "asc"
                            ? aVal.localeCompare(bVal)
                            : bVal.localeCompare(aVal);
                    } else {
                        return currentSortDirection === "asc"
                            ? aVal - bVal
                            : bVal - aVal;
                    }
                });

                displayBooks();
            }

            function updateBookSelector() {
                const selector = document.getElementById("bookSelector");
                selector.innerHTML = '<option value="new">Âª∫Á´ãÊñ∞Êõ∏Á±ç</option>';
                books.forEach((book) => {
                    const option = document.createElement("option");
                    option.value = book.id;
                    option.textContent =
                        book.book_name_traditional || book.book_name_simplified;
                    selector.appendChild(option);
                });
            }

            function displayBooks() {
                const booksGrid = document.getElementById("booksGrid");

                if (books.length === 0) {
                    booksGrid.innerHTML =
                        '<div class="empty-state">ÈÇÑÊ≤íÊúâÊõ∏Á±ç</div>';
                    return;
                }

                let html = `
                    <table class="books-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" id="selectAllBooks" onchange="toggleSelectAllBooks(event)">
                                </th>
                                <th class="sortable ${currentSortColumn === "name" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('name')">Êõ∏Âêç</th>
                                <th class="sortable ${currentSortColumn === "author" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('author')">‰ΩúËÄÖ</th>
                                <th class="sortable ${currentSortColumn === "rating" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('rating')">Ë©ïÂàÜ</th>
                                <th class="sortable ${currentSortColumn === "chapters" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('chapters')">Á´†ÁØÄÁØÑÂúç</th>
                                <th>ÁôºÂ∏ÉÊó•Êúü</th>
                                <th class="sortable ${currentSortColumn === "last_updated" ? (currentSortDirection === "asc" ? "sort-asc" : "sort-desc") : ""}" onclick="sortBooks('last_updated')">ÊúÄÂæåÊõ¥Êñ∞</th>
                                <th style="width: 500px;">Êìç‰Ωú</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                books.forEach((book) => {
                    const isSelected = selectedBooks.has(book.id);
                    const chapterRange =
                        book.min_chapter && book.max_chapter
                            ? `Á¨¨${book.min_chapter}Á´† ~ Á¨¨${book.max_chapter}Á´†`
                            : "ÁÑ°Á´†ÁØÄ";

                    const rating = book.rating || 0;
                    const ratingStars = Array.from({ length: 5 }, (_, i) => {
                        const starValue = i + 1;
                        return `<span class="rating-star ${starValue <= rating ? "active" : ""}" 
                            data-rating="${starValue}" 
                            data-book-id="${book.id}"
                            onclick="event.stopPropagation(); setBookRating(${book.id}, ${starValue})"
                            onmouseover="event.stopPropagation(); highlightRating(${book.id}, ${starValue})"
                            onmouseout="event.stopPropagation(); resetRatingHighlight(${book.id})"
                            >‚òÖ</span>`;
                    }).join("");

                    html += `
                        <tr class="book-row ${isSelected ? "selected" : ""}" onclick="toggleBookSelection(${book.id}, event)">
                            <td onclick="event.stopPropagation();">
                                <input type="checkbox" class="book-checkbox" ${
                                    isSelected ? "checked" : ""
                                } onclick="event.stopPropagation(); toggleBookSelection(${book.id}, event)">
                            </td>
                            <td class="book-title">${
                                book.book_name_traditional ||
                                book.book_name_simplified
                            }</td>
                            <td>${book.author || "Êú™Áü•"}</td>
                            <td onclick="event.stopPropagation();">
                                <div class="rating-stars" id="rating-${book.id}">${ratingStars}</div>
                            </td>
                            <td>${chapterRange}</td>
                            <td>${book.release_date || "Êú™Áü•"}</td>
                            <td>${
                                book.last_updated
                                    ? new Date(
                                          book.last_updated
                                      ).toLocaleDateString("zh-TW")
                                    : "Êú™Áü•"
                            }</td>
                            <td class="book-actions" onclick="event.stopPropagation();">
                                <button class="button success" onclick="viewBookDetails(${book.id})">Êü•ÁúãÁ´†ÁØÄ</button>
                                <button class="button" onclick="editBookMetadata(${book.id})">Á∑®ËºØË≥áË®ä</button>
                                <button class="button" onclick="searchMissingChapters(${book.id})">ÊêúÂ∞ãÁº∫Â§±Á´†ÁØÄ</button>
                                <button class="button" onclick="searchDownChapters(${book.id})">Âêë‰∏ãÊêúÂ∞ã</button>
                                <button class="button" onclick="searchNewChapters(${book.id})">ÊêúÂ∞ãÊñ∞Á´†ÁØÄ</button>
                                <button class="button success" onclick="exportBookToJoplin(${book.id})">ÂåØÂá∫Âà∞ Joplin</button>
                                <button class="button error" onclick="deleteBook(${book.id})">Âà™Èô§</button>
                            </td>
                        </tr>
                    `;
                });

                html += `
                        </tbody>
                    </table>
                `;

                booksGrid.innerHTML = html;
                updateBulkActions();
                updateSelectAllCheckbox();
                
                // Setup drag rating for all books
                setupDragRating();
            }

            function highlightRating(bookId, rating) {
                const ratingContainer = document.getElementById(`rating-${bookId}`);
                if (!ratingContainer) return;
                
                const stars = ratingContainer.querySelectorAll(".rating-star");
                stars.forEach((star, index) => {
                    if (index < rating) {
                        star.style.color = "#ffc107";
                    } else {
                        star.style.color = "#ddd";
                    }
                });
            }

            function resetRatingHighlight(bookId) {
                const ratingContainer = document.getElementById(`rating-${bookId}`);
                if (!ratingContainer) return;
                
                const book = books.find(b => b.id === bookId);
                const currentRating = book?.rating || 0;
                
                const stars = ratingContainer.querySelectorAll(".rating-star");
                stars.forEach((star, index) => {
                    if (index < currentRating) {
                        star.style.color = "#ffc107";
                    } else {
                        star.style.color = "#ddd";
                    }
                });
            }

            async function setBookRating(bookId, rating) {
                try {
                    const response = await fetch(`/api/books/${bookId}`, {
                        method: "PUT",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ rating: rating }),
                    });

                    const data = await response.json();
                    if (data.error) {
                        showStatus("Êõ¥Êñ∞Ë©ïÂàÜÂ§±Êïó: " + data.message, "error");
                        return;
                    }

                    // Update local book data
                    const book = books.find(b => b.id === bookId);
                    if (book) {
                        book.rating = rating;
                    }

                    // Update display
                    displayBooks();
                    showStatus("Ë©ïÂàÜÂ∑≤Êõ¥Êñ∞", "success");
                } catch (error) {
                    console.error("Error setting rating:", error);
                    showStatus("Êõ¥Êñ∞Ë©ïÂàÜÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            function setupDragRating() {
                // Setup drag and drop for rating stars
                books.forEach((book) => {
                    const ratingContainer = document.getElementById(`rating-${book.id}`);
                    if (!ratingContainer) return;

                    let isDragging = false;
                    let currentDragRating = 0;

                    ratingContainer.addEventListener("mousedown", (e) => {
                        if (e.target.classList.contains("rating-star")) {
                            isDragging = true;
                            currentDragRating = parseInt(e.target.dataset.rating);
                            highlightRating(book.id, currentDragRating);
                            e.preventDefault();
                        }
                    });

                    ratingContainer.addEventListener("mousemove", (e) => {
                        if (isDragging) {
                            const star = e.target.closest(".rating-star");
                            if (star) {
                                currentDragRating = parseInt(star.dataset.rating);
                                highlightRating(book.id, currentDragRating);
                            }
                        }
                    });

                    ratingContainer.addEventListener("mouseup", (e) => {
                        if (isDragging) {
                            isDragging = false;
                            const star = e.target.closest(".rating-star");
                            if (star) {
                                currentDragRating = parseInt(star.dataset.rating);
                                setBookRating(book.id, currentDragRating);
                            } else if (currentDragRating > 0) {
                                setBookRating(book.id, currentDragRating);
                            } else {
                                resetRatingHighlight(book.id);
                            }
                        }
                    });

                    ratingContainer.addEventListener("mouseleave", (e) => {
                        if (isDragging) {
                            // Check if we're still over a star
                            const star = e.relatedTarget?.closest(".rating-star");
                            if (!star) {
                                isDragging = false;
                                resetRatingHighlight(book.id);
                            }
                        }
                    });

                    // Also handle touch events for mobile
                    ratingContainer.addEventListener("touchstart", (e) => {
                        const star = e.target.closest(".rating-star");
                        if (star) {
                            isDragging = true;
                            currentDragRating = parseInt(star.dataset.rating);
                            highlightRating(book.id, currentDragRating);
                            e.preventDefault();
                        }
                    });

                    ratingContainer.addEventListener("touchmove", (e) => {
                        if (isDragging) {
                            const touch = e.touches[0];
                            const star = document.elementFromPoint(touch.clientX, touch.clientY)?.closest(".rating-star");
                            if (star) {
                                currentDragRating = parseInt(star.dataset.rating);
                                highlightRating(book.id, currentDragRating);
                            }
                            e.preventDefault();
                        }
                    });

                    ratingContainer.addEventListener("touchend", (e) => {
                        if (isDragging) {
                            isDragging = false;
                            if (currentDragRating > 0) {
                                setBookRating(book.id, currentDragRating);
                            } else {
                                resetRatingHighlight(book.id);
                            }
                            e.preventDefault();
                        }
                    });
                });
            }

            function toggleSelectAllBooks(event) {
                const checked = event.target.checked;
                books.forEach((book) => {
                    if (checked) {
                        selectedBooks.add(book.id);
                    } else {
                        selectedBooks.delete(book.id);
                    }
                });
                displayBooks();
                updateBulkActions();
            }

            function updateSelectAllCheckbox() {
                const selectAllCheckbox = document.getElementById("selectAllBooks");
                if (selectAllCheckbox && books.length > 0) {
                    const allSelected = books.every((book) => selectedBooks.has(book.id));
                    const someSelected = books.some((book) => selectedBooks.has(book.id));
                    selectAllCheckbox.checked = allSelected;
                    selectAllCheckbox.indeterminate = someSelected && !allSelected;
                }
            }

            function toggleBookSelection(bookId, event) {
                if (selectedBooks.has(bookId)) {
                    selectedBooks.delete(bookId);
                } else {
                    selectedBooks.add(bookId);
                }
                displayBooks();
            }

            function updateBulkActions() {
                const count = selectedBooks.size;
                const bulkActions = document.getElementById("bulkActions");
                const bulkActionsInfo =
                    document.getElementById("bulkActionsInfo");
                const exportBtn = document.getElementById("exportToJoplinBtn");

                if (count > 0) {
                    bulkActions.classList.add("active");
                    bulkActionsInfo.textContent = `Â∑≤ÈÅ∏Êìá ${count} Êú¨Êõ∏Á±ç`;
                    exportBtn.disabled = false;
                } else {
                    bulkActions.classList.remove("active");
                    exportBtn.disabled = true;
                }
            }

            async function exportSelectedToJoplin() {
                const bookIds = Array.from(selectedBooks);
                if (bookIds.length === 0) {
                    showStatus("Ë´ãÈÅ∏ÊìáË¶ÅÂåØÂá∫ÁöÑÊõ∏Á±ç", "error");
                    return;
                }

                showStatus(`Ê≠£Âú®ÂåØÂá∫ ${bookIds.length} Êú¨Êõ∏Á±çÂà∞ Joplin...`, "");

                try {
                    for (const bookId of bookIds) {
                        const response = await fetch(
                            `/api/joplin/export/${bookId}`,
                            {
                                method: "POST",
                            }
                        );
                        const data = await response.json();
                        if (data.error) {
                            showStatus(
                                `ÂåØÂá∫Êõ∏Á±ç ID ${bookId} Â§±Êïó: ${data.message}`,
                                "error"
                            );
                        }
                    }
                    showStatus(
                        `ÊàêÂäüÂåØÂá∫ ${bookIds.length} Êú¨Êõ∏Á±çÂà∞ Joplin`,
                        "success"
                    );
                    selectedBooks.clear();
                    displayBooks();
                } catch (error) {
                    console.error("Export error:", error);
                    showStatus("ÂåØÂá∫ÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            async function exportBookToJoplin(bookId) {
                showStatus("Ê≠£Âú®ÂåØÂá∫Âà∞ Joplin...", "");

                try {
                    const response = await fetch(
                        `/api/joplin/export/${bookId}`,
                        {
                            method: "POST",
                        }
                    );
                    const data = await response.json();
                    if (data.error) {
                        showStatus("ÂåØÂá∫Â§±Êïó: " + data.message, "error");
                    } else {
                        showStatus("ÊàêÂäüÂåØÂá∫Âà∞ Joplin", "success");
                    }
                } catch (error) {
                    console.error("Export error:", error);
                    showStatus("ÂåØÂá∫ÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            let currentBookDetailsId = null;
            let currentViewingBookId = null;

            async function viewBookDetails(bookId) {
                try {
                    currentViewingBookId = bookId;
                    currentBookDetailsId = bookId;
                    showStatus("ËºâÂÖ•Êõ∏Á±çÁ´†ÁØÄ...", "");

                    // Switch to chapters tab
                    switchTab("chapters");

                    // Load chapters
                    await loadChaptersForBook(bookId);

                    // Show back button and reformat button
                    document.getElementById("backToBooksBtn").style.display =
                        "inline-block";
                    document.getElementById(
                        "reformatChaptersBtn"
                    ).style.display = "inline-block";

                    showStatus("Á´†ÁØÄÂ∑≤ËºâÂÖ•", "success");
                } catch (error) {
                    console.error("Error loading book chapters:", error);
                    showStatus("ËºâÂÖ•Á´†ÁØÄÂ§±Êïó: " + error.message, "error");
                }
            }

            function backToBooks() {
                currentViewingBookId = null;
                document.getElementById("backToBooksBtn").style.display =
                    "none";
                document.getElementById("reformatChaptersBtn").style.display =
                    "none";
                document.getElementById("chaptersTabTitle").textContent =
                    "Á´†ÁØÄÂàóË°®";
                document.getElementById("chaptersList").innerHTML = "";
                switchTab("books");
            }

            async function reformatAllChapters() {
                if (!currentViewingBookId) {
                    showStatus("Ê≤íÊúâÊ≠£Âú®Êü•ÁúãÁöÑÊõ∏Á±ç", "error");
                    return;
                }

                if (
                    !confirm(
                        "Á¢∫ÂÆöË¶ÅÈáçÊñ∞Ê†ºÂºèÂåñÊ≠§Êõ∏Á±çÁöÑÊâÄÊúâÁ´†ÁØÄÂóéÔºüÈÄôÂ∞áÊõ¥Êñ∞ÊâÄÊúâÁ´†ÁØÄÁöÑÊ†ºÂºè„ÄÇ"
                    )
                ) {
                    return;
                }

                try {
                    showStatus("Ê≠£Âú®ÈáçÊñ∞Ê†ºÂºèÂåñÁ´†ÁØÄ...", "");

                    const response = await fetch(
                        `/api/books/${currentViewingBookId}/reformat-chapters`,
                        {
                            method: "POST",
                        }
                    );

                    const data = await response.json();

                    if (data.error) {
                        showStatus("ÈáçÊñ∞Ê†ºÂºèÂåñÂ§±Êïó: " + data.message, "error");
                    } else {
                        showStatus(
                            `ÊàêÂäüÈáçÊñ∞Ê†ºÂºèÂåñ ${data.reformatted}/${
                                data.total
                            } ÂÄãÁ´†ÁØÄ${
                                data.errors > 0
                                    ? ` (${data.errors} ÂÄãÈåØË™§)`
                                    : ""
                            }`,
                            "success"
                        );
                        // Reload chapters to show updated content
                        await loadChaptersForBook(currentViewingBookId);
                    }
                } catch (error) {
                    console.error("Reformat error:", error);
                    showStatus(
                        "ÈáçÊñ∞Ê†ºÂºèÂåñÊôÇÁôºÁîüÈåØË™§: " + error.message,
                        "error"
                    );
                }
            }

            async function loadChaptersForBook(bookId) {
                try {
                    // Fetch book info
                    const bookResponse = await fetch(`/api/books/${bookId}`);
                    const book = await bookResponse.json();

                    if (book.error) {
                        showStatus("ËºâÂÖ•Êõ∏Á±çË≥áË®äÂ§±Êïó: " + book.error, "error");
                        return;
                    }

                    // Update title
                    document.getElementById(
                        "chaptersTabTitle"
                    ).textContent = `Á´†ÁØÄÂàóË°® - ${
                        book.book_name_traditional ||
                        book.book_name_simplified ||
                        "Êú™Áü•Êõ∏Á±ç"
                    }`;

                    // Fetch chapters
                    const chaptersResponse = await fetch(
                        `/api/books/${bookId}/chapters`
                    );
                    const chapters = await chaptersResponse.json();

                    if (chapters.error) {
                        showStatus("ËºâÂÖ•Á´†ÁØÄÂ§±Êïó: " + chapters.error, "error");
                        return;
                    }

                    // Display chapters
                    displayChapters(chapters, book);
                } catch (error) {
                    console.error("Error loading chapters:", error);
                    showStatus("ËºâÂÖ•Á´†ÁØÄÂ§±Êïó: " + error.message, "error");
                }
            }

            function displayChapters(chapters, book) {
                const chaptersList = document.getElementById("chaptersList");

                if (!chapters || chapters.length === 0) {
                    chaptersList.innerHTML =
                        '<div class="empty-state">Ê≤íÊúâÁ´†ÁØÄ</div>';
                    return;
                }

                // Sort chapters by chapter_number
                const sortedChapters = [...chapters].sort((a, b) => {
                    const numA =
                        a.chapter_number !== null ? a.chapter_number : 999999;
                    const numB =
                        b.chapter_number !== null ? b.chapter_number : 999999;
                    return numA - numB;
                });

                let html = `
                    <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                        <h4>Êõ∏Á±çË≥áË®ä</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                            <div><strong>Êõ∏ÂêçÔºàÁ∞°È´îÔºâ:</strong> ${
                                book.book_name_simplified || "Êú™Áü•"
                            }</div>
                            <div><strong>Êõ∏ÂêçÔºàÁπÅÈ´îÔºâ:</strong> ${
                                book.book_name_traditional || "Êú™Áü•"
                            }</div>
                            <div><strong>‰ΩúËÄÖ:</strong> ${
                                book.author || "Êú™Áü•"
                            }</div>
                            <div><strong>ÂàÜÈ°û:</strong> ${
                                book.category || "Êú™Áü•"
                            }</div>
                            <div><strong>Á∏ΩÁ´†ÁØÄÊï∏:</strong> ${
                                book.total_chapters || 0
                            }</div>
                            <div><strong>‰æÜÊ∫êÁ∂≤ÂùÄ:</strong> ${
                                book.source_url
                                    ? `<a href="${book.source_url}" target="_blank">Êü•Áúã</a>`
                                    : "ÁÑ°"
                            }</div>
                        </div>
                        ${
                            book.description
                                ? `<div style="margin-top: 10px;"><strong>ÊèèËø∞:</strong><br/>${book.description}</div>`
                                : ""
                        }
                        ${
                            book.tags && book.tags.length > 0
                                ? `<div style="margin-top: 10px;"><strong>Ê®ôÁ±§:</strong> ${book.tags.join(
                                      ", "
                                  )}</div>`
                                : ""
                        }
                    </div>
                    <div>
                        <h4>Á´†ÁØÄÂàóË°® (${sortedChapters.length} ÂÄãÁ´†ÁØÄ)</h4>
                        <div style="margin-top: 10px;">
                `;

                sortedChapters.forEach((chapter) => {
                    const statusClass =
                        chapter.status === "downloaded"
                            ? "success"
                            : chapter.status === "failed"
                            ? "error"
                            : "";
                    const hasContent =
                        chapter.content && chapter.content.trim().length > 0;

                    html += `
                        <div class="chapter-item" style="padding: 15px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">
                                        Á¨¨${
                                            chapter.chapter_number !== null
                                                ? chapter.chapter_number
                                                : "Êú™Áü•"
                                        }Á´†
                                        ${
                                            chapter.chapter_title ||
                                            chapter.chapter_title_simplified
                                                ? ` - ${
                                                      chapter.chapter_title ||
                                                      chapter.chapter_title_simplified
                                                  }`
                                                : ""
                                        }
                                    </div>
                                    <div style="color: #666; font-size: 14px; margin-bottom: 5px;">
                                        <span class="status ${statusClass}">${
                        chapter.status === "downloaded"
                            ? "Â∑≤‰∏ãËºâ"
                            : chapter.status === "failed"
                            ? "Â§±Êïó"
                            : chapter.status || "Êú™Áü•"
                    }</span>
                                        ${
                                            hasContent
                                                ? `<span style="margin-left: 10px;">ÂÖßÂÆπ: ${chapter.content.length} Â≠óÂÖÉ</span>`
                                                : '<span style="margin-left: 10px; color: #999;">ÁÑ°ÂÖßÂÆπ</span>'
                                        }
                                    </div>
                                    ${
                                        chapter.cool18_url
                                            ? `<div style="margin-top: 5px;"><a href="${chapter.cool18_url}" target="_blank" style="color: #007bff;">Êü•ÁúãÂéüÊñá</a></div>`
                                            : ""
                                    }
                                </div>
                                <div style="display: flex; gap: 5px; margin-left: 10px;">
                                    ${
                                        hasContent
                                            ? `<button class="button" onclick="viewChapterContent(${chapter.id}, ${currentViewingBookId})">Êü•ÁúãÂÖßÂÆπ</button>`
                                            : ""
                                    }
                                    <button class="button" onclick="editChapter(${
                                        chapter.id
                                    }, ${currentViewingBookId})">Á∑®ËºØ</button>
                                    <button class="button error" onclick="deleteChapter(${
                                        chapter.id
                                    }, ${currentViewingBookId})">Âà™Èô§</button>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += "</div></div>";
                chaptersList.innerHTML = html;
            }

            async function refreshChapters() {
                if (currentViewingBookId) {
                    await loadChaptersForBook(currentViewingBookId);
                } else {
                    showStatus("Ê≤íÊúâÊ≠£Âú®Êü•ÁúãÁöÑÊõ∏Á±ç", "error");
                }
            }

            async function viewChapterContent(chapterId, bookId) {
                try {
                    showStatus("ËºâÂÖ•Á´†ÁØÄÂÖßÂÆπ...", "");
                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`
                    );
                    const chapter = await response.json();

                    if (chapter.error) {
                        showStatus(
                            "ËºâÂÖ•Á´†ÁØÄÂÖßÂÆπÂ§±Êïó: " + chapter.error,
                            "error"
                        );
                        return;
                    }

                    // Create modal for viewing chapter content
                    let modalHtml = `
                        <div id="chapterContentModal" class="modal active">
                            <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
                                <div class="progress-header">
                                    <h3>Á´†ÁØÄÂÖßÂÆπ - Á¨¨${
                                        chapter.chapter_number !== null
                                            ? chapter.chapter_number
                                            : "Êú™Áü•"
                                    }Á´†</h3>
                                    <button class="close-button" onclick="closeChapterContentModal()">&times;</button>
                                </div>
                                <div style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 100px);">
                                    <div style="margin-bottom: 15px;">
                                        <strong>Á´†ÁØÄÊ®ôÈ°å:</strong> ${
                                            chapter.chapter_title ||
                                            chapter.chapter_title_simplified ||
                                            "ÁÑ°Ê®ôÈ°å"
                                        }
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <strong>Á´†ÁØÄÁ∑®Ëôü:</strong> ${
                                            chapter.chapter_number !== null
                                                ? chapter.chapter_number
                                                : "Êú™Áü•"
                                        }
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <strong>ÁãÄÊÖã:</strong> <span class="status ${
                                            chapter.status === "downloaded"
                                                ? "success"
                                                : chapter.status === "failed"
                                                ? "error"
                                                : ""
                                        }">${
                        chapter.status === "downloaded"
                            ? "Â∑≤‰∏ãËºâ"
                            : chapter.status === "failed"
                            ? "Â§±Êïó"
                            : chapter.status || "Êú™Áü•"
                    }</span>
                                    </div>
                                    ${
                                        chapter.cool18_url
                                            ? `<div style="margin-bottom: 15px;"><strong>‰æÜÊ∫ê:</strong> <a href="${chapter.cool18_url}" target="_blank">Êü•ÁúãÂéüÊñá</a></div>`
                                            : ""
                                    }
                                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; white-space: pre-wrap; line-height: 1.6;">
                                        ${chapter.content || "ÁÑ°ÂÖßÂÆπ"}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Remove existing modal if any
                    const existingModal = document.getElementById(
                        "chapterContentModal"
                    );
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Add modal to body
                    document.body.insertAdjacentHTML("beforeend", modalHtml);
                } catch (error) {
                    console.error("Error loading chapter content:", error);
                    showStatus("ËºâÂÖ•Á´†ÁØÄÂÖßÂÆπÂ§±Êïó: " + error.message, "error");
                }
            }

            function closeChapterContentModal() {
                const modal = document.getElementById("chapterContentModal");
                if (modal) {
                    modal.remove();
                }
            }

            async function editChapter(chapterId, bookId) {
                try {
                    showStatus("ËºâÂÖ•Á´†ÁØÄË≥áË®ä...", "");
                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`
                    );
                    const chapter = await response.json();

                    if (chapter.error) {
                        showStatus(
                            "ËºâÂÖ•Á´†ÁØÄË≥áË®äÂ§±Êïó: " + chapter.error,
                            "error"
                        );
                        return;
                    }

                    // Create modal for editing chapter
                    let modalHtml = `
                        <div id="chapterEditModal" class="modal active">
                            <div class="modal-content" style="max-width: 700px;">
                                <div class="progress-header">
                                    <h3>Á∑®ËºØÁ´†ÁØÄ</h3>
                                    <button class="close-button" onclick="closeChapterEditModal()">&times;</button>
                                </div>
                                <div style="padding: 20px;">
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>Á´†ÁØÄÁ∑®Ëôü:</strong></label>
                                        <input type="number" id="editChapterNumber" value="${
                                            chapter.chapter_number !== null
                                                ? chapter.chapter_number
                                                : ""
                                        }" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>Á´†ÁØÄÊ®ôÈ°åÔºàÁπÅÈ´îÔºâ:</strong></label>
                                        <input type="text" id="editChapterTitle" value="${
                                            chapter.chapter_title || ""
                                        }" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>Á´†ÁØÄÊ®ôÈ°åÔºàÁ∞°È´îÔºâ:</strong></label>
                                        <input type="text" id="editChapterTitleSimplified" value="${
                                            chapter.chapter_title_simplified ||
                                            ""
                                        }" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>ÁãÄÊÖã:</strong></label>
                                        <select id="editChapterStatus" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                            <option value="pending" ${
                                                chapter.status === "pending"
                                                    ? "selected"
                                                    : ""
                                            }>ÂæÖËôïÁêÜ</option>
                                            <option value="downloaded" ${
                                                chapter.status === "downloaded"
                                                    ? "selected"
                                                    : ""
                                            }>Â∑≤‰∏ãËºâ</option>
                                            <option value="failed" ${
                                                chapter.status === "failed"
                                                    ? "selected"
                                                    : ""
                                            }>Â§±Êïó</option>
                                        </select>
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label><strong>ÂÖßÂÆπ:</strong></label>
                                        <textarea id="editChapterContent" rows="10" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">${(
                                            chapter.content || ""
                                        )
                                            .replace(/&/g, "&amp;")
                                            .replace(/</g, "&lt;")
                                            .replace(/>/g, "&gt;")
                                            .replace(/"/g, "&quot;")
                                            .replace(/'/g, "&#39;")}</textarea>
                                    </div>
                                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                        <button class="button secondary" onclick="closeChapterEditModal()">ÂèñÊ∂à</button>
                                        <button class="button success" onclick="saveChapterEdit(${chapterId}, ${bookId})">ÂÑ≤Â≠ò</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Remove existing modal if any
                    const existingModal =
                        document.getElementById("chapterEditModal");
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Add modal to body
                    document.body.insertAdjacentHTML("beforeend", modalHtml);
                } catch (error) {
                    console.error("Error loading chapter for edit:", error);
                    showStatus("ËºâÂÖ•Á´†ÁØÄË≥áË®äÂ§±Êïó: " + error.message, "error");
                }
            }

            function closeChapterEditModal() {
                const modal = document.getElementById("chapterEditModal");
                if (modal) {
                    modal.remove();
                }
            }

            async function saveChapterEdit(chapterId, bookId) {
                try {
                    const chapterNumber =
                        document.getElementById("editChapterNumber").value;
                    const chapterTitle =
                        document.getElementById("editChapterTitle").value;
                    const chapterTitleSimplified = document.getElementById(
                        "editChapterTitleSimplified"
                    ).value;
                    const chapterStatus =
                        document.getElementById("editChapterStatus").value;
                    const chapterContent =
                        document.getElementById("editChapterContent").value;

                    showStatus("ÂÑ≤Â≠ò‰∏≠...", "");

                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`,
                        {
                            method: "PUT",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                chapter_number: chapterNumber
                                    ? parseInt(chapterNumber)
                                    : null,
                                chapter_title: chapterTitle || null,
                                chapter_title_simplified:
                                    chapterTitleSimplified || null,
                                status: chapterStatus,
                                content: chapterContent || null,
                            }),
                        }
                    );

                    const data = await response.json();

                    if (data.error) {
                        showStatus(
                            "ÂÑ≤Â≠òÂ§±Êïó: " + (data.message || data.error),
                            "error"
                        );
                        return;
                    }

                    closeChapterEditModal();
                    showStatus("Á´†ÁØÄÂ∑≤Êõ¥Êñ∞", "success");

                    // Refresh chapters list
                    if (currentViewingBookId) {
                        await loadChaptersForBook(currentViewingBookId);
                    }
                } catch (error) {
                    console.error("Error saving chapter:", error);
                    showStatus("ÂÑ≤Â≠òÂ§±Êïó: " + error.message, "error");
                }
            }

            async function deleteChapter(chapterId, bookId) {
                if (!confirm("Á¢∫ÂÆöË¶ÅÂà™Èô§Ê≠§Á´†ÁØÄÂóéÔºüÊ≠§Êìç‰ΩúÁÑ°Ê≥ïÂæ©Âéü„ÄÇ")) {
                    return;
                }

                try {
                    showStatus("Âà™Èô§‰∏≠...", "");
                    const response = await fetch(
                        `/api/books/${bookId}/chapters/${chapterId}`,
                        {
                            method: "DELETE",
                        }
                    );

                    const data = await response.json();

                    if (data.error) {
                        showStatus(
                            "Âà™Èô§Â§±Êïó: " + (data.message || data.error),
                            "error"
                        );
                        return;
                    }

                    showStatus("Á´†ÁØÄÂ∑≤Âà™Èô§", "success");

                    // Refresh chapters list
                    if (currentViewingBookId) {
                        await loadChaptersForBook(currentViewingBookId);
                    }
                } catch (error) {
                    console.error("Error deleting chapter:", error);
                    showStatus("Âà™Èô§Â§±Êïó: " + error.message, "error");
                }
            }

            async function deleteBook(bookId) {
                if (
                    !confirm(
                        "Á¢∫ÂÆöË¶ÅÂà™Èô§Ê≠§Êõ∏Á±çÂóéÔºüÊ≠§Êìç‰ΩúÂ∞áÂêåÊôÇÂà™Èô§ÊâÄÊúâÁõ∏ÈóúÁ´†ÁØÄÔºå‰∏îÁÑ°Ê≥ïÂæ©Âéü„ÄÇ"
                    )
                ) {
                    return;
                }

                try {
                    showStatus("Âà™Èô§‰∏≠...", "");
                    const response = await fetch(`/api/books/${bookId}`, {
                        method: "DELETE",
                    });

                    const data = await response.json();

                    if (data.error) {
                        showStatus(
                            "Âà™Èô§Â§±Êïó: " + (data.message || data.error),
                            "error"
                        );
                        return;
                    }

                    showStatus("Êõ∏Á±çÂ∑≤Âà™Èô§", "success");

                    // Refresh books list
                    await refreshBooks();

                    // If we're viewing this book's chapters, go back to books tab
                    if (currentViewingBookId === bookId) {
                        backToBooks();
                    }
                } catch (error) {
                    console.error("Error deleting book:", error);
                    showStatus("Âà™Èô§Â§±Êïó: " + error.message, "error");
                }
            }

            function closeBookDetailsModal() {
                document
                    .getElementById("bookDetailsModal")
                    .classList.remove("active");
                currentBookDetailsId = null;
            }

            async function rescanBookChapters() {
                if (!currentBookDetailsId) {
                    showStatus("Ê≤íÊúâÈÅ∏‰∏≠ÁöÑÊõ∏Á±ç", "error");
                    return;
                }

                const rescanBtn = document.getElementById("rescanChaptersBtn");
                const originalText = rescanBtn.textContent;
                rescanBtn.disabled = true;
                rescanBtn.textContent = "ÊéÉÊèè‰∏≠...";

                try {
                    showStatus("Ê≠£Âú®ÈáçÊñ∞ÊéÉÊèèÁ´†ÁØÄË≥áË®ä...", "");
                    const response = await fetch(
                        `/api/books/${currentBookDetailsId}/rescan-chapters`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        }
                    );

                    const data = await response.json();
                    if (data.error) {
                        showStatus("ÈáçÊñ∞ÊéÉÊèèÂ§±Êïó: " + data.message, "error");
                    } else {
                        showStatus(
                            data.message || `Â∑≤Êõ¥Êñ∞ ${data.updated} ÂÄãÁ´†ÁØÄ`,
                            "success"
                        );
                        // Reload book details to show updated information
                        await viewBookDetails(currentBookDetailsId);
                        // Also reload books list
                        await loadBooks();
                    }
                } catch (error) {
                    console.error("Error rescanning chapters:", error);
                    showStatus("ÈáçÊñ∞ÊéÉÊèèÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                } finally {
                    rescanBtn.disabled = false;
                    rescanBtn.textContent = originalText;
                }
            }

            async function editBookMetadata(bookId) {
                try {
                    const response = await fetch(`/api/books/${bookId}`);
                    const book = await response.json();

                    if (book.error) {
                        showStatus("ËºâÂÖ•Êõ∏Á±çË≥áË®äÂ§±Êïó: " + book.error, "error");
                        return;
                    }

                    // Populate form with existing book data
                    document.getElementById("metadataBookName").value =
                        book.book_name_simplified || "";
                    document.getElementById(
                        "metadataBookNameTraditional"
                    ).value = book.book_name_traditional || "";
                    document.getElementById("metadataAuthor").value =
                        book.author || "";
                    document.getElementById("metadataCategory").value =
                        book.category || "";
                    document.getElementById("metadataTags").value = (
                        book.tags || []
                    ).join(", ");
                    document.getElementById("metadataDescription").value =
                        book.description || "";
                    document.getElementById("metadataSourceUrl").value =
                        book.source_url || "";

                    // Store book ID for update
                    pendingDownloadData = { bookId, isEdit: true };

                    // Update modal title and button
                    const modalTitle = document.querySelector(
                        "#bookMetadataModal .progress-header h3"
                    );
                    const confirmButton = document.querySelector(
                        '#bookMetadataModal button[onclick="confirmBookMetadata()"]'
                    );
                    modalTitle.textContent = "Á∑®ËºØÊõ∏Á±çË≥áË®ä";
                    confirmButton.textContent = "Á¢∫Ë™çÊõ¥Êñ∞";

                    // Show modal
                    document
                        .getElementById("bookMetadataModal")
                        .classList.add("active");
                } catch (error) {
                    console.error("Error loading book:", error);
                    showStatus(
                        "ËºâÂÖ•Êõ∏Á±çË≥áË®äÊôÇÁôºÁîüÈåØË™§: " + error.message,
                        "error"
                    );
                }
            }

            async function searchMissingChapters(bookId) {
                try {
                    showStatus("Ê≠£Âú®ÂàÜÊûêÁº∫Â§±Á´†ÁØÄ...", "");

                    // First, get missing chapters
                    const missingResponse = await fetch(
                        `/api/books/${bookId}/missing-chapters`
                    );
                    const missingData = await missingResponse.json();

                    if (missingData.error) {
                        showStatus("ÂàÜÊûêÂ§±Êïó: " + missingData.error, "error");
                        return;
                    }

                    if (missingData.missingChapters.length === 0) {
                        showStatus("Ê≤íÊúâÁôºÁèæÁº∫Â§±Á´†ÁØÄÔºÅ", "success");
                        return;
                    }

                    // Get book info
                    const bookResponse = await fetch(`/api/books/${bookId}`);
                    const book = await bookResponse.json();

                    showStatus(
                        `ÁôºÁèæ ${missingData.missingChapters.length} ÂÄãÁº∫Â§±Á´†ÁØÄÔºåÊ≠£Âú®ÊêúÂ∞ã...`,
                        ""
                    );

                    // Search for missing chapters
                    const searchResponse = await fetch(
                        `/api/books/${bookId}/search-missing`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                missingChapters: missingData.missingChapters,
                                bookName: book.book_name_simplified,
                            }),
                        }
                    );

                    const searchData = await searchResponse.json();

                    if (searchData.error) {
                        showStatus("ÊêúÂ∞ãÂ§±Êïó: " + searchData.error, "error");
                        return;
                    }

                    // Show results in modal
                    showMissingChaptersModal(bookId, missingData, searchData);
                } catch (error) {
                    console.error("Error searching missing chapters:", error);
                    showStatus("ÊêúÂ∞ãÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            function showMissingChaptersModal(bookId, missingData, searchData) {
                const modal = document.getElementById("missingChaptersModal");
                const content = document.getElementById(
                    "missingChaptersContent"
                );

                let html = `
                <div style="margin-bottom: 20px;">
                    <h4>Áº∫Â§±Á´†ÁØÄÂàÜÊûê</h4>
                    <p>Á∏ΩÁ´†ÁØÄÁØÑÂúç: Á¨¨${missingData.minChapter}Á´† ~ Á¨¨${missingData.maxChapter}Á´†</p>
                    <p>Â∑≤‰∏ãËºâ: ${missingData.totalChapters} Á´†</p>
                    <p>Áº∫Â§±: ${missingData.missingChapters.length} Á´†</p>
                </div>
            `;

                if (searchData.foundChapters.length === 0) {
                    html += `
                    <div style="padding: 20px; background: #fff3cd; border-radius: 4px; margin-bottom: 20px;">
                        <p>Êú™ÊâæÂà∞‰ªª‰ΩïÁº∫Â§±Á´†ÁØÄÁöÑÁµêÊûú„ÄÇ</p>
                        <p>Áº∫Â§±ÁöÑÁ´†ÁØÄ: ${missingData.missingChapters.join(
                            ", "
                        )}</p>
                    </div>
                `;
                } else {
                    html += `
                    <div style="margin-bottom: 20px;">
                        <h4>ÊâæÂà∞ ${searchData.foundChapters.length} ÂÄãÁ´†ÁØÄ</h4>
                        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                `;

                    const selectedChapters = new Set();
                    searchData.foundChapters.forEach((ch) => {
                        const isMulti = ch.isMultiChapter ? " (Â§öÁ´†ÁØÄ)" : "";
                        html += `
                        <div style="padding: 10px; border-bottom: 1px solid #eee;">
                            <label style="display: flex; align-items: start; cursor: pointer;">
                                <input type="checkbox" value="${
                                    ch.url
                                }" data-chapter="${ch.chapterNumber}" 
                                    style="margin-right: 10px; margin-top: 3px;" 
                                    onchange="toggleMissingChapter(this, ${
                                        ch.chapterNumber
                                    })">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold;">Á¨¨${
                                        ch.chapterNumber
                                    }Á´†${isMulti}</div>
                                    <div style="color: #666; font-size: 14px; margin-top: 5px;">${
                                        ch.title
                                    }</div>
                                    ${
                                        ch.isMultiChapter
                                            ? `<div style="color: #007bff; font-size: 12px; margin-top: 3px;">ÂåÖÂê´Á´†ÁØÄ: ${
                                                  ch.range ||
                                                  ch.chapters.join(", ")
                                              }</div>`
                                            : ""
                                    }
                                    <div style="color: #999; font-size: 12px; margin-top: 3px;">${
                                        ch.date || ""
                                    }</div>
                                </div>
                            </label>
                        </div>
                    `;
                    });

                    html += `
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeMissingChaptersModal()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">ÂèñÊ∂à</button>
                        <button onclick="downloadMissingChapters(${bookId})" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">‰∏ãËºâÈÅ∏‰∏≠ÁöÑÁ´†ÁØÄ</button>
                    </div>
                `;
                }

                content.innerHTML = html;
                window.missingChaptersData = { bookId, searchData };
                modal.classList.add("active");
            }

            function closeMissingChaptersModal() {
                document
                    .getElementById("missingChaptersModal")
                    .classList.remove("active");
                window.missingChaptersData = null;
            }

            function toggleMissingChapter(checkbox, chapterNumber) {
                if (!window.missingChaptersData) return;
                // This is handled by the checkbox state
            }

            async function downloadMissingChapters(bookId) {
                if (!window.missingChaptersData) return;

                const checkboxes = document.querySelectorAll(
                    '#missingChaptersContent input[type="checkbox"]:checked'
                );
                if (checkboxes.length === 0) {
                    showStatus("Ë´ãËá≥Â∞ëÈÅ∏Êìá‰∏ÄÂÄãÁ´†ÁØÄ", "error");
                    return;
                }

                const chapters = Array.from(checkboxes).map((cb) => {
                    const chapterData =
                        window.missingChaptersData.searchData.foundChapters.find(
                            (ch) => ch.url === cb.value
                        );
                    return {
                        url: cb.value,
                        title: chapterData.title,
                        chapterNum: parseInt(cb.dataset.chapter),
                    };
                });

                closeMissingChaptersModal();

                // Get book name
                const bookResponse = await fetch(`/api/books/${bookId}`);
                const book = await bookResponse.json();

                proceedWithDownload(
                    chapters,
                    bookId,
                    book.book_name_simplified,
                    null
                );
            }

            async function searchDownChapters(bookId) {
                try {
                    showStatus("Ê≠£Âú®Âêë‰∏ãÊêúÂ∞ãÁ´†ÁØÄÔºàÊúÄÂ§ö5È†ÅÔºåÁõ¥Âà∞Á¨¨1Á´†Ôºâ...", "");

                    const searchResponse = await fetch(
                        `/api/books/${bookId}/search-down`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        }
                    );

                    const searchData = await searchResponse.json();

                    if (searchData.error) {
                        showStatus("ÊêúÂ∞ãÂ§±Êïó: " + searchData.error, "error");
                        return;
                    }

                    if (searchData.foundChapters.length === 0) {
                        showStatus(`Êú™ÊâæÂà∞‰ªª‰ΩïËºÉ‰ΩéÁ∑®ËôüÁöÑÁ´†ÁØÄÔºàÁï∂ÂâçÊúÄ‰ΩéÔºöÁ¨¨${searchData.minChapter}Á´†Ôºâ`, "success");
                        return;
                    }

                    // Show results in modal
                    showSearchResultsModal(bookId, searchData, "Âêë‰∏ãÊêúÂ∞ãÁµêÊûú", `ÊâæÂà∞ ${searchData.foundChapters.length} ÂÄãËºÉ‰ΩéÁ∑®ËôüÁöÑÁ´†ÁØÄÔºàÁï∂ÂâçÊúÄ‰ΩéÔºöÁ¨¨${searchData.minChapter}Á´†Ôºâ`);
                } catch (error) {
                    console.error("Error searching down for chapters:", error);
                    showStatus("ÊêúÂ∞ãÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            async function searchNewChapters(bookId) {
                try {
                    showStatus("Ê≠£Âú®ÊêúÂ∞ãÊñ∞Á´†ÁØÄÔºàÊúÄÂ§ö3È†ÅÔºâ...", "");

                    const searchResponse = await fetch(
                        `/api/books/${bookId}/search-new`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        }
                    );

                    const searchData = await searchResponse.json();

                    if (searchData.error) {
                        showStatus("ÊêúÂ∞ãÂ§±Êïó: " + searchData.error, "error");
                        return;
                    }

                    if (searchData.foundChapters.length === 0) {
                        showStatus(`Êú™ÊâæÂà∞‰ªª‰ΩïÊñ∞Á´†ÁØÄÔºàÁï∂ÂâçÊúÄÈ´òÔºöÁ¨¨${searchData.maxChapter}Á´†Ôºâ`, "success");
                        return;
                    }

                    // Show results in modal
                    showSearchResultsModal(bookId, searchData, "ÊêúÂ∞ãÊñ∞Á´†ÁØÄÁµêÊûú", `ÊâæÂà∞ ${searchData.foundChapters.length} ÂÄãÊñ∞Á´†ÁØÄÔºàÁï∂ÂâçÊúÄÈ´òÔºöÁ¨¨${searchData.maxChapter}Á´†Ôºâ`);
                } catch (error) {
                    console.error("Error searching for new chapters:", error);
                    showStatus("ÊêúÂ∞ãÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            function showSearchResultsModal(bookId, searchData, title, description) {
                // Create or reuse modal
                let modal = document.getElementById("searchResultsModal");
                if (!modal) {
                    modal = document.createElement("div");
                    modal.id = "searchResultsModal";
                    modal.className = "modal";
                    modal.innerHTML = `
                        <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
                            <div class="progress-header">
                                <h3 id="searchResultsTitle">${title}</h3>
                                <button class="close-button" onclick="closeSearchResultsModal()">&times;</button>
                            </div>
                            <div id="searchResultsContent" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 100px);"></div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                }

                const content = document.getElementById("searchResultsContent");
                const titleElement = document.getElementById("searchResultsTitle");
                if (titleElement) {
                    titleElement.textContent = title;
                }

                let html = `
                    <div style="margin-bottom: 20px;">
                        <p>${description}</p>
                        <p style="color: #666; font-size: 14px;">
                            Â∑≤ÊêúÂ∞ã ${searchData.pagesSearched} È†Å
                            ${searchData.authorSearched ? `ÔºàÊõ∏ÂêçÔºö${searchData.searchKeyword}Ôºå‰ΩúËÄÖÔºö${searchData.authorSearched}Ôºâ` : `ÔºàÊõ∏ÂêçÔºö${searchData.searchKeyword}Ôºâ`}
                        </p>
                    </div>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                `;

                searchData.foundChapters.forEach((ch) => {
                    const isMulti = ch.isMultiChapter ? " (Â§öÁ´†ÁØÄ)" : "";
                    html += `
                        <div style="padding: 10px; border-bottom: 1px solid #eee;">
                            <label style="display: flex; align-items: start; cursor: pointer;">
                                <input type="checkbox" value="${ch.url}" data-chapter="${ch.chapterNumber}" 
                                    style="margin-right: 10px; margin-top: 3px;" 
                                    checked>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold;">Á¨¨${ch.chapterNumber}Á´†${isMulti}</div>
                                    <div style="color: #666; font-size: 14px; margin-top: 5px;">${ch.title}</div>
                                    ${ch.isMultiChapter
                                        ? `<div style="color: #007bff; font-size: 12px; margin-top: 3px;">ÂåÖÂê´Á´†ÁØÄ: ${ch.range || ch.chapters.join(", ")}</div>`
                                        : ""
                                    }
                                    <div style="color: #999; font-size: 12px; margin-top: 3px;">${ch.date || ""}</div>
                                    <div style="margin-top: 5px;"><a href="${ch.url}" target="_blank" style="color: #007bff; font-size: 12px;">Êü•ÁúãÂéüÊñá</a></div>
                                </div>
                            </label>
                        </div>
                    `;
                });

                html += `
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                        <button onclick="closeSearchResultsModal()" class="button secondary">ÂèñÊ∂à</button>
                        <button onclick="downloadSearchResults(${bookId})" class="button success">‰∏ãËºâÈÅ∏‰∏≠ÁöÑÁ´†ÁØÄ</button>
                    </div>
                `;

                content.innerHTML = html;
                window.searchResultsData = { bookId, searchData };
                modal.classList.add("active");
            }

            function closeSearchResultsModal() {
                const modal = document.getElementById("searchResultsModal");
                if (modal) {
                    modal.classList.remove("active");
                }
                window.searchResultsData = null;
            }

            async function downloadSearchResults(bookId) {
                if (!window.searchResultsData) return;

                const checkboxes = document.querySelectorAll(
                    '#searchResultsContent input[type="checkbox"]:checked'
                );
                if (checkboxes.length === 0) {
                    showStatus("Ë´ãËá≥Â∞ëÈÅ∏Êìá‰∏ÄÂÄãÁ´†ÁØÄ", "error");
                    return;
                }

                const chapters = Array.from(checkboxes).map((cb) => {
                    const chapterData =
                        window.searchResultsData.searchData.foundChapters.find(
                            (ch) => ch.url === cb.value
                        );
                    return {
                        url: cb.value,
                        title: chapterData.title,
                        chapterNum: parseInt(cb.dataset.chapter),
                    };
                });

                closeSearchResultsModal();

                // Get book name
                const bookResponse = await fetch(`/api/books/${bookId}`);
                const book = await bookResponse.json();

                proceedWithDownload(
                    chapters,
                    bookId,
                    book.book_name_simplified,
                    null
                );
            }

            function refreshBooks() {
                console.log("Refreshing books...");
                loadBooks()
                    .then(() => {
                        console.log(
                            "Books refreshed, total books:",
                            books.length
                        );
                        showStatus(
                            `Â∑≤ÈáçÊñ∞Êï¥ÁêÜÔºåÂÖ± ${books.length} Êú¨Êõ∏Á±ç`,
                            "success"
                        );
                    })
                    .catch((error) => {
                        console.error("Error refreshing books:", error);
                        showStatus("ÈáçÊñ∞Êï¥ÁêÜÂ§±Êïó: " + error.message, "error");
                    });
            }

            let statusHideTimeout = null;

            function showStatus(message, type = "") {
                const statusDiv = document.getElementById("status");
                if (!statusDiv) {
                    console.warn(
                        "Status element not found when showing status",
                        { message, type }
                    );
                    console.error("Status message:", message, "Type:", type);
                    return;
                }

                // Clear any existing timeout
                if (statusHideTimeout) {
                    clearTimeout(statusHideTimeout);
                    statusHideTimeout = null;
                }

                statusDiv.style.display = "block";
                statusDiv.className = "status " + type;
                statusDiv.textContent = message;

                // Only auto-hide success messages, not errors
                if (type === "success") {
                    statusHideTimeout = setTimeout(() => {
                        if (statusDiv) {
                            statusDiv.style.display = "none";
                        }
                        statusHideTimeout = null;
                    }, 5000);
                }
                // Errors stay visible until manually dismissed or new message shown
            }

            // Download Progress
            let progressEventSource = null;

            function showDownloadProgress(jobId, totalChapters) {
                const modal = document.getElementById("progressModal");
                const progressBar = document.getElementById("progressBar");
                const progressLogs = document.getElementById("progressLogs");
                const progressCompleted =
                    document.getElementById("progressCompleted");
                const progressTotal = document.getElementById("progressTotal");
                const progressFailed =
                    document.getElementById("progressFailed");

                modal.classList.add("active");
                progressBar.style.width = "0%";
                progressBar.textContent = "0%";
                progressLogs.innerHTML = "";
                progressCompleted.textContent = "0";
                progressTotal.textContent = totalChapters || "0";
                progressFailed.textContent = "0";

                // Close any existing connection
                if (progressEventSource) {
                    progressEventSource.close();
                }

                // Connect to SSE stream
                progressEventSource = new EventSource(
                    `/api/download/${jobId}/stream`
                );

                progressEventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleProgressUpdate(
                            data,
                            progressBar,
                            progressLogs,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                    } catch (error) {
                        console.error("Error parsing progress data:", error);
                    }
                };

                progressEventSource.onerror = (error) => {
                    console.error("SSE error:", error);
                    addProgressLog(
                        progressLogs,
                        "ÈÄ£Êé•ÈåØË™§ÔºåË´ãÂà∑Êñ∞È†ÅÈù¢Êü•ÁúãÁãÄÊÖã",
                        "error"
                    );
                };
            }

            function handleProgressUpdate(
                data,
                progressBar,
                progressLogs,
                progressCompleted,
                progressTotal,
                progressFailed,
                totalChapters
            ) {
                switch (data.type) {
                    case "connected":
                        addProgressLog(
                            progressLogs,
                            "Â∑≤ÈÄ£Êé•Âà∞‰∏ãËºâÊúçÂãô",
                            "success"
                        );
                        break;
                    case "job-start":
                        addProgressLog(progressLogs, data.message, "success");
                        break;
                    case "chapter-start":
                        addProgressLog(progressLogs, data.message);
                        break;
                    case "chapter-complete":
                        addProgressLog(progressLogs, data.message, "success");
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        break;
                    case "chapter-skipped":
                        addProgressLog(progressLogs, data.message);
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        break;
                    case "chapter-error":
                        addProgressLog(progressLogs, data.message, "error");
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        break;
                    case "job-complete":
                        addProgressLog(progressLogs, data.message, "success");
                        updateProgress(
                            progressBar,
                            progressCompleted,
                            progressTotal,
                            progressFailed,
                            totalChapters
                        );
                        if (progressEventSource) {
                            progressEventSource.close();
                            progressEventSource = null;
                        }
                        // Auto-close after 3 seconds
                        setTimeout(() => {
                            closeProgressModal();
                            loadBooks();
                        }, 3000);
                        break;
                    case "job-error":
                        addProgressLog(progressLogs, data.message, "error");
                        if (progressEventSource) {
                            progressEventSource.close();
                            progressEventSource = null;
                        }
                        break;
                }
            }

            function addProgressLog(logsContainer, message, type = "") {
                const logItem = document.createElement("div");
                logItem.className = `progress-log-item ${type}`;
                logItem.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logsContainer.appendChild(logItem);
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }

            function updateProgress(
                progressBar,
                progressCompleted,
                progressTotal,
                progressFailed,
                totalChapters
            ) {
                // Fetch current status from API
                const jobId = progressEventSource
                    ? progressEventSource.url.match(
                          /\/download\/(\d+)\/stream/
                      )[1]
                    : null;
                if (jobId) {
                    fetch(`/api/download/${jobId}/status`)
                        .then((res) => res.json())
                        .then((job) => {
                            const completed = job.completed_chapters || 0;
                            const failed = job.failed_chapters || 0;
                            const total =
                                job.total_chapters || totalChapters || 0;
                            const percentage =
                                total > 0
                                    ? Math.round((completed / total) * 100)
                                    : 0;

                            progressBar.style.width = `${percentage}%`;
                            progressBar.textContent = `${percentage}%`;
                            progressCompleted.textContent = completed;
                            progressTotal.textContent = total;
                            progressFailed.textContent = failed;
                        })
                        .catch((error) =>
                            console.error("Error fetching progress:", error)
                        );
                }
            }

            function closeProgressModal() {
                const modal = document.getElementById("progressModal");
                modal.classList.remove("active");
                if (progressEventSource) {
                    progressEventSource.close();
                    progressEventSource = null;
                }
            }

            // Upload Management
            let uploadedFiles = [];
            let currentFileAnalysis = null;
            let pendingFileForProcessing = null;

            function setupUploadArea() {
                const uploadArea = document.getElementById("uploadArea");
                const fileInput = document.getElementById("fileInput");
                const uploadTab = document.getElementById("uploadTab");

                if (!uploadArea) {
                    console.error("Upload area not found");
                    return;
                }

                let dragCounter = 0; // Track drag enter/leave to handle child elements

                // Prevent default drag behaviors on the entire page
                document.addEventListener("dragover", (e) => {
                    // Only prevent default when dragging files
                    if (
                        e.dataTransfer &&
                        e.dataTransfer.types.includes("Files")
                    ) {
                        e.preventDefault();
                    }
                });

                document.addEventListener("drop", (e) => {
                    // Only prevent default when dragging files
                    if (
                        e.dataTransfer &&
                        e.dataTransfer.types.includes("Files")
                    ) {
                        e.preventDefault();
                    }
                });

                // Drag and drop handlers for upload area
                uploadArea.addEventListener("dragenter", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragCounter++;
                    uploadArea.classList.add("dragover");
                });

                uploadArea.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Set dropEffect to show it's a valid drop target
                    e.dataTransfer.dropEffect = "copy";
                });

                uploadArea.addEventListener("dragleave", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragCounter--;
                    // Only remove dragover if we've actually left the upload area
                    if (dragCounter === 0) {
                        uploadArea.classList.remove("dragover");
                    }
                });

                uploadArea.addEventListener("drop", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragCounter = 0;
                    uploadArea.classList.remove("dragover");

                    const files = Array.from(e.dataTransfer.files);
                    if (files.length > 0) {
                        handleFiles(files);
                    }
                });

                // Also allow drag and drop on the entire upload tab area
                if (uploadTab) {
                    uploadTab.addEventListener("dragenter", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (!uploadArea.contains(e.target)) {
                                uploadArea.classList.add("dragover");
                            }
                        }
                    });

                    uploadTab.addEventListener("dragover", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.dataTransfer.dropEffect = "copy";
                            if (!uploadArea.contains(e.target)) {
                                uploadArea.classList.add("dragover");
                            }
                        }
                    });

                    uploadTab.addEventListener("dragleave", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            // Only remove if leaving the tab entirely
                            if (!uploadTab.contains(e.relatedTarget)) {
                                uploadArea.classList.remove("dragover");
                            }
                        }
                    });

                    uploadTab.addEventListener("drop", (e) => {
                        if (
                            e.dataTransfer &&
                            e.dataTransfer.types.includes("Files")
                        ) {
                            e.preventDefault();
                            e.stopPropagation();
                            uploadArea.classList.remove("dragover");

                            const files = Array.from(e.dataTransfer.files);
                            if (files.length > 0) {
                                handleFiles(files);
                            }
                        }
                    });
                }
            }

            function handleFileSelect(event) {
                const files = Array.from(event.target.files);
                handleFiles(files);
            }

            async function handleFiles(files) {
                const validFiles = files.filter((file) => {
                    const ext = file.name.split(".").pop().toLowerCase();
                    return ["txt", "html", "md"].includes(ext);
                });

                if (validFiles.length === 0) {
                    showUploadStatus(
                        "Ë´ãÈÅ∏ÊìáÊúâÊïàÁöÑÊ™îÊ°àÊ†ºÂºè (.txt, .html, .md)",
                        "error"
                    );
                    return;
                }

                showUploadStatus(`Ê≠£Âú®‰∏äÂÇ≥ ${validFiles.length} ÂÄãÊ™îÊ°à...`, "");

                for (const file of validFiles) {
                    try {
                        const formData = new FormData();
                        formData.append("file", file);

                        const response = await fetch("/api/upload", {
                            method: "POST",
                            body: formData,
                        });

                        const data = await response.json();
                        if (data.error) {
                            showUploadStatus(
                                `‰∏äÂÇ≥ ${file.name} Â§±Êïó: ${data.message}`,
                                "error"
                            );
                        } else {
                            uploadedFiles.push({
                                filename: data.filename,
                                originalName: file.name,
                                size: file.size,
                                path: data.path,
                            });
                        }
                    } catch (error) {
                        showUploadStatus(
                            `‰∏äÂÇ≥ ${file.name} ÊôÇÁôºÁîüÈåØË™§: ${error.message}`,
                            "error"
                        );
                    }
                }

                if (uploadedFiles.length > 0) {
                    showUploadStatus(
                        `ÊàêÂäü‰∏äÂÇ≥ ${uploadedFiles.length} ÂÄãÊ™îÊ°à`,
                        "success"
                    );
                    displayUploadedFiles();
                    await loadBooksForUpload();

                    // Automatically analyze the first file to extract book info
                    if (uploadedFiles.length > 0) {
                        await analyzeFirstFileForBookInfo();
                    }
                }
            }

            async function analyzeFirstFileForBookInfo() {
                if (uploadedFiles.length === 0) return;
                
                // Make sure modal is closed first
                const modal = document.getElementById("uploadBookSelectionModal");
                if (modal) {
                    modal.classList.remove("active");
                }

                const firstFile = uploadedFiles[0];
                showUploadStatus("Ê≠£Âú®ÂàÜÊûêÁ¨¨‰∏ÄÂÄãÊ™îÊ°à‰ª•ÊèêÂèñÊõ∏Á±çË≥áË®ä...", "");

                try {
                    const response = await fetch("/api/upload/analyze", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            filename: firstFile.filename,
                            originalName: firstFile.originalName,
                        }),
                    });

                    const data = await response.json();
                    if (data.error) {
                        showUploadStatus(
                            `ÂàÜÊûêÂ§±Êïó: ${data.message}`,
                            "error"
                        );
                        return;
                    }

                    // Store analysis for all files
                    currentFileAnalysis = {
                        ...data,
                        allFiles: uploadedFiles,
                    };

                    // Show book selection modal with extracted info
                    showBookSelectionModal(data);
                } catch (error) {
                    console.error("Analyze error:", error);
                    showUploadStatus(
                        "ÂàÜÊûêÊôÇÁôºÁîüÈåØË™§: " + error.message,
                        "error"
                    );
                }
            }

            function showBookSelectionModal(analysis) {
                const modal = document.getElementById("uploadBookSelectionModal");
                if (!modal) {
                    console.error("Upload book selection modal not found");
                    return;
                }

                // Populate book metadata form from analysis
                const bookNameInput = document.getElementById("uploadNewBookName");
                if (bookNameInput && analysis.bookNameSimplified) {
                    bookNameInput.value = analysis.bookNameSimplified;
                }

                const authorInput = document.getElementById("uploadNewBookAuthor");
                if (authorInput && analysis.metadata?.author) {
                    authorInput.value = analysis.metadata.author;
                }

                const categoryInput = document.getElementById("uploadNewBookCategory");
                if (categoryInput && analysis.metadata?.category) {
                    categoryInput.value = analysis.metadata.category;
                }

                const descriptionInput = document.getElementById("uploadNewBookDescription");
                if (descriptionInput && analysis.metadata?.description) {
                    descriptionInput.value = analysis.metadata.description;
                }

                const sourceUrlInput = document.getElementById("uploadNewBookSourceUrl");
                if (sourceUrlInput && analysis.metadata?.sourceUrl) {
                    sourceUrlInput.value = analysis.metadata.sourceUrl;
                }

                // Show matched books
                const selector = document.getElementById("uploadBookSelector");
                if (selector && analysis.matchedBooks) {
                    selector.innerHTML = '<option value="new">Âª∫Á´ãÊñ∞Êõ∏Á±ç</option>';
                    analysis.matchedBooks.forEach((book) => {
                        const option = document.createElement("option");
                        option.value = book.id;
                        option.textContent =
                            book.book_name_traditional || book.book_name_simplified;
                        selector.appendChild(option);
                    });
                    
                    // Automatically select the first matched book if there is one
                    if (analysis.matchedBooks.length > 0) {
                        selector.value = analysis.matchedBooks[0].id;
                    }
                }

                // Show metadata form if creating new book
                toggleUploadBookMetadataForm();

                // Show file count
                const fileCountInfo = document.getElementById("uploadFileCountInfo");
                if (fileCountInfo) {
                    fileCountInfo.textContent = `ÂÖ± ${uploadedFiles.length} ÂÄãÊ™îÊ°àÂ∞áË¢´ËôïÁêÜ`;
                }

                // Show chapter preview
                const chapterPreview = document.getElementById("uploadChapterPreview");
                if (chapterPreview && analysis.chapters) {
                    const previewText = analysis.chapters
                        .slice(0, 10)
                        .map((ch, idx) => `${idx + 1}. ${ch.titleTraditional || ch.title}`)
                        .join("\n");
                    chapterPreview.textContent = previewText || "ÁÑ°Á´†ÁØÄË≥áË®ä";
                    if (analysis.totalChapters > 10) {
                        chapterPreview.textContent += `\n... ÈÇÑÊúâ ${analysis.totalChapters - 10} ÂÄãÁ´†ÁØÄ`;
                    }
                }

                modal.classList.add("active");
            }

            function displayUploadedFiles() {
                const uploadedFilesDiv =
                    document.getElementById("uploadedFiles");
                const uploadedFilesList =
                    document.getElementById("uploadedFilesList");

                if (uploadedFiles.length === 0) {
                    uploadedFilesDiv.style.display = "none";
                    return;
                }

                uploadedFilesDiv.style.display = "block";

                let html = "";
                uploadedFiles.forEach((file, index) => {
                    const sizeKB = (file.size / 1024).toFixed(2);
                    html += `
                    <div class="uploaded-file-item">
                        <div class="uploaded-file-info">
                            <div class="uploaded-file-name">${file.originalName}</div>
                            <div class="uploaded-file-size">${sizeKB} KB</div>
                        </div>
                        <div class="uploaded-file-actions">
                            <button class="button success" onclick="extractAndCreateBookFromFile(${index})" title="ÂæûÊ™îÊ°àÊèêÂèñÊõ∏Á±çË≥áË®ä‰∏¶Âª∫Á´ãÊñ∞Êõ∏">ÊèêÂèñ‰∏¶Âª∫Á´ã</button>
                            <button class="button secondary" onclick="removeUploadedFile(${index})">ÁßªÈô§</button>
                        </div>
                    </div>
                `;
                });

                uploadedFilesList.innerHTML = html;
                const uploadProcessSection = document.getElementById("uploadProcessSection");
                if (uploadProcessSection) {
                    uploadProcessSection.style.display = "block";
                }
            }

            function removeUploadedFile(index) {
                uploadedFiles.splice(index, 1);
                displayUploadedFiles();
            }

            async function extractAndCreateBookFromFile(index) {
                if (index < 0 || index >= uploadedFiles.length) {
                    showUploadStatus("ÁÑ°ÊïàÁöÑÊ™îÊ°àÁ¥¢Âºï", "error");
                    return;
                }

                const file = uploadedFiles[index];
                showUploadStatus(`Ê≠£Âú®Âæû ${file.originalName} ÊèêÂèñÊõ∏Á±çË≥áË®ä‰∏¶Âª∫Á´ãÊñ∞Êõ∏...`, "");

                try {
                    const response = await fetch("/api/upload/extract-and-create", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            filename: file.filename,
                            originalName: file.originalName,
                        }),
                    });

                    const data = await response.json();
                    if (data.error) {
                        showUploadStatus("ÊèêÂèñ‰∏¶Âª∫Á´ãÊõ∏Á±çÂ§±Êïó: " + data.message, "error");
                    } else {
                        // Check if any chapters were actually processed
                        if (data.chaptersInserted === 0 && data.chaptersUpdated === 0) {
                            if (data.totalChapters === 0) {
                                showUploadStatus(
                                    `Ë≠¶ÂëäÔºöÊ™îÊ°à‰∏≠Ê≤íÊúâÊâæÂà∞Á´†ÁØÄ„ÄÇÊõ∏Á±ç„Äå${data.bookName}„ÄçÂ∑≤${data.isNewBook ? 'Âª∫Á´ã' : 'Â≠òÂú®'}Ôºå‰ΩÜÊ≤íÊúâÁ´†ÁØÄË¢´Ê∑ªÂä†„ÄÇ`,
                                    "error"
                                );
                            } else if (data.chaptersErrored > 0) {
                                showUploadStatus(
                                    `ÈåØË™§ÔºöÊâÄÊúâÁ´†ÁØÄËôïÁêÜÂ§±ÊïóÔºà${data.chaptersErrored}/${data.totalChapters}Ôºâ„ÄÇË´ãÊ™¢Êü•‰º∫ÊúçÂô®Êó•Ë™å„ÄÇ`,
                                    "error"
                                );
                            } else {
                                showUploadStatus(
                                    `Ë≠¶ÂëäÔºöÊ≤íÊúâÁ´†ÁØÄË¢´Ê∑ªÂä†ÊàñÊõ¥Êñ∞„ÄÇÁ∏ΩÁ´†ÁØÄÊï∏Ôºö${data.totalChapters}`,
                                    "error"
                                );
                            }
                        } else {
                            if (data.isMerged) {
                                showUploadStatus(
                                    `Â∑≤Âêà‰ΩµÂà∞ÁèæÊúâÊõ∏Á±ç„Äå${data.bookName}„ÄçÔºÅÂ∑≤ËôïÁêÜ ${data.chaptersInserted} ÂÄãÊñ∞Á´†ÁØÄÔºå${data.chaptersUpdated} ÂÄãÁ´†ÁØÄÂ∑≤Êõ¥Êñ∞${data.chaptersErrored > 0 ? `Ôºå${data.chaptersErrored} ÂÄãÂ§±Êïó` : ''}`,
                                    data.chaptersErrored > 0 ? "error" : "success"
                                );
                            } else {
                                showUploadStatus(
                                    `ÊàêÂäüÂª∫Á´ãÊõ∏Á±ç„Äå${data.bookName}„ÄçÔºÅÂ∑≤ËôïÁêÜ ${data.chaptersInserted} ÂÄãÁ´†ÁØÄ${data.chaptersErrored > 0 ? `Ôºå${data.chaptersErrored} ÂÄãÂ§±Êïó` : ''}`,
                                    data.chaptersErrored > 0 ? "error" : "success"
                                );
                            }
                            
                            // Remove the processed file from the list
                            uploadedFiles.splice(index, 1);
                            displayUploadedFiles();
                            
                            // Reload books list
                            await loadBooks();
                            
                            // Switch to books tab after a delay to show the book
                            setTimeout(() => {
                                switchTab("books");
                            }, 2000);
                        }
                    }
                } catch (error) {
                    console.error("Error extracting and creating book:", error);
                    showUploadStatus("ÊèêÂèñ‰∏¶Âª∫Á´ãÊõ∏Á±çÊôÇÁôºÁîüÈåØË™§: " + error.message, "error");
                }
            }

            async function loadBooksForUpload() {
                try {
                    const response = await fetch("/api/books");
                    books = await response.json();
                    updateUploadBookSelector();
                } catch (error) {
                    console.error("Error loading books:", error);
                }
            }

            function updateUploadBookSelector() {
                const selector = document.getElementById("uploadBookSelector");
                selector.innerHTML = '<option value="new">Âª∫Á´ãÊñ∞Êõ∏Á±ç</option>';
                books.forEach((book) => {
                    const option = document.createElement("option");
                    option.value = book.id;
                    option.textContent =
                        book.book_name_traditional || book.book_name_simplified;
                    selector.appendChild(option);
                });
            }

            function toggleUploadBookMetadataForm() {
                const selector = document.getElementById("uploadBookSelector");
                const newBookForm = document.getElementById("uploadNewBookForm");
                if (newBookForm) {
                    newBookForm.style.display =
                        selector.value === "new" ? "block" : "none";
                }
            }

            function closeUploadBookSelectionModal() {
                const modal = document.getElementById("uploadBookSelectionModal");
                if (modal) {
                    modal.classList.remove("active");
                }
                // Clear uploaded files and analysis when modal is closed without processing
                uploadedFiles = [];
                currentFileAnalysis = null;
                displayUploadedFiles();
            }

            function showUploadStatus(message, type = "") {
                const statusDiv = document.getElementById("uploadStatus");
                statusDiv.style.display = "block";
                statusDiv.className = "status " + type;
                statusDiv.textContent = message;
                if (type === "success" || type === "error") {
                    setTimeout(() => {
                        statusDiv.style.display = "none";
                    }, 5000);
                }
            }

            async function processUploadedFiles() {
                if (uploadedFiles.length === 0) {
                    showUploadStatus("Ê≤íÊúâÂèØËôïÁêÜÁöÑÊ™îÊ°à", "error");
                    return;
                }

                const bookSelector =
                    document.getElementById("uploadBookSelector");
                
                let bookId =
                    bookSelector.value === "new"
                        ? null
                        : parseInt(bookSelector.value);
                let bookName = null;
                let bookMetadata = null;

                if (bookSelector.value === "new") {
                    // Get form data for new book
                    const newBookName = document
                        .getElementById("uploadNewBookName")
                        .value.trim();
                    
                    if (!newBookName) {
                        showUploadStatus("Ë´ãËº∏ÂÖ•Êñ∞Êõ∏Á±çÂêçÁ®±", "error");
                        return;
                    }
                    
                    bookName = newBookName;
                    
                    // Get metadata from form
                    bookMetadata = {
                        author: document.getElementById("uploadNewBookAuthor")?.value.trim() || null,
                        category: document.getElementById("uploadNewBookCategory")?.value.trim() || null,
                        description: document.getElementById("uploadNewBookDescription")?.value.trim() || null,
                        sourceUrl: document.getElementById("uploadNewBookSourceUrl")?.value.trim() || null,
                    };
                } else {
                    const selectedBook = books.find((b) => b.id === bookId);
                    bookName = selectedBook
                        ? selectedBook.book_name_simplified
                        : null;
                }

                // Close modal
                const modal = document.getElementById("uploadBookSelectionModal");
                if (modal) {
                    modal.classList.remove("active");
                }

                showUploadStatus(`Ê≠£Âú®ËôïÁêÜ ${uploadedFiles.length} ÂÄãÊ™îÊ°àÂà∞Âêå‰∏ÄÊú¨Êõ∏Á±ç...`, "");

                try {
                    let finalBookId = bookId;
                    let processedCount = 0;
                    let errorCount = 0;

                    // Process all files into the same book
                    for (let i = 0; i < uploadedFiles.length; i++) {
                        const file = uploadedFiles[i];
                        try {
                            const requestBody = {
                                filename: file.filename,
                                originalName: file.originalName,
                                bookId: finalBookId, // Use the same bookId for all files
                                bookName: bookName,
                            };
                            
                            // Include metadata only for the first file when creating new book
                            if (i === 0 && !finalBookId && bookMetadata) {
                                requestBody.bookMetadata = bookMetadata;
                            }
                            
                            const response = await fetch("/api/upload/process", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify(requestBody),
                            });

                            const data = await response.json();
                            if (data.error) {
                                errorCount++;
                                showUploadStatus(
                                    `ËôïÁêÜ ${file.originalName} Â§±Êïó: ${data.message}`,
                                    "error"
                                );
                            } else {
                                processedCount++;
                                // Update bookId after first file creates the book
                                if (!finalBookId && data.bookId) {
                                    finalBookId = data.bookId;
                                }
                                showUploadStatus(
                                    `Â∑≤ËôïÁêÜ ${processedCount}/${uploadedFiles.length} ÂÄãÊ™îÊ°à...`,
                                    ""
                                );
                            }
                        } catch (error) {
                            errorCount++;
                            console.error(`Error processing ${file.originalName}:`, error);
                        }
                    }

                    if (processedCount > 0) {
                        showUploadStatus(
                            `ÊàêÂäüËôïÁêÜ ${processedCount} ÂÄãÊ™îÊ°à${errorCount > 0 ? `Ôºå${errorCount} ÂÄãÂ§±Êïó` : ""}`,
                            "success"
                        );
                    } else {
                        showUploadStatus("ÊâÄÊúâÊ™îÊ°àËôïÁêÜÂ§±Êïó", "error");
                    }

                    uploadedFiles = [];
                    displayUploadedFiles();
                    currentFileAnalysis = null;
                    await loadBooks();

                    // Switch to books tab to see the result
                    setTimeout(() => {
                        switchTab("books");
                    }, 2000);
                } catch (error) {
                    console.error("Process error:", error);
                    showUploadStatus(
                        "ËôïÁêÜÊ™îÊ°àÊôÇÁôºÁîüÈåØË™§: " + error.message,
                        "error"
                    );
                }
            }

            // Bot Status Management
            let botStatusEventSource = null;
            let botOperations = [];

            function formatDuration(startTime) {
                if (!startTime) return "";
                const start = new Date(startTime);
                const now = new Date();
                const diff = Math.floor((now - start) / 1000);
                const minutes = Math.floor(diff / 60);
                const seconds = diff % 60;
                if (minutes > 0) {
                    return `${minutes}ÂàÜ${seconds}Áßí`;
                }
                return `${seconds}Áßí`;
            }

            function formatOperationType(type) {
                const types = {
                    search: "ÊêúÂ∞ã",
                    download: "‰∏ãËºâ",
                    upload: "‰∏äÂÇ≥",
                    export: "ÂåØÂá∫",
                };
                return types[type] || type;
            }

            function formatOperationStatus(status) {
                const statuses = {
                    active: "ÈÄ≤Ë°å‰∏≠",
                    completed: "Â∑≤ÂÆåÊàê",
                    failed: "Â§±Êïó",
                };
                return statuses[status] || status;
            }

            async function loadBotStatus() {
                try {
                    const response = await fetch("/api/bot-status/operations");
                    const data = await response.json();

                    if (data.success) {
                        botOperations = data.operations || [];
                        updateBotStatusIndicator(data.isActive);
                        updateBotStatusSummary(data.summary);
                        displayOperations(botOperations);
                    }
                } catch (error) {
                    console.error("Error loading bot status:", error);
                }
            }

            function updateBotStatusIndicator(isActive) {
                const indicator = document.getElementById("botStatusIndicator");
                if (isActive) {
                    indicator.textContent = "ÈÅã‰Ωú‰∏≠";
                    indicator.classList.add("active");
                } else {
                    indicator.textContent = "ÈñíÁΩÆ";
                    indicator.classList.remove("active");
                }
            }

            function updateBotStatusSummary(summary) {
                document.getElementById("summaryTotal").textContent =
                    summary.total || 0;
                document.getElementById("summaryActive").textContent =
                    summary.active || 0;

                let completed = 0;
                let failed = 0;
                Object.values(summary.byType || {}).forEach((type) => {
                    completed += type.completed || 0;
                    failed += type.failed || 0;
                });

                document.getElementById("summaryCompleted").textContent =
                    completed;
                document.getElementById("summaryFailed").textContent = failed;
            }

            function displayOperations(operations) {
                const operationsList =
                    document.getElementById("operationsList");

                if (operations.length === 0) {
                    operationsList.innerHTML =
                        '<div class="empty-operations">ÁõÆÂâçÊ≤íÊúâÈÄ≤Ë°å‰∏≠ÁöÑÊìç‰Ωú</div>';
                    return;
                }

                // Sort operations: active first, then by start time
                const sorted = [...operations].sort((a, b) => {
                    if (a.status === "active" && b.status !== "active")
                        return -1;
                    if (a.status !== "active" && b.status === "active")
                        return 1;
                    return new Date(b.startTime) - new Date(a.startTime);
                });

                let html = "";
                sorted.forEach((op) => {
                    const statusClass = op.status || "active";
                    const progress = op.progress || 0;
                    const progressClass =
                        op.status === "completed"
                            ? "completed"
                            : op.status === "failed"
                            ? "failed"
                            : "";

                    let details = "";
                    if (op.type === "search") {
                        details = `
                        <div>ÈóúÈçµÂ≠ó: ${op.keyword || "N/A"}</div>
                        <div>È†ÅÊï∏: ${op.pages || "N/A"}</div>
                        ${
                            op.totalResults !== undefined
                                ? `<div>ÁµêÊûúÊï∏: ${op.totalResults}</div>`
                                : ""
                        }
                    `;
                    } else if (op.type === "download") {
                        details = `
                        <div>Êõ∏Á±ç: ${op.bookName || "N/A"}</div>
                        <div>Á∏ΩÁ´†ÁØÄ: ${op.totalChapters || 0}</div>
                        <div>Â∑≤ÂÆåÊàê: ${op.completedChapters || 0}</div>
                        ${
                            op.failedChapters > 0
                                ? `<div style="color: #dc3545;">Â§±Êïó: ${op.failedChapters}</div>`
                                : ""
                        }
                    `;
                    } else if (op.type === "upload") {
                        details = `
                        <div>Ê™îÊ°à: ${op.filename || "N/A"}</div>
                        ${op.bookName ? `<div>Êõ∏Á±ç: ${op.bookName}</div>` : ""}
                        ${
                            op.totalChapters !== undefined
                                ? `<div>Á∏ΩÁ´†ÁØÄ: ${op.totalChapters || 0}</div>`
                                : ""
                        }
                        ${
                            op.completedChapters !== undefined
                                ? `<div>Â∑≤ÂÆåÊàê: ${
                                      op.completedChapters || 0
                                  }</div>`
                                : ""
                        }
                        ${
                            op.chaptersInserted !== undefined
                                ? `<div>ÊèíÂÖ•: ${op.chaptersInserted || 0}</div>`
                                : ""
                        }
                        ${
                            op.chaptersUpdated !== undefined
                                ? `<div>Êõ¥Êñ∞: ${op.chaptersUpdated || 0}</div>`
                                : ""
                        }
                        ${
                            op.failedChapters > 0 || op.chaptersErrored > 0
                                ? `<div style="color: #dc3545;">Â§±Êïó: ${
                                      op.failedChapters ||
                                      op.chaptersErrored ||
                                      0
                                  }</div>`
                                : ""
                        }
                    `;
                    } else if (op.type === "export") {
                        details = `
                        <div>Êõ∏Á±ç ID: ${op.bookId || "N/A"}</div>
                    `;
                    }

                    if (op.error) {
                        details += `<div style="color: #dc3545;">ÈåØË™§: ${op.error}</div>`;
                    }

                    html += `
                    <div class="operation-card ${statusClass}">
                        <div class="operation-header">
                            <div>
                                <span class="operation-title">${formatOperationType(
                                    op.type
                                )}</span>
                                <span class="operation-type-badge ${op.type}">${
                        op.type
                    }</span>
                            </div>
                            <span class="operation-status ${statusClass}">${formatOperationStatus(
                        op.status
                    )}</span>
                        </div>
                        ${
                            (op.type === "download" || op.type === "upload") &&
                            op.totalChapters > 0
                                ? `
                            <div class="operation-progress">
                                <div class="operation-progress-bar">
                                    <div class="operation-progress-fill ${progressClass}" style="width: ${progress}%;">
                                        ${progress}%
                                    </div>
                                </div>
                            </div>
                        `
                                : ""
                        }
                        <div class="operation-details">
                            ${details}
                        </div>
                        <div class="operation-time">
                            ÈñãÂßãÊôÇÈñì: ${
                                op.startTime
                                    ? new Date(op.startTime).toLocaleString(
                                          "zh-TW"
                                      )
                                    : "N/A"
                            }
                            ${
                                op.status === "active"
                                    ? ` | Âü∑Ë°åÊôÇÈñì: ${formatDuration(
                                          op.startTime
                                      )}`
                                    : ""
                            }
                            ${
                                op.endTime
                                    ? ` | ÁµêÊùüÊôÇÈñì: ${new Date(
                                          op.endTime
                                      ).toLocaleString("zh-TW")}`
                                    : ""
                            }
                        </div>
                    </div>
                `;
                });

                operationsList.innerHTML = html;
            }

            function refreshBotStatus() {
                loadBotStatus();
            }

            function startBotStatusStream() {
                // Close existing connection
                if (botStatusEventSource) {
                    botStatusEventSource.close();
                }

                // Connect to SSE stream
                botStatusEventSource = new EventSource(
                    "/api/bot-status/stream"
                );

                botStatusEventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === "status-update") {
                            botOperations = data.operations || [];
                            updateBotStatusIndicator(data.isActive);
                            updateBotStatusSummary(data.summary);

                            // Only update display if bot status tab is active
                            const botStatusTab =
                                document.getElementById("botStatusTab");
                            if (
                                botStatusTab &&
                                botStatusTab.classList.contains("active")
                            ) {
                                displayOperations(botOperations);
                            }
                        }
                    } catch (error) {
                        console.error("Error parsing bot status data:", error);
                    }
                };

                botStatusEventSource.onerror = (error) => {
                    console.error("Bot status SSE error:", error);
                    // Reconnect after 3 seconds
                    setTimeout(() => {
                        if (
                            botStatusEventSource &&
                            botStatusEventSource.readyState ===
                                EventSource.CLOSED
                        ) {
                            startBotStatusStream();
                        }
                    }, 3000);
                };
            }

            const searchHtmlInput = document.getElementById("searchHtmlInput");
            if (searchHtmlInput) {
                searchHtmlInput.addEventListener(
                    "change",
                    handleSearchHtmlUpload
                );
            }

            // Initialize
            // Load saved search state from localStorage
            loadSearchStateFromLocalStorage();

            // Restore search results display if available
            if (searchResults.length > 0) {
                displayResults(searchResults);
                updateSearchUrlDisplay();
                // Show retry and delete buttons if we have a last search
                if (lastSearchId) {
                    const retryBtn = document.getElementById("retrySearchBtn");
                    const deleteBtn =
                        document.getElementById("deleteSearchBtn");
                    if (retryBtn) retryBtn.style.display = "inline-block";
                    if (deleteBtn) deleteBtn.style.display = "inline-block";
                }
            }

            loadBooks();
            updateQueueDisplay();
            setupUploadArea();
            loadBotStatus();
            startBotStatusStream();
            
            // Setup draggable modal for book metadata
            (function setupDraggableModal() {
                const modalHeader = document.getElementById("bookMetadataModalHeader");
                const modalContent = document.getElementById("bookMetadataModalContent");
                
                if (!modalHeader || !modalContent) return;
                
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;
                
                modalHeader.addEventListener("mousedown", dragStart);
                document.addEventListener("mousemove", drag);
                document.addEventListener("mouseup", dragEnd);
                
                function dragStart(e) {
                    // Don't drag if clicking the close button
                    if (e.target.tagName === "BUTTON" || e.target.closest("button")) {
                        return;
                    }
                    
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === modalHeader || modalHeader.contains(e.target)) {
                        isDragging = true;
                        modalContent.style.cursor = "grabbing";
                    }
                }
                
                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        setTranslate(currentX, currentY, modalContent);
                    }
                }
                
                function dragEnd(e) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    modalContent.style.cursor = "";
                }
                
                function setTranslate(xPos, yPos, el) {
                    el.style.transform = `translate(${xPos}px, ${yPos}px)`;
                    el.style.top = "50%";
                    el.style.left = "50%";
                }
                
                // Reset position when modal is closed
                const originalCloseModal = closeBookMetadataModal;
                closeBookMetadataModal = function() {
                    xOffset = 0;
                    yOffset = 0;
                    originalCloseModal();
                };
            })();
        </script>
    </body>
</html>
