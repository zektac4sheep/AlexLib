<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alex Library</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #007bff;
            color: white;
            padding: 20px 30px;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header-icon {
            width: 32px;
            height: 32px;
            vertical-align: middle;
        }
        .tabs {
            display: flex;
            background: #e9ecef;
            border-bottom: 2px solid #dee2e6;
        }
        .tab {
            padding: 15px 30px;
            cursor: pointer;
            background: transparent;
            border: none;
            font-size: 16px;
            color: #495057;
            transition: all 0.3s;
            position: relative;
        }
        .tab:hover {
            background: #dee2e6;
        }
        .tab.active {
            background: white;
            color: #007bff;
            font-weight: bold;
        }
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: #007bff;
        }
        .tab-content {
            display: none;
            padding: 30px;
        }
        .tab-content.active {
            display: block;
        }
        .search-section {
            margin-bottom: 30px;
            display: flex;
            gap: 10px;
        }
        input[type="text"] {
            flex: 1;
            padding: 12px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        button.secondary {
            background: #6c757d;
        }
        button.secondary:hover {
            background: #5a6268;
        }
        button.success {
            background: #28a745;
        }
        button.success:hover {
            background: #218838;
        }
        .status {
            padding: 10px;
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            margin: 20px 0;
            display: none;
        }
        .status.error {
            background: #ffe7e7;
            border-left-color: #dc3545;
        }
        .status.success {
            background: #e7f7e7;
            border-left-color: #28a745;
        }
        .queue-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .queue-item {
            padding: 10px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .queue-item.processing {
            border-left: 4px solid #007bff;
        }
        .queue-item.completed {
            border-left: 4px solid #28a745;
        }
        .queue-item.error {
            border-left: 4px solid #dc3545;
        }
        .queue-keyword {
            font-weight: bold;
        }
        .queue-status {
            font-size: 14px;
            color: #666;
        }
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        .thread-item {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
            display: flex;
            align-items: start;
            gap: 15px;
        }
        .thread-item:hover {
            background: #f9f9f9;
        }
        .thread-checkbox {
            margin-top: 3px;
        }
        .thread-content {
            flex: 1;
        }
        .thread-title {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
            color: #333;
        }
        .thread-meta {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .thread-meta span {
            margin-right: 15px;
        }
        .chapter-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #007bff;
            color: white;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 10px;
        }
        .book-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #28a745;
            color: white;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 10px;
        }
        .selection-section {
            margin-top: 20px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 4px;
            display: none;
        }
        .selection-section.active {
            display: block;
        }
        .book-selector {
            margin-bottom: 15px;
        }
        .book-selector label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .book-selector select,
        .book-selector input {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .selected-count {
            margin-bottom: 15px;
            font-weight: bold;
            color: #007bff;
        }
        .books-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .book-card {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px;
            background: white;
        }
        .book-card:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .book-card.selected {
            border-color: #007bff;
            background: #f0f7ff;
        }
        .book-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 15px;
        }
        .book-card-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .book-card-checkbox {
            margin-top: 3px;
        }
        .book-card-meta {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        .book-card-meta div {
            margin-bottom: 5px;
        }
        .book-card-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        .book-card-actions button {
            flex: 1;
            padding: 8px;
            font-size: 14px;
        }
        .results-list {
            max-height: 600px;
            overflow-y: auto;
        }
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }
        .bulk-actions {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 15px;
            border-top: 2px solid #eee;
            margin-top: 20px;
            display: none;
        }
        .bulk-actions.active {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .bulk-actions-info {
            font-weight: bold;
            color: #007bff;
        }
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #f9f9f9;
            transition: all 0.3s;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .upload-area:hover {
            border-color: #007bff;
            background: #f0f7ff;
        }
        .upload-area.dragover {
            border-color: #007bff;
            background: #e7f3ff;
        }
        .upload-area-icon {
            font-size: 48px;
            color: #999;
            margin-bottom: 15px;
        }
        .upload-area-text {
            font-size: 16px;
            color: #666;
            margin-bottom: 10px;
        }
        .upload-area-hint {
            font-size: 14px;
            color: #999;
        }
        .uploaded-files {
            margin-top: 20px;
        }
        .uploaded-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .uploaded-file-info {
            flex: 1;
        }
        .uploaded-file-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .uploaded-file-size {
            font-size: 14px;
            color: #666;
        }
        .uploaded-file-actions {
            display: flex;
            gap: 10px;
        }
        .file-input {
            display: none;
        }
        .progress-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .progress-modal.active {
            display: flex;
        }
        .progress-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .progress-bar {
            height: 100%;
            background: #007bff;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }
        .progress-logs {
            max-height: 300px;
            overflow-y: auto;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .progress-log-item {
            margin-bottom: 5px;
            padding: 5px;
        }
        .progress-log-item.error {
            color: #dc3545;
        }
        .progress-log-item.success {
            color: #28a745;
        }
        .bot-status-indicator {
            display: inline-block;
            margin-left: 15px;
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: normal;
            background: #6c757d;
            color: white;
        }
        .bot-status-indicator.active {
            background: #28a745;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .bot-status-summary {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .bot-status-summary-item {
            flex: 1;
            text-align: center;
        }
        .bot-status-summary-item-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .bot-status-summary-item-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .operation-card {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            background: white;
        }
        .operation-card.active {
            border-left: 4px solid #007bff;
        }
        .operation-card.completed {
            border-left: 4px solid #28a745;
        }
        .operation-card.failed {
            border-left: 4px solid #dc3545;
        }
        .operation-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }
        .operation-title {
            font-weight: bold;
            font-size: 16px;
        }
        .operation-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 10px;
        }
        .operation-type-badge.search {
            background: #17a2b8;
            color: white;
        }
        .operation-type-badge.download {
            background: #007bff;
            color: white;
        }
        .operation-type-badge.upload {
            background: #ffc107;
            color: #333;
        }
        .operation-type-badge.export {
            background: #28a745;
            color: white;
        }
        .operation-status {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
            background: #e9ecef;
            color: #495057;
        }
        .operation-status.active {
            background: #cfe2ff;
            color: #084298;
        }
        .operation-status.completed {
            background: #d1e7dd;
            color: #0f5132;
        }
        .operation-status.failed {
            background: #f8d7da;
            color: #842029;
        }
        .operation-progress {
            margin-top: 10px;
        }
        .operation-progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .operation-progress-fill {
            height: 100%;
            background: #007bff;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
        }
        .operation-progress-fill.completed {
            background: #28a745;
        }
        .operation-progress-fill.failed {
            background: #dc3545;
        }
        .operation-details {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
        }
        .operation-details div {
            margin-bottom: 5px;
        }
        .operation-time {
            font-size: 12px;
            color: #999;
            margin-top: 10px;
        }
        .empty-operations {
            text-align: center;
            padding: 40px;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <a href="https://game-icons.net/1x1/lorc/cat.html" target="_blank" rel="noopener noreferrer" style="text-decoration: none;">
                    <img src="https://game-icons.net/icons/000000/transparent/1x1/lorc/cat.svg" alt="Cat Icon" class="header-icon" style="filter: brightness(0) invert(1);">
                </a>
                Alex Library <span id="botStatusIndicator" class="bot-status-indicator">é–’ç½®</span>
            </h1>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('search')">æœå°‹</button>
            <button class="tab" onclick="switchTab('results')">æœå°‹çµæœ</button>
            <button class="tab" onclick="switchTab('books')">æ›¸ç±</button>
            <button class="tab" onclick="switchTab('upload')">ä¸Šå‚³æª”æ¡ˆ</button>
            <button class="tab" onclick="switchTab('botStatus')">æ©Ÿå™¨äººç‹€æ…‹</button>
        </div>

        <!-- Search Tab -->
        <div id="searchTab" class="tab-content active">
            <div class="search-section">
                <input type="text" id="searchInput" placeholder="è¼¸å…¥é—œéµå­—æœå°‹ (ä¾‹å¦‚: éƒ½å¸‚ã€å¤è£)" onkeypress="if(event.key==='Enter') addToQueue()">
                <button id="searchBtn" onclick="addToQueue()">åŠ å…¥æœå°‹ä½‡åˆ—</button>
                <button class="button secondary" onclick="triggerSearchHtmlUpload()">åŒ¯å…¥æœå°‹HTML</button>
                <input type="file" id="searchHtmlInput" class="file-input" accept=".html,.htm,.txt">
            </div>
            <div id="status" class="status"></div>
            
            <div class="queue-section">
                <h3>æœå°‹ä½‡åˆ—</h3>
                <div id="queueList"></div>
            </div>
        </div>

        <!-- Results Tab -->
        <div id="resultsTab" class="tab-content">
            <div class="results-header">
                <h3>æœå°‹çµæœ</h3>
            </div>
            <div id="searchUrlDisplay" style="display: none; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #007bff;">
                <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ç›®æ¨™ç¶²å€ï¼š</div>
                <div style="font-size: 16px;">
                    <a id="searchUrlLink" href="#" target="_blank" rel="noopener noreferrer" style="color: #007bff; text-decoration: none; word-break: break-all;">
                        <span id="searchUrlText"></span>
                    </a>
                    <button onclick="copySearchUrl()" style="margin-left: 10px; padding: 5px 10px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">è¤‡è£½</button>
                </div>
            </div>
            <div id="resultsList" class="results-list"></div>
            
            <div id="selectionSection" class="selection-section">
                <div class="selected-count" id="selectedCount">å·²é¸æ“‡ 0 å€‹ç« ç¯€</div>
                <div class="book-selector">
                    <label>é¸æ“‡æ›¸ç±ï¼š</label>
                    <select id="bookSelector" onchange="toggleBookNameInput()">
                        <option value="new">å»ºç«‹æ–°æ›¸ç±</option>
                    </select>
                    <input type="text" id="newBookName" placeholder="æ–°æ›¸ç±åç¨± (ç°¡é«”ä¸­æ–‡)" style="margin-top: 10px; display: none;">
                </div>
                <button onclick="startDownload()" id="downloadBtn" disabled>ä¸‹è¼‰é¸ä¸­çš„ç« ç¯€</button>
            </div>
        </div>

        <!-- Book Metadata Modal -->
        <div id="bookMetadataModal" class="progress-modal">
            <div class="progress-content" style="max-width: 700px;">
                <div class="progress-header">
                    <h3>ç¢ºèªæ›¸ç±è³‡è¨Š</h3>
                    <button onclick="closeBookMetadataModal()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                </div>
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; margin-bottom: 15px;">è«‹ç¢ºèªä¸¦ç·¨è¼¯ä»¥ä¸‹è³‡è¨Šï¼Œé€™äº›è³‡è¨Šå°‡ç”¨æ–¼å»ºç«‹æ–°æ›¸ç±ï¼š</p>
                    <form id="bookMetadataForm">
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ›¸åï¼ˆç°¡é«”ï¼‰:</label>
                            <input type="text" id="metadataBookName" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" required>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ›¸åï¼ˆç¹é«”ï¼‰:</label>
                            <input type="text" id="metadataBookNameTraditional" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä½œè€…:</label>
                            <input type="text" id="metadataAuthor" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">é¡åˆ¥:</label>
                            <input type="text" id="metadataCategory" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ¨™ç±¤ï¼ˆç”¨é€—è™Ÿåˆ†éš”ï¼‰:</label>
                            <input type="text" id="metadataTags" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="ä¾‹å¦‚: å°èªª, éƒ½å¸‚, æˆäºº">
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">æè¿°:</label>
                            <textarea id="metadataDescription" rows="4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä¾†æºç¶²å€:</label>
                            <input type="text" id="metadataSourceUrl" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" readonly>
                        </div>
                    </form>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeBookMetadataModal()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
                    <button onclick="confirmBookMetadata()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">ç¢ºèªä¸¦é–‹å§‹ä¸‹è¼‰</button>
                </div>
            </div>
        </div>

        <!-- Missing Chapters Modal -->
        <div id="missingChaptersModal" class="progress-modal">
            <div class="progress-content" style="max-width: 800px;">
                <div class="progress-header">
                    <h3>ç¼ºå¤±ç« ç¯€æœå°‹çµæœ</h3>
                    <button onclick="closeMissingChaptersModal()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                </div>
                <div id="missingChaptersContent"></div>
            </div>
        </div>

        <!-- Progress Modal -->
        <div id="progressModal" class="progress-modal">
            <div class="progress-content">
                <div class="progress-header">
                    <h3>ä¸‹è¼‰é€²åº¦</h3>
                    <button onclick="closeProgressModal()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                </div>
                <div class="progress-bar-container">
                    <div id="progressBar" class="progress-bar" style="width: 0%;">0%</div>
                </div>
                <div id="progressStats" style="margin-bottom: 15px;">
                    <div>å·²å®Œæˆ: <span id="progressCompleted">0</span> / <span id="progressTotal">0</span></div>
                    <div>å¤±æ•—: <span id="progressFailed">0</span></div>
                </div>
                <div class="progress-logs" id="progressLogs"></div>
            </div>
        </div>

        <!-- Upload Tab -->
        <div id="uploadTab" class="tab-content">
            <div class="results-header">
                <h3>ä¸Šå‚³æª”æ¡ˆè™•ç†</h3>
            </div>
            <p style="margin-bottom: 20px; color: #666;">
                æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ï¼šhtml.txt (è«–å£‡ç´¢å¼•)ã€å–®ä¸€åŸ·è¡Œç·’ HTMLã€raw.txtã€pre_content_0.md
            </p>
            
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <div class="upload-area-icon">ğŸ“</div>
                <div class="upload-area-text">é»æ“Šæˆ–æ‹–æ”¾æª”æ¡ˆåˆ°æ­¤è™•ä¸Šå‚³</div>
                <div class="upload-area-hint">æ”¯æ´å¤šæª”æ¡ˆä¸Šå‚³</div>
            </div>
            <input type="file" id="fileInput" class="file-input" multiple accept=".txt,.html,.md" onchange="handleFileSelect(event)">
            
            <div id="uploadStatus" class="status" style="display: none;"></div>
            
            <div class="uploaded-files" id="uploadedFiles" style="display: none;">
                <h4 style="margin-bottom: 15px;">å·²ä¸Šå‚³çš„æª”æ¡ˆ</h4>
                <div id="uploadedFilesList"></div>
                
                <div id="uploadProcessSection" class="selection-section" style="margin-top: 20px;">
                    <div class="book-selector">
                        <label>é¸æ“‡æ›¸ç±ï¼š</label>
                        <select id="uploadBookSelector" onchange="toggleUploadBookNameInput()">
                            <option value="new">å»ºç«‹æ–°æ›¸ç±</option>
                        </select>
                        <input type="text" id="uploadNewBookName" placeholder="æ–°æ›¸ç±åç¨± (ç°¡é«”ä¸­æ–‡)" style="margin-top: 10px; display: none;">
                    </div>
                    <button onclick="processUploadedFiles()" id="processUploadBtn" class="button success">è™•ç†é¸ä¸­çš„æª”æ¡ˆ</button>
                </div>
            </div>
        </div>

        <!-- Books Tab -->
        <div id="booksTab" class="tab-content">
            <div class="results-header">
                <h3>æˆ‘çš„æ›¸ç±</h3>
                <div>
                    <button class="button secondary" onclick="refreshBooks()">é‡æ–°æ•´ç†</button>
                    <button class="button success" id="exportToJoplinBtn" onclick="exportSelectedToJoplin()" disabled>åŒ¯å‡ºé¸ä¸­æ›¸ç±åˆ° Joplin</button>
                </div>
            </div>
            <div id="booksGrid" class="books-grid"></div>
            <div id="bulkActions" class="bulk-actions">
                <div class="bulk-actions-info" id="bulkActionsInfo">å·²é¸æ“‡ 0 æœ¬æ›¸ç±</div>
                <button class="button success" onclick="exportSelectedToJoplin()">åŒ¯å‡ºé¸ä¸­æ›¸ç±åˆ° Joplin</button>
            </div>
        </div>

        <!-- Bot Status Tab -->
        <div id="botStatusTab" class="tab-content">
            <div class="results-header">
                <h3>æ©Ÿå™¨äººç‹€æ…‹</h3>
                <button class="button secondary" onclick="refreshBotStatus()">é‡æ–°æ•´ç†</button>
            </div>
            
            <div class="bot-status-summary" id="botStatusSummary">
                <div class="bot-status-summary-item">
                    <div class="bot-status-summary-item-value" id="summaryTotal">0</div>
                    <div class="bot-status-summary-item-label">ç¸½æ“ä½œæ•¸</div>
                </div>
                <div class="bot-status-summary-item">
                    <div class="bot-status-summary-item-value" id="summaryActive">0</div>
                    <div class="bot-status-summary-item-label">é€²è¡Œä¸­</div>
                </div>
                <div class="bot-status-summary-item">
                    <div class="bot-status-summary-item-value" id="summaryCompleted">0</div>
                    <div class="bot-status-summary-item-label">å·²å®Œæˆ</div>
                </div>
                <div class="bot-status-summary-item">
                    <div class="bot-status-summary-item-value" id="summaryFailed">0</div>
                    <div class="bot-status-summary-item-label">å¤±æ•—</div>
                </div>
            </div>

            <div id="operationsList"></div>
        </div>
    </div>

    <script>
        // Global state
        let searchQueue = [];
        let searchResults = [];
        let selectedThreads = new Set();
        let books = [];
        let selectedBooks = new Set();
        let currentSearchId = null;
        let lastSearchParams = null; // Store last search keyword and pages for retry
        let lastSearchId = null; // Store last search ID for deletion
        let currentSearchKeyword = null; // Store current search keyword for URL display

        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach((tab, index) => {
                tab.classList.remove('active');
                if ((tabName === 'search' && index === 0) ||
                    (tabName === 'results' && index === 1) ||
                    (tabName === 'books' && index === 2) ||
                    (tabName === 'upload' && index === 3)) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Load data when switching tabs
            if (tabName === 'books') {
                loadBooks();
            } else if (tabName === 'upload') {
                loadBooksForUpload();
            } else if (tabName === 'botStatus') {
                loadBotStatus();
            }
        }

        // Search Queue Management
        function addToQueue() {
            const keyword = document.getElementById('searchInput').value.trim();
            if (!keyword) {
                showStatus('è«‹è¼¸å…¥æœå°‹é—œéµå­—', 'error');
                return;
            }

            const searchId = Date.now();
            const queueItem = {
                id: searchId,
                keyword: keyword,
                pages: 3, // Default to 3 pages
                status: 'pending',
                results: null
            };

            searchQueue.push(queueItem);
            document.getElementById('searchInput').value = '';
            updateQueueDisplay();
            
            // Start processing if not already processing
            if (!currentSearchId) {
                processQueue();
            }
        }

        function updateQueueDisplay() {
            const queueList = document.getElementById('queueList');
            if (searchQueue.length === 0) {
                queueList.innerHTML = '<div class="empty-state">ä½‡åˆ—ç‚ºç©º</div>';
                return;
            }

            let html = '';
            searchQueue.forEach(item => {
                const statusClass = item.status === 'processing' ? 'processing' : 
                                   item.status === 'completed' ? 'completed' : 
                                   item.status === 'error' ? 'error' : '';
                const statusText = item.status === 'processing' ? 'æœå°‹ä¸­...' :
                                  item.status === 'completed' ? `å®Œæˆ (${item.results?.length || 0} çµæœ)` :
                                  item.status === 'error' ? 'éŒ¯èª¤' : 'ç­‰å¾…ä¸­';
                
                html += `
                    <div class="queue-item ${statusClass}">
                        <div>
                            <div class="queue-keyword">${item.keyword}</div>
                            <div class="queue-status">${statusText}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            ${item.status === 'completed' ? `<button class="button" onclick="viewResults(${item.id})">æŸ¥çœ‹çµæœ</button>` : ''}
                            ${item.status !== 'processing' ? `<button class="button secondary" onclick="retrySearch(${item.id})">é‡æ–°æœå°‹</button>` : ''}
                            ${item.status !== 'processing' ? `<button class="button secondary" onclick="removeSearch(${item.id})" style="background: #dc3545; color: white;">ç§»é™¤</button>` : ''}
                        </div>
                    </div>
                `;
            });
            queueList.innerHTML = html;
        }

        async function processQueue() {
            const pendingItem = searchQueue.find(item => item.status === 'pending');
            if (!pendingItem) {
                currentSearchId = null;
                updateQueueDisplay(); // Update display when queue is empty
                return;
            }

            currentSearchId = pendingItem.id;
            pendingItem.status = 'processing';
            updateQueueDisplay();

            try {
                const pages = pendingItem.pages || 3;
                const response = await fetch(`/api/search?keyword=${encodeURIComponent(pendingItem.keyword)}&pages=${pages}`);
                const data = await response.json();

                if (data.error) {
                    pendingItem.status = 'error';
                    showStatus('æœå°‹å¤±æ•—: ' + data.message, 'error');
                } else {
                    pendingItem.status = 'completed';
                    pendingItem.results = data.threads || [];
                    pendingItem.dbSearchId = data.searchResultId || null; // Store database ID
                    // Store last search params for retry
                    currentSearchKeyword = pendingItem.keyword;
                    lastSearchParams = {
                        keyword: pendingItem.keyword,
                        pages: pages
                    };
                    lastSearchId = pendingItem.id;
                    // Show retry and delete buttons
                    document.getElementById('retrySearchBtn').style.display = 'inline-block';
                    document.getElementById('deleteSearchBtn').style.display = 'inline-block';
                    showStatus(`æœå°‹å®Œæˆ: æ‰¾åˆ° ${pendingItem.results.length} å€‹çµæœ`, 'success');
                }
            } catch (error) {
                pendingItem.status = 'error';
                showStatus('æœå°‹æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            } finally {
                updateQueueDisplay();
                // Process next item
                setTimeout(() => {
                    processQueue();
                }, 500);
            }
        }

        function viewResults(searchId) {
            const queueItem = searchQueue.find(item => item.id === searchId);
            if (!queueItem || !queueItem.results) return;

            searchResults = queueItem.results;
            currentSearchKeyword = queueItem.keyword;
            lastSearchId = searchId;
            lastSearchParams = {
                keyword: queueItem.keyword,
                pages: queueItem.pages || 3
            };
            // Show retry and delete buttons
            document.getElementById('retrySearchBtn').style.display = 'inline-block';
            document.getElementById('deleteSearchBtn').style.display = 'inline-block';
            displayResults(searchResults);
            updateSearchUrlDisplay();
            switchTab('results');
        }

        function clearResults() {
            searchResults = [];
            selectedThreads.clear();
            displayResults([]);
            document.getElementById('selectionSection').classList.remove('active');
            lastSearchParams = null;
            lastSearchId = null;
            document.getElementById('retrySearchBtn').style.display = 'none';
            document.getElementById('deleteSearchBtn').style.display = 'none';
        }

        async function deleteLastSearch() {
            if (!lastSearchId) {
                showStatus('æ²’æœ‰å¯åˆªé™¤çš„æœå°‹', 'error');
                return;
            }

            // Remove from queue
            const queueItem = searchQueue.find(item => item.id === lastSearchId);
            if (queueItem && queueItem.status === 'processing') {
                showStatus('ç„¡æ³•åˆªé™¤æ­£åœ¨è™•ç†ä¸­çš„æœå°‹', 'error');
                return;
            }

            // Delete from database if it has a dbSearchId
            if (queueItem && queueItem.dbSearchId) {
                try {
                    const response = await fetch(`/api/search/${queueItem.dbSearchId}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) {
                        console.error('Failed to delete search from database');
                    }
                } catch (error) {
                    console.error('Error deleting search from database:', error);
                }
            }

            searchQueue = searchQueue.filter(item => item.id !== lastSearchId);
            
            // If it was the current search, clear it
            if (currentSearchId === lastSearchId) {
                currentSearchId = null;
            }

            // Clear results if viewing this search
            if (searchResults.length > 0) {
                clearResults();
            }

            updateQueueDisplay();
            showStatus('å·²åˆªé™¤æœå°‹', 'success');
        }

        function retryLastSearch() {
            if (!lastSearchParams) {
                showStatus('æ²’æœ‰å¯é‡è©¦çš„æœå°‹', 'error');
                return;
            }

            // Add to queue with same params
            const searchId = Date.now();
            const queueItem = {
                id: searchId,
                keyword: lastSearchParams.keyword,
                pages: lastSearchParams.pages,
                status: 'pending',
                results: null
            };

            searchQueue.push(queueItem);
            updateQueueDisplay();
            
            // Start processing if not already processing
            if (!currentSearchId) {
                processQueue();
            }

            showStatus('å·²åŠ å…¥æœå°‹ä½‡åˆ—', 'success');
        }

        function retrySearch(searchId) {
            const queueItem = searchQueue.find(item => item.id === searchId);
            if (!queueItem) return;

            const newItem = {
                id: Date.now(),
                keyword: queueItem.keyword,
                pages: queueItem.pages || 3,
                status: 'pending',
                results: null
            };

            searchQueue.push(newItem);
            updateQueueDisplay();
            
            // Start processing if not already processing
            if (!currentSearchId) {
                processQueue();
            }

            showStatus('å·²é‡æ–°åŠ å…¥æœå°‹', 'success');
        }

        async function removeSearch(searchId) {
            // Don't remove if currently processing
            const queueItem = searchQueue.find(item => item.id === searchId);
            if (queueItem && queueItem.status === 'processing') {
                showStatus('ç„¡æ³•ç§»é™¤æ­£åœ¨è™•ç†ä¸­çš„æœå°‹', 'error');
                return;
            }

            // Delete from database if it has a dbSearchId
            if (queueItem && queueItem.dbSearchId) {
                try {
                    const response = await fetch(`/api/search/${queueItem.dbSearchId}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) {
                        console.error('Failed to delete search from database');
                    }
                } catch (error) {
                    console.error('Error deleting search from database:', error);
                }
            }

            // Remove from queue
            searchQueue = searchQueue.filter(item => item.id !== searchId);
            
            // If it was the current search, clear it
            if (currentSearchId === searchId) {
                currentSearchId = null;
            }

            updateQueueDisplay();
            showStatus('å·²ç§»é™¤æœå°‹', 'success');
        }

        // Update search URL display
        function updateSearchUrlDisplay() {
            const searchUrlDisplay = document.getElementById('searchUrlDisplay');
            const searchUrlLink = document.getElementById('searchUrlLink');
            const searchUrlText = document.getElementById('searchUrlText');
            
            if (currentSearchKeyword) {
                const baseUrl = 'https://www.cool18.com/bbs4';
                const searchUrl = `${baseUrl}/index.php?app=forum&act=search&keyword=${encodeURIComponent(currentSearchKeyword)}&page=1`;
                searchUrlLink.href = searchUrl;
                searchUrlText.textContent = searchUrl;
                searchUrlDisplay.style.display = 'block';
            } else {
                searchUrlDisplay.style.display = 'none';
            }
        }

        // Copy search URL to clipboard
        function copySearchUrl() {
            const searchUrlLink = document.getElementById('searchUrlLink');
            const url = searchUrlLink.href;
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(url).then(() => {
                    showStatus('ç¶²å€å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿', 'success');
                }).catch(err => {
                    console.error('Failed to copy URL:', err);
                    showStatus('è¤‡è£½å¤±æ•—', 'error');
                });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = url;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showStatus('ç¶²å€å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿', 'success');
                } catch (err) {
                    showStatus('è¤‡è£½å¤±æ•—', 'error');
                }
                document.body.removeChild(textArea);
            }
        }

        // Results Display
        function displayResults(threads) {
            const resultsList = document.getElementById('resultsList');
            
            if (threads.length === 0) {
                resultsList.innerHTML = '<div class="empty-state">æ²’æœ‰çµæœ</div>';
                updateSearchUrlDisplay();
                return;
            }

            let html = '';
            threads.forEach((thread, index) => {
                const isSelected = selectedThreads.has(index);
                html += `
                    <div class="thread-item">
                        <input type="checkbox" class="thread-checkbox" data-index="${index}" ${isSelected ? 'checked' : ''} onchange="toggleThread(${index})">
                        <div class="thread-content">
                            <div class="thread-title">
                                ${thread.titleTraditional || thread.title}
                                ${thread.chapterNumber ? `<span class="chapter-badge">ç¬¬${thread.chapterNumber}${thread.chapterFormat || 'ç« '}</span>` : ''}
                                ${thread.bookNameTraditional ? `<span class="book-badge">${thread.bookNameTraditional}</span>` : ''}
                            </div>
                            <div class="thread-meta">
                                ${thread.url ? `<span><a href="${thread.url}" target="_blank" rel="noopener noreferrer" style="color: #007bff; text-decoration: none;">ğŸ”— æŸ¥çœ‹åŸæ–‡</a></span>` : ''}
                                ${thread.date ? `<span>æ—¥æœŸ: ${thread.date}</span>` : ''}
                                ${thread.replies !== undefined ? `<span>å›è¦†: ${thread.replies}</span>` : ''}
                                ${thread.existingBookId ? `<span style="color: #28a745;">âœ“ å·²å­˜åœ¨æ–¼è³‡æ–™åº«</span>` : ''}
                            </div>
                        </div>
                    </div>
                `;
            });

            resultsList.innerHTML = html;
            updateSearchUrlDisplay();
        }

        function toggleThread(index) {
            const checkbox = document.querySelector(`.thread-checkbox[data-index="${index}"]`);
            if (checkbox.checked) {
                selectedThreads.add(index);
            } else {
                selectedThreads.delete(index);
            }
            updateSelectionUI();
        }

        function updateSelectionUI() {
            const count = selectedThreads.size;
            document.getElementById('selectedCount').textContent = `å·²é¸æ“‡ ${count} å€‹ç« ç¯€`;
            document.getElementById('downloadBtn').disabled = count === 0;
            
            const selectionSection = document.getElementById('selectionSection');
            if (count > 0) {
                selectionSection.classList.add('active');
            } else {
                selectionSection.classList.remove('active');
            }
        }

        function toggleBookNameInput() {
            const selector = document.getElementById('bookSelector');
            const newBookInput = document.getElementById('newBookName');
            newBookInput.style.display = selector.value === 'new' ? 'block' : 'none';
        }

        let pendingDownloadData = null; // Store download data while showing metadata modal

        async function startDownload() {
            const selected = Array.from(selectedThreads).map(i => searchResults[i]);
            const bookSelector = document.getElementById('bookSelector');
            const newBookName = document.getElementById('newBookName').value.trim();
            
            let bookId = bookSelector.value === 'new' ? null : parseInt(bookSelector.value);
            let bookName = null;

            if (bookSelector.value === 'new') {
                if (!newBookName) {
                    showStatus('è«‹è¼¸å…¥æ–°æ›¸ç±åç¨±', 'error');
                    return;
                }
                bookName = newBookName;
            } else {
                const selectedBook = books.find(b => b.id === bookId);
                bookName = selectedBook ? selectedBook.book_name_simplified : null;
            }

            const chapters = selected.map(thread => ({
                url: thread.url,
                title: thread.title,
                chapterNum: thread.chapterNumber
            }));

            // If creating a new book, extract metadata from first chapter URL
            if (bookSelector.value === 'new' && chapters.length > 0) {
                showStatus('æ­£åœ¨æå–æ›¸ç±è³‡è¨Š...', '');
                try {
                    const response = await fetch('/api/books/extract-metadata', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ url: chapters[0].url })
                    });

                    const metadata = await response.json();
                    if (metadata.error) {
                        showStatus('æå–è³‡è¨Šå¤±æ•—ï¼Œå°‡ä½¿ç”¨é è¨­å€¼: ' + metadata.message, 'warning');
                        // Continue with download using default values
                        proceedWithDownload(chapters, bookId, bookName, null);
                    } else {
                        // Show metadata modal for confirmation
                        showBookMetadataModal(metadata, chapters, bookId, bookName);
                    }
                } catch (error) {
                    console.error('Metadata extraction error:', error);
                    showStatus('æå–è³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œå°‡ä½¿ç”¨é è¨­å€¼', 'warning');
                    // Continue with download using default values
                    proceedWithDownload(chapters, bookId, bookName, null);
                }
            } else {
                // Existing book, proceed directly
                proceedWithDownload(chapters, bookId, bookName, null);
            }
        }

        function showBookMetadataModal(metadata, chapters, bookId, bookName) {
            // Populate form with extracted metadata
            document.getElementById('metadataBookName').value = metadata.bookName || bookName || '';
            document.getElementById('metadataBookNameTraditional').value = metadata.bookNameTraditional || '';
            document.getElementById('metadataAuthor').value = metadata.author || '';
            document.getElementById('metadataCategory').value = metadata.category || '';
            document.getElementById('metadataTags').value = (metadata.tags || []).join(', ');
            document.getElementById('metadataDescription').value = metadata.description || '';
            document.getElementById('metadataSourceUrl').value = metadata.sourceUrl || '';

            // Store download data
            pendingDownloadData = { chapters, bookId, bookName };

            // Update modal title and button
            const modalTitle = document.querySelector('#bookMetadataModal .progress-header h3');
            const confirmButton = document.querySelector('#bookMetadataModal button[onclick="confirmBookMetadata()"]');
            modalTitle.textContent = 'ç¢ºèªæ›¸ç±è³‡è¨Š';
            confirmButton.textContent = 'ç¢ºèªä¸¦é–‹å§‹ä¸‹è¼‰';

            // Show modal
            document.getElementById('bookMetadataModal').classList.add('active');
        }

        function closeBookMetadataModal() {
            document.getElementById('bookMetadataModal').classList.remove('active');
            pendingDownloadData = null;
        }

        async function confirmBookMetadata() {
            if (!pendingDownloadData) return;

            // Get form values
            const bookMetadata = {
                bookName: document.getElementById('metadataBookName').value.trim(),
                bookNameTraditional: document.getElementById('metadataBookNameTraditional').value.trim(),
                author: document.getElementById('metadataAuthor').value.trim(),
                category: document.getElementById('metadataCategory').value.trim(),
                tags: document.getElementById('metadataTags').value.split(',').map(t => t.trim()).filter(t => t),
                description: document.getElementById('metadataDescription').value.trim(),
                sourceUrl: document.getElementById('metadataSourceUrl').value.trim()
            };

            if (!bookMetadata.bookName) {
                showStatus('è«‹è¼¸å…¥æ›¸å', 'error');
                return;
            }

            closeBookMetadataModal();

            // If editing existing book
            if (pendingDownloadData.isEdit) {
                try {
                    showStatus('æ­£åœ¨æ›´æ–°æ›¸ç±è³‡è¨Š...', '');
                    const response = await fetch(`/api/books/${pendingDownloadData.bookId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            book_name_simplified: bookMetadata.bookName,
                            book_name_traditional: bookMetadata.bookNameTraditional,
                            author: bookMetadata.author,
                            category: bookMetadata.category,
                            description: bookMetadata.description,
                            source_url: bookMetadata.sourceUrl,
                            tags: bookMetadata.tags
                        })
                    });

                    const data = await response.json();
                    if (data.error) {
                        showStatus('æ›´æ–°å¤±æ•—: ' + data.error, 'error');
                    } else {
                        showStatus('æ›¸ç±è³‡è¨Šå·²æ›´æ–°', 'success');
                        await loadBooks();
                    }
                } catch (error) {
                    console.error('Update error:', error);
                    showStatus('æ›´æ–°æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
                }
            } else {
                // Creating new book and downloading
                proceedWithDownload(pendingDownloadData.chapters, pendingDownloadData.bookId, bookMetadata.bookName, bookMetadata);
            }
        }

        async function proceedWithDownload(chapters, bookId, bookName, bookMetadata) {
            showStatus('æº–å‚™ä¸‹è¼‰...', '');
            
            try {
                const response = await fetch('/api/download/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chapters, bookId, bookName, bookMetadata })
                });

                const data = await response.json();
                if (data.error) {
                    showStatus('ä¸‹è¼‰å¤±æ•—: ' + data.message, 'error');
                } else {
                    showStatus(`ä¸‹è¼‰ä»»å‹™å·²å»ºç«‹ (ID: ${data.jobId})`, 'success');
                    selectedThreads.clear();
                    updateSelectionUI();
                    // Open progress view
                    showDownloadProgress(data.jobId, data.totalChapters);
                    await loadBooks();
                }
            } catch (error) {
                console.error('Download error:', error);
                showStatus('ä¸‹è¼‰æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        }

        // Books Management
        async function loadBooks() {
            try {
                const response = await fetch('/api/books');
                books = await response.json();
                updateBookSelector();
                displayBooks();
            } catch (error) {
                console.error('Error loading books:', error);
                showStatus('è¼‰å…¥æ›¸ç±å¤±æ•—: ' + error.message, 'error');
            }
        }

        function updateBookSelector() {
            const selector = document.getElementById('bookSelector');
            selector.innerHTML = '<option value="new">å»ºç«‹æ–°æ›¸ç±</option>';
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.book_name_traditional || book.book_name_simplified;
                selector.appendChild(option);
            });
        }

        function displayBooks() {
            const booksGrid = document.getElementById('booksGrid');
            
            if (books.length === 0) {
                booksGrid.innerHTML = '<div class="empty-state">é‚„æ²’æœ‰æ›¸ç±</div>';
                return;
            }

            let html = '';
            books.forEach(book => {
                const isSelected = selectedBooks.has(book.id);
                const chapterRange = book.min_chapter && book.max_chapter 
                    ? `ç¬¬${book.min_chapter}ç«  ~ ç¬¬${book.max_chapter}ç« `
                    : 'ç„¡ç« ç¯€';
                
                html += `
                    <div class="book-card ${isSelected ? 'selected' : ''}" onclick="toggleBookSelection(${book.id}, event)">
                        <div class="book-card-header">
                            <div>
                                <div class="book-card-title">${book.book_name_traditional || book.book_name_simplified}</div>
                                <div class="book-card-meta">
                                    <div>ä½œè€…: ${book.author || 'æœªçŸ¥'}</div>
                                    <div>ç« ç¯€: ${chapterRange}</div>
                                    <div>ç™¼å¸ƒæ—¥æœŸ: ${book.release_date || 'æœªçŸ¥'}</div>
                                    <div>æœ€å¾Œæ›´æ–°: ${book.last_updated ? new Date(book.last_updated).toLocaleDateString('zh-TW') : 'æœªçŸ¥'}</div>
                                </div>
                            </div>
                            <input type="checkbox" class="book-card-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleBookSelection(${book.id}, event)">
                        </div>
                        <div class="book-card-actions">
                            <button class="button" onclick="event.stopPropagation(); viewBookDetails(${book.id})">æŸ¥çœ‹è©³æƒ…</button>
                            <button class="button" onclick="event.stopPropagation(); editBookMetadata(${book.id})">ç·¨è¼¯è³‡è¨Š</button>
                            <button class="button" onclick="event.stopPropagation(); searchMissingChapters(${book.id})">æœå°‹ç¼ºå¤±ç« ç¯€</button>
                            <button class="button success" onclick="event.stopPropagation(); exportBookToJoplin(${book.id})">åŒ¯å‡ºåˆ° Joplin</button>
                        </div>
                    </div>
                `;
            });

            booksGrid.innerHTML = html;
            updateBulkActions();
        }

        function toggleBookSelection(bookId, event) {
            if (selectedBooks.has(bookId)) {
                selectedBooks.delete(bookId);
            } else {
                selectedBooks.add(bookId);
            }
            displayBooks();
        }

        function updateBulkActions() {
            const count = selectedBooks.size;
            const bulkActions = document.getElementById('bulkActions');
            const bulkActionsInfo = document.getElementById('bulkActionsInfo');
            const exportBtn = document.getElementById('exportToJoplinBtn');
            
            if (count > 0) {
                bulkActions.classList.add('active');
                bulkActionsInfo.textContent = `å·²é¸æ“‡ ${count} æœ¬æ›¸ç±`;
                exportBtn.disabled = false;
            } else {
                bulkActions.classList.remove('active');
                exportBtn.disabled = true;
            }
        }

        async function exportSelectedToJoplin() {
            const bookIds = Array.from(selectedBooks);
            if (bookIds.length === 0) {
                showStatus('è«‹é¸æ“‡è¦åŒ¯å‡ºçš„æ›¸ç±', 'error');
                return;
            }

            showStatus(`æ­£åœ¨åŒ¯å‡º ${bookIds.length} æœ¬æ›¸ç±åˆ° Joplin...`, '');
            
            try {
                for (const bookId of bookIds) {
                    const response = await fetch(`/api/joplin/export/${bookId}`, {
                        method: 'POST'
                    });
                    const data = await response.json();
                    if (data.error) {
                        showStatus(`åŒ¯å‡ºæ›¸ç± ID ${bookId} å¤±æ•—: ${data.message}`, 'error');
                    }
                }
                showStatus(`æˆåŠŸåŒ¯å‡º ${bookIds.length} æœ¬æ›¸ç±åˆ° Joplin`, 'success');
                selectedBooks.clear();
                displayBooks();
            } catch (error) {
                console.error('Export error:', error);
                showStatus('åŒ¯å‡ºæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        }

        async function exportBookToJoplin(bookId) {
            showStatus('æ­£åœ¨åŒ¯å‡ºåˆ° Joplin...', '');
            
            try {
                const response = await fetch(`/api/joplin/export/${bookId}`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.error) {
                    showStatus('åŒ¯å‡ºå¤±æ•—: ' + data.message, 'error');
                } else {
                    showStatus('æˆåŠŸåŒ¯å‡ºåˆ° Joplin', 'success');
                }
            } catch (error) {
                console.error('Export error:', error);
                showStatus('åŒ¯å‡ºæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        }

        function viewBookDetails(bookId) {
            // TODO: Implement book details view
            alert('æŸ¥çœ‹è©³æƒ…åŠŸèƒ½é–‹ç™¼ä¸­');
        }

        async function editBookMetadata(bookId) {
            try {
                const response = await fetch(`/api/books/${bookId}`);
                const book = await response.json();
                
                if (book.error) {
                    showStatus('è¼‰å…¥æ›¸ç±è³‡è¨Šå¤±æ•—: ' + book.error, 'error');
                    return;
                }

                // Populate form with existing book data
                document.getElementById('metadataBookName').value = book.book_name_simplified || '';
                document.getElementById('metadataBookNameTraditional').value = book.book_name_traditional || '';
                document.getElementById('metadataAuthor').value = book.author || '';
                document.getElementById('metadataCategory').value = book.category || '';
                document.getElementById('metadataTags').value = (book.tags || []).join(', ');
                document.getElementById('metadataDescription').value = book.description || '';
                document.getElementById('metadataSourceUrl').value = book.source_url || '';

                // Store book ID for update
                pendingDownloadData = { bookId, isEdit: true };

                // Update modal title and button
                const modalTitle = document.querySelector('#bookMetadataModal .progress-header h3');
                const confirmButton = document.querySelector('#bookMetadataModal button[onclick="confirmBookMetadata()"]');
                modalTitle.textContent = 'ç·¨è¼¯æ›¸ç±è³‡è¨Š';
                confirmButton.textContent = 'ç¢ºèªæ›´æ–°';

                // Show modal
                document.getElementById('bookMetadataModal').classList.add('active');
            } catch (error) {
                console.error('Error loading book:', error);
                showStatus('è¼‰å…¥æ›¸ç±è³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        }

        async function searchMissingChapters(bookId) {
            try {
                showStatus('æ­£åœ¨åˆ†æç¼ºå¤±ç« ç¯€...', '');
                
                // First, get missing chapters
                const missingResponse = await fetch(`/api/books/${bookId}/missing-chapters`);
                const missingData = await missingResponse.json();
                
                if (missingData.error) {
                    showStatus('åˆ†æå¤±æ•—: ' + missingData.error, 'error');
                    return;
                }

                if (missingData.missingChapters.length === 0) {
                    showStatus('æ²’æœ‰ç™¼ç¾ç¼ºå¤±ç« ç¯€ï¼', 'success');
                    return;
                }

                // Get book info
                const bookResponse = await fetch(`/api/books/${bookId}`);
                const book = await bookResponse.json();

                showStatus(`ç™¼ç¾ ${missingData.missingChapters.length} å€‹ç¼ºå¤±ç« ç¯€ï¼Œæ­£åœ¨æœå°‹...`, '');
                
                // Search for missing chapters
                const searchResponse = await fetch(`/api/books/${bookId}/search-missing`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        missingChapters: missingData.missingChapters,
                        bookName: book.book_name_simplified
                    })
                });

                const searchData = await searchResponse.json();
                
                if (searchData.error) {
                    showStatus('æœå°‹å¤±æ•—: ' + searchData.error, 'error');
                    return;
                }

                // Show results in modal
                showMissingChaptersModal(bookId, missingData, searchData);
            } catch (error) {
                console.error('Error searching missing chapters:', error);
                showStatus('æœå°‹æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        }

        function showMissingChaptersModal(bookId, missingData, searchData) {
            const modal = document.getElementById('missingChaptersModal');
            const content = document.getElementById('missingChaptersContent');
            
            let html = `
                <div style="margin-bottom: 20px;">
                    <h4>ç¼ºå¤±ç« ç¯€åˆ†æ</h4>
                    <p>ç¸½ç« ç¯€ç¯„åœ: ç¬¬${missingData.minChapter}ç«  ~ ç¬¬${missingData.maxChapter}ç« </p>
                    <p>å·²ä¸‹è¼‰: ${missingData.totalChapters} ç« </p>
                    <p>ç¼ºå¤±: ${missingData.missingChapters.length} ç« </p>
                </div>
            `;

            if (searchData.foundChapters.length === 0) {
                html += `
                    <div style="padding: 20px; background: #fff3cd; border-radius: 4px; margin-bottom: 20px;">
                        <p>æœªæ‰¾åˆ°ä»»ä½•ç¼ºå¤±ç« ç¯€çš„çµæœã€‚</p>
                        <p>ç¼ºå¤±çš„ç« ç¯€: ${missingData.missingChapters.join(', ')}</p>
                    </div>
                `;
            } else {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4>æ‰¾åˆ° ${searchData.foundChapters.length} å€‹ç« ç¯€</h4>
                        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                `;

                const selectedChapters = new Set();
                searchData.foundChapters.forEach(ch => {
                    const isMulti = ch.isMultiChapter ? ' (å¤šç« ç¯€)' : '';
                    html += `
                        <div style="padding: 10px; border-bottom: 1px solid #eee;">
                            <label style="display: flex; align-items: start; cursor: pointer;">
                                <input type="checkbox" value="${ch.url}" data-chapter="${ch.chapterNumber}" 
                                    style="margin-right: 10px; margin-top: 3px;" 
                                    onchange="toggleMissingChapter(this, ${ch.chapterNumber})">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold;">ç¬¬${ch.chapterNumber}ç« ${isMulti}</div>
                                    <div style="color: #666; font-size: 14px; margin-top: 5px;">${ch.title}</div>
                                    ${ch.isMultiChapter ? `<div style="color: #007bff; font-size: 12px; margin-top: 3px;">åŒ…å«ç« ç¯€: ${ch.range || ch.chapters.join(', ')}</div>` : ''}
                                    <div style="color: #999; font-size: 12px; margin-top: 3px;">${ch.date || ''}</div>
                                </div>
                            </label>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeMissingChaptersModal()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
                        <button onclick="downloadMissingChapters(${bookId})" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">ä¸‹è¼‰é¸ä¸­çš„ç« ç¯€</button>
                    </div>
                `;
            }

            content.innerHTML = html;
            window.missingChaptersData = { bookId, searchData };
            modal.classList.add('active');
        }

        function closeMissingChaptersModal() {
            document.getElementById('missingChaptersModal').classList.remove('active');
            window.missingChaptersData = null;
        }

        function toggleMissingChapter(checkbox, chapterNumber) {
            if (!window.missingChaptersData) return;
            // This is handled by the checkbox state
        }

        async function downloadMissingChapters(bookId) {
            if (!window.missingChaptersData) return;

            const checkboxes = document.querySelectorAll('#missingChaptersContent input[type="checkbox"]:checked');
            if (checkboxes.length === 0) {
                showStatus('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹ç« ç¯€', 'error');
                return;
            }

            const chapters = Array.from(checkboxes).map(cb => {
                const chapterData = window.missingChaptersData.searchData.foundChapters.find(
                    ch => ch.url === cb.value
                );
                return {
                    url: cb.value,
                    title: chapterData.title,
                    chapterNum: parseInt(cb.dataset.chapter)
                };
            });

            closeMissingChaptersModal();
            
            // Get book name
            const bookResponse = await fetch(`/api/books/${bookId}`);
            const book = await bookResponse.json();

            proceedWithDownload(chapters, bookId, book.book_name_simplified, null);
        }

        function refreshBooks() {
            loadBooks();
        }

        function showStatus(message, type = '') {
            const statusDiv = document.getElementById('status');
            statusDiv.style.display = 'block';
            statusDiv.className = 'status ' + type;
            statusDiv.textContent = message;
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Download Progress
        let progressEventSource = null;

        function showDownloadProgress(jobId, totalChapters) {
            const modal = document.getElementById('progressModal');
            const progressBar = document.getElementById('progressBar');
            const progressLogs = document.getElementById('progressLogs');
            const progressCompleted = document.getElementById('progressCompleted');
            const progressTotal = document.getElementById('progressTotal');
            const progressFailed = document.getElementById('progressFailed');

            modal.classList.add('active');
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressLogs.innerHTML = '';
            progressCompleted.textContent = '0';
            progressTotal.textContent = totalChapters || '0';
            progressFailed.textContent = '0';

            // Close any existing connection
            if (progressEventSource) {
                progressEventSource.close();
            }

            // Connect to SSE stream
            progressEventSource = new EventSource(`/api/download/${jobId}/stream`);

            progressEventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleProgressUpdate(data, progressBar, progressLogs, progressCompleted, progressTotal, progressFailed, totalChapters);
                } catch (error) {
                    console.error('Error parsing progress data:', error);
                }
            };

            progressEventSource.onerror = (error) => {
                console.error('SSE error:', error);
                addProgressLog(progressLogs, 'é€£æ¥éŒ¯èª¤ï¼Œè«‹åˆ·æ–°é é¢æŸ¥çœ‹ç‹€æ…‹', 'error');
            };
        }

        function handleProgressUpdate(data, progressBar, progressLogs, progressCompleted, progressTotal, progressFailed, totalChapters) {
            switch (data.type) {
                case 'connected':
                    addProgressLog(progressLogs, 'å·²é€£æ¥åˆ°ä¸‹è¼‰æœå‹™', 'success');
                    break;
                case 'job-start':
                    addProgressLog(progressLogs, data.message, 'success');
                    break;
                case 'chapter-start':
                    addProgressLog(progressLogs, data.message);
                    break;
                case 'chapter-complete':
                    addProgressLog(progressLogs, data.message, 'success');
                    updateProgress(progressBar, progressCompleted, progressTotal, progressFailed, totalChapters);
                    break;
                case 'chapter-skipped':
                    addProgressLog(progressLogs, data.message);
                    updateProgress(progressBar, progressCompleted, progressTotal, progressFailed, totalChapters);
                    break;
                case 'chapter-error':
                    addProgressLog(progressLogs, data.message, 'error');
                    updateProgress(progressBar, progressCompleted, progressTotal, progressFailed, totalChapters);
                    break;
                case 'job-complete':
                    addProgressLog(progressLogs, data.message, 'success');
                    updateProgress(progressBar, progressCompleted, progressTotal, progressFailed, totalChapters);
                    if (progressEventSource) {
                        progressEventSource.close();
                        progressEventSource = null;
                    }
                    // Auto-close after 3 seconds
                    setTimeout(() => {
                        closeProgressModal();
                        loadBooks();
                    }, 3000);
                    break;
                case 'job-error':
                    addProgressLog(progressLogs, data.message, 'error');
                    if (progressEventSource) {
                        progressEventSource.close();
                        progressEventSource = null;
                    }
                    break;
            }
        }

        function addProgressLog(logsContainer, message, type = '') {
            const logItem = document.createElement('div');
            logItem.className = `progress-log-item ${type}`;
            logItem.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logsContainer.appendChild(logItem);
            logsContainer.scrollTop = logsContainer.scrollHeight;
        }

        function updateProgress(progressBar, progressCompleted, progressTotal, progressFailed, totalChapters) {
            // Fetch current status from API
            const jobId = progressEventSource ? progressEventSource.url.match(/\/download\/(\d+)\/stream/)[1] : null;
            if (jobId) {
                fetch(`/api/download/${jobId}/status`)
                    .then(res => res.json())
                    .then(job => {
                        const completed = job.completed_chapters || 0;
                        const failed = job.failed_chapters || 0;
                        const total = job.total_chapters || totalChapters || 0;
                        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

                        progressBar.style.width = `${percentage}%`;
                        progressBar.textContent = `${percentage}%`;
                        progressCompleted.textContent = completed;
                        progressTotal.textContent = total;
                        progressFailed.textContent = failed;
                    })
                    .catch(error => console.error('Error fetching progress:', error));
            }
        }

        function closeProgressModal() {
            const modal = document.getElementById('progressModal');
            modal.classList.remove('active');
            if (progressEventSource) {
                progressEventSource.close();
                progressEventSource = null;
            }
        }

        // Upload Management
        let uploadedFiles = [];

        function setupUploadArea() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            // Drag and drop handlers
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                handleFiles(files);
            });
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            handleFiles(files);
        }

        async function handleFiles(files) {
            const validFiles = files.filter(file => {
                const ext = file.name.split('.').pop().toLowerCase();
                return ['txt', 'html', 'md'].includes(ext);
            });

            if (validFiles.length === 0) {
                showUploadStatus('è«‹é¸æ“‡æœ‰æ•ˆçš„æª”æ¡ˆæ ¼å¼ (.txt, .html, .md)', 'error');
                return;
            }

            showUploadStatus(`æ­£åœ¨ä¸Šå‚³ ${validFiles.length} å€‹æª”æ¡ˆ...`, '');

            for (const file of validFiles) {
                try {
                    const formData = new FormData();
                    formData.append('file', file);

                    const response = await fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    });

                    const data = await response.json();
                    if (data.error) {
                        showUploadStatus(`ä¸Šå‚³ ${file.name} å¤±æ•—: ${data.message}`, 'error');
                    } else {
                        uploadedFiles.push({
                            filename: data.filename,
                            originalName: file.name,
                            size: file.size,
                            path: data.path
                        });
                    }
                } catch (error) {
                    showUploadStatus(`ä¸Šå‚³ ${file.name} æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`, 'error');
                }
            }

            if (uploadedFiles.length > 0) {
                showUploadStatus(`æˆåŠŸä¸Šå‚³ ${uploadedFiles.length} å€‹æª”æ¡ˆ`, 'success');
                displayUploadedFiles();
                await loadBooksForUpload();
            }
        }

        function displayUploadedFiles() {
            const uploadedFilesDiv = document.getElementById('uploadedFiles');
            const uploadedFilesList = document.getElementById('uploadedFilesList');

            if (uploadedFiles.length === 0) {
                uploadedFilesDiv.style.display = 'none';
                return;
            }

            uploadedFilesDiv.style.display = 'block';

            let html = '';
            uploadedFiles.forEach((file, index) => {
                const sizeKB = (file.size / 1024).toFixed(2);
                html += `
                    <div class="uploaded-file-item">
                        <div class="uploaded-file-info">
                            <div class="uploaded-file-name">${file.originalName}</div>
                            <div class="uploaded-file-size">${sizeKB} KB</div>
                        </div>
                        <div class="uploaded-file-actions">
                            <button class="button secondary" onclick="removeUploadedFile(${index})">ç§»é™¤</button>
                        </div>
                    </div>
                `;
            });

            uploadedFilesList.innerHTML = html;
            document.getElementById('uploadProcessSection').style.display = 'block';
        }

        function removeUploadedFile(index) {
            uploadedFiles.splice(index, 1);
            displayUploadedFiles();
        }

        async function loadBooksForUpload() {
            try {
                const response = await fetch('/api/books');
                books = await response.json();
                updateUploadBookSelector();
            } catch (error) {
                console.error('Error loading books:', error);
            }
        }

        function updateUploadBookSelector() {
            const selector = document.getElementById('uploadBookSelector');
            selector.innerHTML = '<option value="new">å»ºç«‹æ–°æ›¸ç±</option>';
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.book_name_traditional || book.book_name_simplified;
                selector.appendChild(option);
            });
        }

        function toggleUploadBookNameInput() {
            const selector = document.getElementById('uploadBookSelector');
            const newBookInput = document.getElementById('uploadNewBookName');
            newBookInput.style.display = selector.value === 'new' ? 'block' : 'none';
        }

        function showUploadStatus(message, type = '') {
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.style.display = 'block';
            statusDiv.className = 'status ' + type;
            statusDiv.textContent = message;
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        async function processUploadedFiles() {
            if (uploadedFiles.length === 0) {
                showUploadStatus('æ²’æœ‰å¯è™•ç†çš„æª”æ¡ˆ', 'error');
                return;
            }

            const bookSelector = document.getElementById('uploadBookSelector');
            const newBookName = document.getElementById('uploadNewBookName').value.trim();
            
            let bookId = bookSelector.value === 'new' ? null : parseInt(bookSelector.value);
            let bookName = null;

            if (bookSelector.value === 'new') {
                if (!newBookName) {
                    showUploadStatus('è«‹è¼¸å…¥æ–°æ›¸ç±åç¨±', 'error');
                    return;
                }
                bookName = newBookName;
            } else {
                const selectedBook = books.find(b => b.id === bookId);
                bookName = selectedBook ? selectedBook.book_name_simplified : null;
            }

            showUploadStatus('æ­£åœ¨è™•ç†æª”æ¡ˆ...', '');

            try {
                for (const file of uploadedFiles) {
                    const response = await fetch('/api/upload/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: file.filename,
                            bookId: bookId,
                            bookName: bookName
                        })
                    });

                    const data = await response.json();
                    if (data.error) {
                        showUploadStatus(`è™•ç† ${file.originalName} å¤±æ•—: ${data.message}`, 'error');
                    }
                }

                showUploadStatus('æª”æ¡ˆè™•ç†å®Œæˆ', 'success');
                uploadedFiles = [];
                displayUploadedFiles();
                await loadBooks();
                
                // Switch to books tab to see the result
                setTimeout(() => {
                    switchTab('books');
                }, 2000);
            } catch (error) {
                console.error('Process error:', error);
                showUploadStatus('è™•ç†æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        }

        // Bot Status Management
        let botStatusEventSource = null;
        let botOperations = [];

        function formatDuration(startTime) {
            if (!startTime) return '';
            const start = new Date(startTime);
            const now = new Date();
            const diff = Math.floor((now - start) / 1000);
            const minutes = Math.floor(diff / 60);
            const seconds = diff % 60;
            if (minutes > 0) {
                return `${minutes}åˆ†${seconds}ç§’`;
            }
            return `${seconds}ç§’`;
        }

        function formatOperationType(type) {
            const types = {
                'search': 'æœå°‹',
                'download': 'ä¸‹è¼‰',
                'upload': 'ä¸Šå‚³',
                'export': 'åŒ¯å‡º'
            };
            return types[type] || type;
        }

        function formatOperationStatus(status) {
            const statuses = {
                'active': 'é€²è¡Œä¸­',
                'completed': 'å·²å®Œæˆ',
                'failed': 'å¤±æ•—'
            };
            return statuses[status] || status;
        }

        async function loadBotStatus() {
            try {
                const response = await fetch('/api/bot-status/operations');
                const data = await response.json();
                
                if (data.success) {
                    botOperations = data.operations || [];
                    updateBotStatusIndicator(data.isActive);
                    updateBotStatusSummary(data.summary);
                    displayOperations(botOperations);
                }
            } catch (error) {
                console.error('Error loading bot status:', error);
            }
        }

        function updateBotStatusIndicator(isActive) {
            const indicator = document.getElementById('botStatusIndicator');
            if (isActive) {
                indicator.textContent = 'é‹ä½œä¸­';
                indicator.classList.add('active');
            } else {
                indicator.textContent = 'é–’ç½®';
                indicator.classList.remove('active');
            }
        }

        function updateBotStatusSummary(summary) {
            document.getElementById('summaryTotal').textContent = summary.total || 0;
            document.getElementById('summaryActive').textContent = summary.active || 0;
            
            let completed = 0;
            let failed = 0;
            Object.values(summary.byType || {}).forEach(type => {
                completed += type.completed || 0;
                failed += type.failed || 0;
            });
            
            document.getElementById('summaryCompleted').textContent = completed;
            document.getElementById('summaryFailed').textContent = failed;
        }

        function displayOperations(operations) {
            const operationsList = document.getElementById('operationsList');
            
            if (operations.length === 0) {
                operationsList.innerHTML = '<div class="empty-operations">ç›®å‰æ²’æœ‰é€²è¡Œä¸­çš„æ“ä½œ</div>';
                return;
            }

            // Sort operations: active first, then by start time
            const sorted = [...operations].sort((a, b) => {
                if (a.status === 'active' && b.status !== 'active') return -1;
                if (a.status !== 'active' && b.status === 'active') return 1;
                return new Date(b.startTime) - new Date(a.startTime);
            });

            let html = '';
            sorted.forEach(op => {
                const statusClass = op.status || 'active';
                const progress = op.progress || 0;
                const progressClass = op.status === 'completed' ? 'completed' : 
                                     op.status === 'failed' ? 'failed' : '';
                
                let details = '';
                if (op.type === 'search') {
                    details = `
                        <div>é—œéµå­—: ${op.keyword || 'N/A'}</div>
                        <div>é æ•¸: ${op.pages || 'N/A'}</div>
                        ${op.totalResults !== undefined ? `<div>çµæœæ•¸: ${op.totalResults}</div>` : ''}
                    `;
                } else if (op.type === 'download') {
                    details = `
                        <div>æ›¸ç±: ${op.bookName || 'N/A'}</div>
                        <div>ç¸½ç« ç¯€: ${op.totalChapters || 0}</div>
                        <div>å·²å®Œæˆ: ${op.completedChapters || 0}</div>
                        ${op.failedChapters > 0 ? `<div style="color: #dc3545;">å¤±æ•—: ${op.failedChapters}</div>` : ''}
                    `;
                } else if (op.type === 'upload') {
                    details = `
                        <div>æª”æ¡ˆ: ${op.filename || 'N/A'}</div>
                    `;
                } else if (op.type === 'export') {
                    details = `
                        <div>æ›¸ç± ID: ${op.bookId || 'N/A'}</div>
                    `;
                }

                if (op.error) {
                    details += `<div style="color: #dc3545;">éŒ¯èª¤: ${op.error}</div>`;
                }

                html += `
                    <div class="operation-card ${statusClass}">
                        <div class="operation-header">
                            <div>
                                <span class="operation-title">${formatOperationType(op.type)}</span>
                                <span class="operation-type-badge ${op.type}">${op.type}</span>
                            </div>
                            <span class="operation-status ${statusClass}">${formatOperationStatus(op.status)}</span>
                        </div>
                        ${(op.type === 'download' && op.totalChapters > 0) ? `
                            <div class="operation-progress">
                                <div class="operation-progress-bar">
                                    <div class="operation-progress-fill ${progressClass}" style="width: ${progress}%;">
                                        ${progress}%
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        <div class="operation-details">
                            ${details}
                        </div>
                        <div class="operation-time">
                            é–‹å§‹æ™‚é–“: ${op.startTime ? new Date(op.startTime).toLocaleString('zh-TW') : 'N/A'}
                            ${op.status === 'active' ? ` | åŸ·è¡Œæ™‚é–“: ${formatDuration(op.startTime)}` : ''}
                            ${op.endTime ? ` | çµæŸæ™‚é–“: ${new Date(op.endTime).toLocaleString('zh-TW')}` : ''}
                        </div>
                    </div>
                `;
            });

            operationsList.innerHTML = html;
        }

        function refreshBotStatus() {
            loadBotStatus();
        }

        function startBotStatusStream() {
            // Close existing connection
            if (botStatusEventSource) {
                botStatusEventSource.close();
            }

            // Connect to SSE stream
            botStatusEventSource = new EventSource('/api/bot-status/stream');

            botStatusEventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'status-update') {
                        botOperations = data.operations || [];
                        updateBotStatusIndicator(data.isActive);
                        updateBotStatusSummary(data.summary);
                        
                        // Only update display if bot status tab is active
                        const botStatusTab = document.getElementById('botStatusTab');
                        if (botStatusTab && botStatusTab.classList.contains('active')) {
                            displayOperations(botOperations);
                        }
                    }
                } catch (error) {
                    console.error('Error parsing bot status data:', error);
                }
            };

            botStatusEventSource.onerror = (error) => {
                console.error('Bot status SSE error:', error);
                // Reconnect after 3 seconds
                setTimeout(() => {
                    if (botStatusEventSource && botStatusEventSource.readyState === EventSource.CLOSED) {
                        startBotStatusStream();
                    }
                }, 3000);
            };
        }

        const searchHtmlInput = document.getElementById('searchHtmlInput');
        if (searchHtmlInput) {
            searchHtmlInput.addEventListener('change', handleSearchHtmlUpload);
        }

        // Initialize
        loadBooks();
        updateQueueDisplay();
        setupUploadArea();
        loadBotStatus();
        startBotStatusStream();
    </script>
</body>
</html>

